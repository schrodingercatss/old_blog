<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哲♂学家的小黑屋</title>
  
  <subtitle>Rick&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maojunjie666.top/"/>
  <updated>2018-09-06T04:56:39.562Z</updated>
  <id>http://maojunjie666.top/</id>
  
  <author>
    <name>Schoringercatss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 D题：Tu Hao&#39;s Problem</title>
    <link href="http://maojunjie666.top/2018/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AC%AC39%E9%98%B6%E5%8F%B0%E9%98%B6/"/>
    <id>http://maojunjie666.top/2018/09/06/动态规划/第39阶台阶/</id>
    <published>2018-09-06T03:49:45.622Z</published>
    <updated>2018-09-06T04:56:39.562Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/D" target="_blank" rel="noopener">题目传送门</a></p><p>这题是蓝桥杯的一道填空题改编过来的，因为是填空题，数据量也比较小，可以直接使用暴力递归的方式来解决，但是在oj上有时间限制1s，使用递归肯定会超时。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> stair,<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//stari用于表示剩余的楼梯的层数，当等于0时停止递归</span></span><br><span class="line"><span class="comment">//step是走过的步数，用来判断是否是偶数，是否符合要求</span></span><br><span class="line"> <span class="keyword">if</span>(stair&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">if</span>(stair==<span class="number">0</span>)<span class="comment">//39节楼梯全部走完</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(step%<span class="number">2</span> == <span class="number">0</span>)cnt++;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> func(stair<span class="number">-1</span>,step+<span class="number">1</span>);<span class="comment">//这一步走了一个台阶</span></span><br><span class="line"> func(stair<span class="number">-2</span>,step+<span class="number">1</span>);<span class="comment">//这一步走了两个台阶</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        func(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候如果再使用暴力递归就会超时，所以得采用动态规划的方法，先提取出递归式，然后把递归得到的值用数组存储起来，避免重复计算，省去了大部分的时间。我们在纸上先推导：</p><pre><code>1.如果只有一级台阶，那么最后一步是左脚的话，方法一共是1种，就是直接迈左脚上一级台阶，任务就完成了，可是如果最后一步是右脚的话，没有办法，因为先迈左脚，直接完成任务了，右脚都出不来。。。所以最后一步是右脚的方法种数为0。2.如果有两级台阶，那么最后一步是左脚的话，方法一共是1种，就是直接迈左脚直接上两级台阶，任务就完成了，可是如果最后一步是右脚的话，只有一种办法，就是左脚先迈一脚，再迈右脚，所以最后一步是右脚的方法种数为1。依次类推：当有三级台阶的时候，左脚方法为1，右脚为2，四级台阶的时候，左脚方法为3，右脚为2……然后发现一种规律：第i级台阶的左脚方法为前两级台阶的右脚方法之和，而右脚方法为前两级左脚方法之和，然后按照这个规律循环填表即可，代码如下：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">40</span>],r[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//1级台阶时 最后一只脚为左脚的方法为1</span></span><br><span class="line">    l[<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//2级台阶时 最后一只脚为左脚的方法为1</span></span><br><span class="line">    r[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//1级台阶时 最后一只脚为右脚的方法为0</span></span><br><span class="line">    r[<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//2级台阶时 最后一只脚为右脚的方法为1</span></span><br><span class="line">    <span class="comment">//可以合并写成： left[1]=left[2]=right[2]=1,right[1]=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">40</span>;++i)&#123;</span><br><span class="line">        l[i]=r[i<span class="number">-1</span>]+r[i<span class="number">-2</span>];<span class="comment">//左脚等于前两项右脚的和</span></span><br><span class="line">        r[i]=l[i<span class="number">-1</span>]+l[i<span class="number">-2</span>]; <span class="comment">//右脚等于前两项左脚的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp();</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其实我们还可以用排列组合的问题来解这道题。</p><p>假设有39阶台阶，那么问题可以转化为：</p><p>n = c(38, 1) + (36, 3) + … + c(20, 19) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cmn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cmn = cmn * (m - i) / (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cmn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">n += c(<span class="number">39</span> - i, i); <span class="comment">//39阶台阶</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题是蓝桥杯的一道填空题改编过来的，因为是填空题，数据量也比较小，可以直接使用暴力递归的方式来解决，但是在oj上有时间限制1s，使用递归肯定会超时。&lt;/p&gt;
    
    </summary>
    
      <category term="-递归 -动态规划 -排列组合" scheme="http://maojunjie666.top/categories/%E9%80%92%E5%BD%92-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
    
      <category term="递归" scheme="http://maojunjie666.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="动态规划" scheme="http://maojunjie666.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="排列组合" scheme="http://maojunjie666.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 B题：Is Sorted</title>
    <link href="http://maojunjie666.top/2018/09/06/%E6%8E%92%E5%BA%8F/Is%20Sorted/"/>
    <id>http://maojunjie666.top/2018/09/06/排序/Is Sorted/</id>
    <published>2018-09-06T02:00:00.000Z</published>
    <updated>2018-09-06T07:38:50.578Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/B" target="_blank" rel="noopener">题目传送门</a></p><p>因为这题的数据量不是太大，我们可以直接用冒泡排序的方式进行比较，如果在比较的过程中，发现前一个元素大于等于后一个元素，就说明数列不是严格递增数列，将flag置为false，跳出循环。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;=arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为这题的数据量不是太大，我们可以直接用冒泡排序的方式进行比较，如果在比较的过程中，发现前一个元素大于等于后一个元素，就说明数列不是严格递增数列，将flag置为false，跳出循环。&lt;/p&gt;
    
    </summary>
    
      <category term="排序" scheme="http://maojunjie666.top/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="http://maojunjie666.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第六届ACM编程决赛-低年级组 G题：做游戏</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%A8%A1%E6%8B%9F/%E5%81%9A%E6%B8%B8%E6%88%8F/"/>
    <id>http://maojunjie666.top/2018/09/05/模拟/做游戏/</id>
    <published>2018-09-05T14:25:43.495Z</published>
    <updated>2018-09-06T02:42:03.791Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/23/G" target="_blank" rel="noopener">题目传送门</a></p><p><strong>(特别注意，题目中可能有没有传送门的测试样例！！！)</strong></p><p>这题其实是一道水题，我们可以找到他的起点和终点（测试用例可能有起点不在第一个字符，或者终点不在最后一个字符的情况),第一遍从起点开始遍历，找到第一个传送阵记录到达传送阵的步数step，第二遍从终点开始遍历，找到离终点最近的一个传送阵，记录步数（只要找离起点和终点最近的传送阵即可，因为中间的传送阵根本不会到达），如果不是一个传送阵，就给步数加1（从一个传送阵到另一个传送阵消耗1个步数），否则不加。</p><p>然后用步数对他们掷骰子的情况一个一个的做减法，谁掷的点数先使step小于等于0，谁就剩，用奇偶判断即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k1=<span class="number">0</span>,k2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> len = a.size();</span><br><span class="line">   <span class="comment">//找到起点和终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'S'</span>)</span><br><span class="line">                x = i;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'E'</span>)</span><br><span class="line">                y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起点出发，找到最近的传送门</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="string">'@'</span>)</span><br><span class="line">                step++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k1=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从终点出发，找到最近的传送门</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="string">'@'</span>)</span><br><span class="line">                step++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k2=i;</span><br><span class="line">                <span class="keyword">if</span>(k1!=k2)step+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(k1!=k2)step+=1;  这里不能把这句放外面，题目样例有毒，可能没用传送门</span></span><br><span class="line">        <span class="comment">//可以改成(k1*k2 &amp;&amp; k1!=k2)step+=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            step -= arr[i];</span><br><span class="line">            <span class="keyword">if</span>(step &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, i % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"Tabris"</span> : <span class="string">"mengxiang000"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(step &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"None"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/23/G&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(特别注意，题目中可能有没有传送门的测试样例！！！)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这题其实是一道水题，我们可以找到他的起点和终点（测试用例可能有起点不在第一个字符，或者终点不在最后一个字符的情况),第一遍从起点开始遍历，找到第一个传送阵记录到达传送阵的步数step，第二遍从终点开始遍历，找到离终点最近的一个传送阵，记录步数（只要找离起点和终点最近的传送阵即可，因为中间的传送阵根本不会到达），如果不是一个传送阵，就给步数加1（从一个传送阵到另一个传送阵消耗1个步数），否则不加。&lt;/p&gt;
&lt;p&gt;然后用步数对他们掷骰子的情况一个一个的做减法，谁掷的点数先使step小于等于0，谁就剩，用奇偶判断即可。&lt;/p&gt;
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第六届ACM编程决赛-低年级组 D题：逃脱</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%90%9C%E7%B4%A2/%E9%80%83%E8%84%B1/"/>
    <id>http://maojunjie666.top/2018/09/05/搜索/逃脱/</id>
    <published>2018-09-05T14:14:21.000Z</published>
    <updated>2018-09-05T13:00:34.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/23/D" target="_blank" rel="noopener">题目传送门</a></p><p>这题开始没想到怎么处理火，火可以走一遍bfs，记录或到达各个点的步数即可，但是有一种更好的方式处理火到达的时间，判断某点x和y坐标与火的x和y坐标，因为火到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标与火坐标行或列的差的最大绝对值值即可。</p><p>人就可以直接BFS，找到出口E就返回步数，当走过一遍BFS后没有return返回步数，就表示他们无法逃脱。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> maze[<span class="number">35</span>][<span class="number">35</span>],fire[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,st,ed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,step;  <span class="comment">//点的坐标和到达所需步数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="comment">//火灾到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标行或列的最大值即可。</span></span><br><span class="line">            fire[i][j]=max(<span class="built_in">abs</span>(i-x),<span class="built_in">abs</span>(j-y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    node now,next;</span><br><span class="line">    now.x=st,now.y=ed,now.step=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            next.x=now.x+dis[i][<span class="number">0</span>];</span><br><span class="line">            next.y=now.y+dis[i][<span class="number">1</span>];</span><br><span class="line">            next.step=now.step+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里不用判断next的x和y坐标是否越界，因为越界肯定不会等于E。</span></span><br><span class="line">            <span class="keyword">if</span>(maze[next.x][next.y]==<span class="string">'E'</span> &amp;&amp;next.step&lt;=fire[next.x][next.y])<span class="keyword">return</span> next.step;</span><br><span class="line">            <span class="keyword">if</span>(next.x&lt;n &amp;&amp;next.y&lt;m &amp;&amp; next.x&gt;=<span class="number">0</span> &amp;&amp;next.y&gt;=<span class="number">0</span> &amp;&amp;maze[next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;</span><br><span class="line">               !vis[next.x][next.y] &amp;&amp; next.step&lt;fire[next.x][next.y])&#123;</span><br><span class="line">                    vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">                    q.push(next);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;maze[i][j];</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="string">'*'</span>)x=i,y=j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="string">'S'</span>)st=i,ed=j;</span><br><span class="line">        &#125;</span><br><span class="line">        Fire();</span><br><span class="line">        <span class="keyword">int</span> ans=bfs();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"T_T"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/23/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题开始没想到怎么处理火，火可以走一遍bfs，记录或到达各个点的步数即可，但是有一种更好的方式处理火到达的时间，判断某点x和y坐标与火的x和y坐标，因为火到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标与火坐标行或列的差的最大绝对值值即可。&lt;/p&gt;
&lt;p&gt;人就可以直接BFS，找到出口E就返回步数，当走过一遍BFS后没有return返回步数，就表示他们无法逃脱。&lt;/p&gt;
    
    </summary>
    
      <category term="BFS" scheme="http://maojunjie666.top/categories/BFS/"/>
    
    
      <category term="BFS" scheme="http://maojunjie666.top/tags/BFS/"/>
    
      <category term="广度优先搜索" scheme="http://maojunjie666.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---A题：星图</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%9D%82%E9%A1%B9/%E6%98%9F%E5%9B%BE/"/>
    <id>http://maojunjie666.top/2018/09/05/杂项/星图/</id>
    <published>2018-09-05T14:14:21.000Z</published>
    <updated>2018-09-05T08:40:12.529Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/A" target="_blank" rel="noopener">题目传送门</a></p><p>这题第一次做的时候没有做到一个合格acmer的基本素质，应首先判断输入的规模，再来确定算法复杂度，误以为题目简单，直接循环暴力搜索头铁就去做了，结果TLE。</p><p>在确认了输入规模后，确定了这道题必须先对原矩阵的行和列进行区间处理或者前缀和处理（计算前n项有多少个黑洞），然后在进行复杂度为O(1)的查询即可。</p><p>下列是使用区间处理的方法，维护矩阵的每行和每列的最大最小值，然后进行O(1)的查询即可。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;    <span class="comment">//在输入的时候先对 行进行处理</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;minv)minv=j; </span><br><span class="line">                <span class="keyword">if</span>(j&gt;maxv)maxv=j;</span><br><span class="line">            &#125;</span><br><span class="line">            row[i][<span class="number">0</span>]=minv,row[i][<span class="number">1</span>]=maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对列进行处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;minv)minv=i;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;maxv)maxv=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        col[j][<span class="number">0</span>]=minv;</span><br><span class="line">        col[j][<span class="number">1</span>]=maxv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,op);</span><br><span class="line">        x--,y--;  <span class="comment">//因为坐标是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'U'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;col[y][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;col[y][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;row[x][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;row[x][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题第一次做的时候没有做到一个合格acmer的基本素质，应首先判断输入的规模，再来确定算法复杂度，误以为题目简单，直接循环暴力搜索头铁就去做了，结果TLE。&lt;/p&gt;
&lt;p&gt;在确认了输入规模后，确定了这道题必须先对原矩阵的行和列进行区间处理或者前缀和处理（计算前n项有多少个黑洞），然后在进行复杂度为O(1)的查询即可。&lt;/p&gt;
&lt;p&gt;下列是使用区间处理的方法，维护矩阵的每行和每列的最大最小值，然后进行O(1)的查询即可。&lt;br&gt;
    
    </summary>
    
      <category term="区间处理" scheme="http://maojunjie666.top/categories/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
    
      <category term="区间处理" scheme="http://maojunjie666.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---C题：装进肚子</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%9D%82%E9%A1%B9/%E8%A3%85%E8%BF%9B%E8%82%9A%E5%AD%90/"/>
    <id>http://maojunjie666.top/2018/09/05/杂项/装进肚子/</id>
    <published>2018-09-05T08:23:27.483Z</published>
    <updated>2018-09-05T08:38:39.314Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/C" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们对结构体进行排序，但是不能分别对早上和晚上的甜蜜值进行分类排序，而应该根据他们的差值，来从大到小排序，这样我们得到的前k的个肯定是早上的甜蜜值较大的，后面的都是晚上甜蜜值更大的。举个栗子：</p><a id="more"></a><p>1  3 、2   4 、  3   9  、4  12        这四对数进行排序后，为：</p><p>1-3= - 2、  2-4 = - 2、   3-9 = - 6、   4-12 = - 8 </p><p>这样排序，我们可以把晚上甜蜜值更大留在后头，而早上甜蜜值较大的留在前头。</p><p>而且我们观察，如果有两组差值相同的，如果是都是早上吃的或者晚上吃的不用考虑，如果是一早一晚吃的，他们的和必定相等，比如早上是1，晚上就是4，早上是2，晚上就是3，不会影响最终答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mo,ev;</span><br><span class="line">&#125;arr[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.mo-a.ev&gt;b.mo-b.ev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].mo; <span class="comment">//第二行输入早上的甜蜜值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].ev; <span class="comment">//第三行输入晚上的甜蜜值</span></span><br><span class="line">    sort(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>,cmp);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=k)sum+=arr[i].mo;</span><br><span class="line">        <span class="keyword">else</span> sum+=arr[i].ev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们对结构体进行排序，但是不能分别对早上和晚上的甜蜜值进行分类排序，而应该根据他们的差值，来从大到小排序，这样我们得到的前k的个肯定是早上的甜蜜值较大的，后面的都是晚上甜蜜值更大的。举个栗子：&lt;/p&gt;
    
    </summary>
    
      <category term="区间处理" scheme="http://maojunjie666.top/categories/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
    
      <category term="区间处理" scheme="http://maojunjie666.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---E题：开心的涂刷</title>
    <link href="http://maojunjie666.top/2018/09/05/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BC%80%E5%BF%83%E7%9A%84%E6%B6%82%E5%88%B7/"/>
    <id>http://maojunjie666.top/2018/09/05/组合数学/开心的涂刷/</id>
    <published>2018-09-05T07:34:21.170Z</published>
    <updated>2018-09-05T08:41:36.762Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/E" target="_blank" rel="noopener">题目传送门</a></p><p>这题是一个组合数学问题。</p><p>分析： 一共有 m^n^ 个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，因为第一位的颜色还可以选,顾所有的可能应该为：m^n^−m∗(m−1)^n−1^,直接快速幂即可 </p><p>由取余公式我们可以得到   (n-m)%K = （n%k-m%k)%k</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD    <span class="comment">//注意给x带上括号，因为宏定义只是单纯的替换</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    a%=MOD;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll ans=mod(pow_mod(m,n)-mod(m)*pow_mod(m<span class="number">-1</span>,n<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mod(ans+MOD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题是一个组合数学问题。&lt;/p&gt;
&lt;p&gt;分析： 一共有 m^n^ 个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，因为第一位的颜色还可以选,顾所有的可能应该为：m^n^−m∗(m−1)^n−1^,直接快速幂即可 &lt;/p&gt;
&lt;p&gt;由取余公式我们可以得到   (n-m)%K = （n%k-m%k)%k&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://maojunjie666.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://maojunjie666.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---K题：免费wifi</title>
    <link href="http://maojunjie666.top/2018/09/05/%E8%B4%AA%E5%BF%83/free%20wifi/"/>
    <id>http://maojunjie666.top/2018/09/05/贪心/free wifi/</id>
    <published>2018-09-05T06:10:59.942Z</published>
    <updated>2018-09-05T08:39:59.727Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/K" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们第一眼觉得是区间计数的题，可是我不会区间计数，于是就用了贪心算法来解。我们先对起始时间进行升序排序，如果起始时间相同，按照结束时间升序排序，对结束时间，我们使用一个小堆顶的优先队列来维护，这样可以保证结束时间最小的总在堆顶，然后比较下一个人的起始时间与堆顶结束时间，如果堆顶结束时间小于起始时间，就让堆顶的元素出列，给路由器数量加一，并且把m个人的结束时间加入堆中。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line">&#125;arr[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.st==b.st)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.ed&lt;b.ed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.st&lt;b.st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].st&gt;&gt;arr[i].ed;</span><br><span class="line">    sort(arr,arr+n,cmp);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)pq.push(arr[i].ed);<span class="comment">//初始给m个人开1台</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;  <span class="comment">//至少1台</span></span><br><span class="line">    <span class="keyword">int</span> j=m; <span class="comment">//因为前面放置了编号0-m-1的人，所以j从编号m开始</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> top=pq.top();</span><br><span class="line">        <span class="keyword">if</span>(top&lt;arr[j].st)&#123;</span><br><span class="line">            pq.pop();</span><br><span class="line">            pq.push(arr[j++].ed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">                pq.push(arr[j++].ed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间计数的方法非常方便，只要找到真个区间中最大的那个值就行了，每重叠一次就加一，</p><p>因为求的是最少个数， 将时间段内的最大值sum找出，ans=int(ceil(1.0*sum/m)) </p><p>比如样例，区间计数后为：1 2 3 3 2 2 2 1 1 ，所以找到3就行，然后再根据m的值得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">            arr[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxv=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5000</span>;++i)maxv=max(arr[i],maxv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样处理可以不用ceil函数</span></span><br><span class="line">    <span class="keyword">if</span>(maxv%m==<span class="number">0</span>)ans=maxv/m;  </span><br><span class="line">    <span class="keyword">else</span> ans=maxv/m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/K&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们第一眼觉得是区间计数的题，可是我不会区间计数，于是就用了贪心算法来解。我们先对起始时间进行升序排序，如果起始时间相同，按照结束时间升序排序，对结束时间，我们使用一个小堆顶的优先队列来维护，这样可以保证结束时间最小的总在堆顶，然后比较下一个人的起始时间与堆顶结束时间，如果堆顶结束时间小于起始时间，就让堆顶的元素出列，给路由器数量加一，并且把m个人的结束时间加入堆中。&lt;br&gt;
    
    </summary>
    
      <category term="贪心" scheme="http://maojunjie666.top/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="贪心" scheme="http://maojunjie666.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>18级编程俱乐部新生赛div1轮题解</title>
    <link href="http://maojunjie666.top/2018/09/02/%E7%BC%96%E7%A8%8B%E4%BF%B1%E4%B9%90%E9%83%A8%E6%9C%88%E8%B5%9B/mrdiv1/"/>
    <id>http://maojunjie666.top/2018/09/02/编程俱乐部月赛/mrdiv1/</id>
    <published>2018-09-02T14:14:21.000Z</published>
    <updated>2018-09-04T10:03:26.333Z</updated>
    
    <content type="html"><![CDATA[<p>前言：这次的题目不算很难，都是你们学过的东西，比如第一题是排序，第二题的循环，第三题的斐波那契等等。</p><hr><h4 id="【新生阶段月赛NO-1】白细胞"><a href="#【新生阶段月赛NO-1】白细胞" class="headerlink" title="【新生阶段月赛NO.1】白细胞"></a>【新生阶段月赛NO.1】白细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=0" target="_blank" rel="noopener">传送门:</a> </p><p>这题非常的水，按非降序的方式排序，然后用循环模拟整个过程即可。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a,b=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L.sort()</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=i):</span><br><span class="line">        a-=i</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><hr><h4 id="【新生阶段月赛NO-2】红细胞"><a href="#【新生阶段月赛NO-2】红细胞" class="headerlink" title="【新生阶段月赛NO.2】红细胞"></a>【新生阶段月赛NO.2】红细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=1" target="_blank" rel="noopener">传送门:</a></p><p>这题无比的水，循环连乘即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">ans=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    ans*=i</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-3】杀手T细胞"><a href="#【新生阶段月赛NO-3】杀手T细胞" class="headerlink" title="【新生阶段月赛NO.3】杀手T细胞"></a>【新生阶段月赛NO.3】杀手T细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=2" target="_blank" rel="noopener">传送门:</a></p><p>这题观察可知，杀手t细胞可以走1步或跑2步，观察前几项可知为：1 2 3 5 8  ，显然是个斐波那契数列，循环走一波，ac。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   <span class="comment">#打表，打出前几项，然后在进行循环递推</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,<span class="number">32</span>):</span><br><span class="line">    L.append(L[i<span class="number">-1</span>]+L[i<span class="number">-2</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=int(input())</span><br><span class="line">        print(L[n])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-4】辅助T细胞"><a href="#【新生阶段月赛NO-4】辅助T细胞" class="headerlink" title="【新生阶段月赛NO.4】辅助T细胞"></a>【新生阶段月赛NO.4】辅助T细胞</h4><p><a href="hhttp://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=3" target="_blank" rel="noopener">传送门:</a></p><p>用python的孩子这题可以直接用字符串的方式来做，不过用c就的话，就需要用下面这种方式了。</p><p>这题我们显然可以用取余的方式来获得每一位，比如631，</p><p>631%10=1  取余一次再整除10，631//10=63  </p><p>63%10=3  再整除10，63//10=6</p><p>6%10=6  再整除10,  6//10=0</p><p>结束循环即可，使用一个变量记录6的个数，如果是2，就给计数器变量加1，最后输出计数器变量即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取余解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">sum=<span class="number">0</span> <span class="comment">#计数器变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">66</span>,n+<span class="number">1</span>):  <span class="comment">#i至少从66开始才会有2个6，如果小于66，这个循环不会执行</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">6</span>):cnt+=<span class="number">1</span>;</span><br><span class="line">        i=i//<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">2</span>):sum+=<span class="number">1</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    cnt=str(i).count(<span class="string">'6'</span>)</span><br><span class="line">    <span class="keyword">if</span> cnt==<span class="number">2</span>:</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-5】巨噬细胞"><a href="#【新生阶段月赛NO-5】巨噬细胞" class="headerlink" title="【新生阶段月赛NO.5】巨噬细胞"></a>【新生阶段月赛NO.5】巨噬细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=4" target="_blank" rel="noopener">传送门:</a></p><p>这题显然对10取余即可，只有（9+1）%10=0，这样正好模拟了向前推一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l=[(int(x)+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> input()]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">    print(l[i],end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-6】压轴：血小板是我的"><a href="#【新生阶段月赛NO-6】压轴：血小板是我的" class="headerlink" title="【新生阶段月赛NO.6】压轴：血小板是我的"></a>【新生阶段月赛NO.6】压轴：血小板是我的</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=5" target="_blank" rel="noopener">传送门:</a></p><p>这题是著名的约瑟夫环问题，有兴趣的孩子可以百度，我这题出的数据特别的小，所以可以用模拟的方法ac，如果数据量大，模拟的方式肯定会超时。</p><p>下面是用递推的方式来解这个问题，<strong>证明过程如下：</strong></p><blockquote><p>令f[n]表示当有n个候选人时，最后当选者的编号。<br>f[1] = 0<br>f[n] = (f[n - 1] + K) mod n</p></blockquote><p>接下来我们用数学归纳法来证明这个递推公式的正确性：</p><p>(1) <strong>f[1] = 0</strong></p><p>显然当只有1个候选人时，该候选人就是当选者，并且他的编号为0。</p><p>(2) <strong>f[n] = (f[n - 1] + K) mod n</strong></p><p>假设我们已经求解出了f[n - 1]，并且保证f[n - 1]的值是正确的。</p><p>现在先将n个人按照编号进行排序：</p><p>那么第一次被淘汰的人编号一定是K-1(假设K &lt; n，若K &gt; n则为(K-1) mod n)。将被选中的人标记为”#”：</p><p>第二轮报数时，起点为K这个候选人。并且只剩下n-1个选手。假如此时把k+1看作0’，k+2看作1’…</p><p>则对应有：</p><p>此时在0’,1’,…,n-2’上再进行一次K报数的选择。而f[n-1]的值已经求得，因此我们可以直接求得当选者的编号s’。</p><p>但是，该编号s’是在n-1个候选人报数时的编号，并不等于n个人时的编号，所以我们还需要将s’转换为对应的s。</p><p>通过观察，s和s’编号相对偏移了K，又因为是在环中，因此得到s = (s’+K) mod n。</p><p>即f[n] = (f[n-1] + k) mod n。</p><p>至此递推公式的两个式子我们均证明了其正确性，则对于任意给定的n，我们可以使用该递推式求得f[n]，写成伪代码为：</p><p>同时由于计算f[i]时，只会用到f[i-1]，因此我们还可以将f[]的空间节约，改进后的代码为：</p><p>该算法的时间复杂度为O(N)，空间复杂度为O(1)。对于N不是很大的数据来说，可以解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n,m=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    s=(s+m)%i  <span class="comment">#循环递推式</span></span><br><span class="line">print(s+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：这次的题目不算很难，都是你们学过的东西，比如第一题是排序，第二题的循环，第三题的斐波那契等等。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;【新生阶段月赛NO-1】白细胞&quot;&gt;&lt;a href=&quot;#【新生阶段月赛NO-1】白细胞&quot; class=&quot;headerlink&quot; title=&quot;【新生阶段月赛NO.1】白细胞&quot;&gt;&lt;/a&gt;【新生阶段月赛NO.1】白细胞&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;amp;pid=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门:&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这题非常的水，按非降序的方式排序，然后用循环模拟整个过程即可。&lt;br&gt;
    
    </summary>
    
      <category term="18级新生赛题解" scheme="http://maojunjie666.top/categories/18%E7%BA%A7%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="新生赛题解" scheme="http://maojunjie666.top/tags/%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>什么是EOF</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/EOF/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/EOF/</id>
    <published>2018-09-02T14:14:21.000Z</published>
    <updated>2018-09-03T10:02:47.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是EOF？"><a href="#什么是EOF？" class="headerlink" title="什么是EOF？"></a>什么是EOF？</h4><p>很多萌新都问到，什么是eof，所以我特地写了一篇博文来介绍EOF。</p><p>首先来看，百度百科给其的定义：</p><p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。<br><a id="more"></a></p><hr><h4 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h4><p>简单来说，eof就是在文件末尾添加的一个字符。在C语言中，EOF是一个关键字，它的值是-1，这样不会与ASCII码冲突（这个以后再详说）</p><p>在window中，eof使用快捷键：<code>ctrl+z</code> 来输入。</p><p>又比如，在下面这个例子中，在8的末尾是有一个eof的，当读取完8后，继续往下读，读到了eof，结束读入。</p><blockquote><p>1 2</p><p>3 4</p><p>5 6</p><p>7 8</p></blockquote><p>EOF在OJ是用来针对多组输入问题的，当你不知道系统有几组输入时，你都可以使用EOF关键字判断，因为不论是有3组、4组还是n组，只要读到了EOF关键字，肯定能表示测试用例已经读完。</p><hr><h4 id="代码举例（C语言）"><a href="#代码举例（C语言）" class="headerlink" title="代码举例（C语言）"></a>代码举例（C语言）</h4><p>现在我们有一个不确定有多少组输入的A+B问题。</p><p>C语言比较方便，因为c语言中定义了EOF关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF)&#123;    <span class="comment">//这里当scanf读取正确时，返回参数个数，如果读到EOF，返回EOF</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当scanf返回EOF，不满足while循环的条件时就结束了输入，非常方便。</p><hr><h4 id="代码举例-python"><a href="#代码举例-python" class="headerlink" title="代码举例(python)"></a>代码举例(python)</h4><p>在python中，是没有定义eof关键字的，但是我们可以使用异常捕获来针对eof关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       print(sum(int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()))</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当捕获到eof时，就会执行pass语句，pass语句表示什么都不执行，然后循环就会结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是EOF？&quot;&gt;&lt;a href=&quot;#什么是EOF？&quot; class=&quot;headerlink&quot; title=&quot;什么是EOF？&quot;&gt;&lt;/a&gt;什么是EOF？&lt;/h4&gt;&lt;p&gt;很多萌新都问到，什么是eof，所以我特地写了一篇博文来介绍EOF。&lt;/p&gt;
&lt;p&gt;首先来看，百度百科给其的定义：&lt;/p&gt;
&lt;p&gt;EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://maojunjie666.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://maojunjie666.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>文件的基本操作（文件重定向篇）</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E7%AF%87%EF%BC%89/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/文件的基本操作（文件重定向篇）/</id>
    <published>2018-09-02T01:39:35.111Z</published>
    <updated>2018-09-05T12:50:33.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-文件重定向"><a href="#1-文件重定向" class="headerlink" title="1.文件重定向"></a>1.文件重定向</h4><p>​    平时我们用到的scanf、gets和printf、puts等等，都是从标准输入输出文件中读写。</p><p>​    默认把键盘作为标准输入文件（scanf和gets在其中读取），把屏幕作为标准输出文件（printf和puts）等在其中写入。</p><p>​    当我们需要读取某一个文本文件的内容时，我们就需要用到文件重定向了，将默认的标准输入文件从键盘改成文本文件；或者输入一些字符到文本文件中，将默认的输出文件从屏幕改成文本文件。<br><a id="more"></a></p><hr><h4 id="2-文件重定向读取"><a href="#2-文件重定向读取" class="headerlink" title="2.文件重定向读取"></a>2.文件重定向读取</h4><p>​    step1：用vs2012新建一个工程，在工程目录里面新建一个文本文件，命名为test.txt（名字可以随便命名），在里面输入12 13 14</p><p>​    如下图：</p><p><img src="https://i.loli.net/2018/06/20/5b29cc2e864c8.png" alt="123.png"></p><p>step2：</p><p>使用文件重定向函数freopen来改变标准输入文件。</p><p>freopen函数一共有3个参数，第一个参数是文本文件的路径，第二个参数是读取文件的方式，第三个参数是标准输入流stdin（这个不需要变动）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  <span class="comment">//"r"：表示以只读方式打开test.txt，stdin是标准输入文件</span></span><br><span class="line"> <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//我们可以使用scanf像平时一样读取3个数，只是你可以不用再输入这三个数，因为它会从文件中读取</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"读取的3个数是：%d %d %d\n"</span>,a,b,c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是重定向了标准输入流，该程序会从文本文件中读取3个数字，然后printf打印到屏幕(标准输出流)</p><hr><h4 id="3-文件重定向写入"><a href="#3-文件重定向写入" class="headerlink" title="3.文件重定向写入"></a>3.文件重定向写入</h4><p>​    step1：用vs2012新建一个工程，在工程目录里面新建一个文本文件，命名为test.txt（名字可以随便命名），在里面输入12 13 14</p><p>​    step2：在工程目录里面新建另一个文本文件，命名为test2.txt（名字随便起）里面不输入任何东西。</p><p>​    step3:</p><p>​        使用freopen的只写模式（”w”)写入数据。程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  <span class="comment">//"r"：表示以只读方式打开test.txt，stdin是标准输入文件</span></span><br><span class="line">    freopen(<span class="string">"test2.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//"w": 表示以只写方式打开test2.txt，stdout是标准输出文件</span></span><br><span class="line"> <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//我们可以使用scanf像平时一样读取3个数，只是你可以不用再输入这三个数，因为它会从文件中读取</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="comment">//下面的printf不会再打印在屏幕上，而是会将文字打印到test2.txt文本文件中。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"读取的3个数是：%d %d %d\n"</span>,a,b,c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>本章介绍了基本文件重定向的概念以及如何使用freopen进行读取和写入重定向，下章将会介绍文件指针的概念和基本操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-文件重定向&quot;&gt;&lt;a href=&quot;#1-文件重定向&quot; class=&quot;headerlink&quot; title=&quot;1.文件重定向&quot;&gt;&lt;/a&gt;1.文件重定向&lt;/h4&gt;&lt;p&gt;​    平时我们用到的scanf、gets和printf、puts等等，都是从标准输入输出文件中读写。&lt;/p&gt;
&lt;p&gt;​    默认把键盘作为标准输入文件（scanf和gets在其中读取），把屏幕作为标准输出文件（printf和puts）等在其中写入。&lt;/p&gt;
&lt;p&gt;​    当我们需要读取某一个文本文件的内容时，我们就需要用到文件重定向了，将默认的标准输入文件从键盘改成文本文件；或者输入一些字符到文本文件中，将默认的输出文件从屏幕改成文本文件。&lt;br&gt;
    
    </summary>
    
      <category term="文件" scheme="http://maojunjie666.top/categories/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="文件" scheme="http://maojunjie666.top/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>文件的基本操作（文件指针上篇）</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%AF%87%EF%BC%89/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/文件的基本操作（文件指针篇）/</id>
    <published>2018-09-02T01:39:35.074Z</published>
    <updated>2018-09-05T12:50:28.772Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-文件指针的定义"><a href="#1-文件指针的定义" class="headerlink" title="1.文件指针的定义"></a>1.文件指针的定义</h4><p>​    在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。</p><p>​    文件指针实际上是系统封装好的一个结构体，里面包含了各种信息，如文件名、文件状态和文件当前位置等信息 （类似光标位置），不用关心内部实现，想具体了解请点击 <a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88/1953678" target="_blank" rel="noopener">文件指针</a>。<br><a id="more"></a></p><hr><h4 id="2-定义文件指针"><a href="#2-定义文件指针" class="headerlink" title="2.定义文件指针"></a>2.定义文件指针</h4><p>fopen函数：打开文件</p><p>用法：fp=fopen（文件路径，“打开方式”） </p><p>fclose函数：关闭文件</p><p>用法：fclose(文件指针名)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>)；<span class="comment">//以只读方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-fscanf函数的用法"><a href="#3-fscanf函数的用法" class="headerlink" title="3.fscanf函数的用法"></a>3.fscanf函数的用法</h4><p>在test.txt文件中提前写入 12 13 14</p><p>fscanf函数：从文件中读取相应内容，类似scanf。</p><p>用法：fscanf（文件指针名，“%d……”，&amp;a，……） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;  <span class="comment">//用来接收文件中的数据</span></span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>)；<span class="comment">//以只读方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-fprintf函数的用法"><a href="#4-fprintf函数的用法" class="headerlink" title="4.fprintf函数的用法"></a>4.fprintf函数的用法</h4><p>fprintf函数：相应内容输出相应内容到文件，类似printf。</p><p>用法：pirntf（文件指针名，“%d……”，a，……） </p><p>在当前目录下准备一个叫test2.txt的空文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>,b=<span class="number">13</span>,c=<span class="number">14</span>;  <span class="comment">//用来接收文件中的数据</span></span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test2.txt"</span>,<span class="string">"a"</span>)；<span class="comment">//以只写方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"读取到的三个数是：a=%d b=%d c=%d"</span>,a,b,c);</span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5-fgets函数和fputs函数的用法"><a href="#5-fgets函数和fputs函数的用法" class="headerlink" title="5.fgets函数和fputs函数的用法"></a>5.fgets函数和fputs函数的用法</h4><p><strong>fgets函数</strong>：从文件中读取n个字符写入到字符数组中</p><p>用法：fgets（字符数组名，字符串大小，文件指针）</p><p><strong>fputs函数</strong>:字符数组的内容写入到文件中</p><p>用法：fputs（字符数组名，文件指针）</p><p>具体代码不做过多赘述，自己去尝试一下吧。</p><p> <strong>PS：fgets保留了换行符，fputs输出就不会再添加换行符了。</strong></p><hr><p>下章将详细介绍剩余的fwrite和fread函数，以及如何使用文件的基础操作模拟实现一个登陆界面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-文件指针的定义&quot;&gt;&lt;a href=&quot;#1-文件指针的定义&quot; class=&quot;headerlink&quot; title=&quot;1.文件指针的定义&quot;&gt;&lt;/a&gt;1.文件指针的定义&lt;/h4&gt;&lt;p&gt;​    在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。&lt;/p&gt;
&lt;p&gt;​    文件指针实际上是系统封装好的一个结构体，里面包含了各种信息，如文件名、文件状态和文件当前位置等信息 （类似光标位置），不用关心内部实现，想具体了解请点击 &lt;a href=&quot;https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88/1953678&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文件指针&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="文件" scheme="http://maojunjie666.top/categories/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="文件" scheme="http://maojunjie666.top/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>文件的基本操作（概念介绍篇）</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%E7%AF%87%EF%BC%89/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/文件的基本操作（概念介绍篇）/</id>
    <published>2018-09-02T01:39:35.064Z</published>
    <updated>2018-09-05T12:50:24.602Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-文件的基本概念（需要理解）"><a href="#1-文件的基本概念（需要理解）" class="headerlink" title="1.文件的基本概念（需要理解）"></a>1.文件的基本概念（需要理解）</h4><p>​    所谓“文件”一般是指存储在外部介质上数据的集合。一批文件是以数据的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存在外部介质上的数据，必须先按文件名找到指定的文件，然后再从该文件中读取数据。 </p><p>​    普通文件是指驻留在磁盘或其它外部介质上的一个有序数据集，可以是源文件、目标文件、可执行程序； 也可以是一组待输入处理的原始数据，或者是一组输出的结果。对于源文件、目标文件、 可执行程序可以称作程序文件，对输入输出数据可称作数据文件。</p><p>　　设备文件是指与主机相联的各种外部设备，如显示器、打印机、键盘等。在操作系统中，把外部设备也看作是一个文件来进行管理，把它们的输入、输出等同于对磁盘文件的读和写。</p><p> 通常把显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的printf,putchar 函数就是这类输出。键盘通常被指定标准的输入文件， 从键盘上输入就意味着从标准输入文件上输入数据。scanf,getchar函数就属于这类输入。<br><a id="more"></a></p><hr><h4 id="2-文件的分类"><a href="#2-文件的分类" class="headerlink" title="2.文件的分类"></a>2.文件的分类</h4><p>　从文件编码的方式来看，文件可分为ASCII码文件和二进制码文件两种。</p><p>　　ASCII文件也称为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如，数5678的存储形式为：<br>ASCII码： 00110101 00110110 00110111 00111000<br>　　　　　↓ 　　　　     ↓　　　   ↓ 　　       ↓<br>十进制码： 5　　　　　6　　　　7　　　　8 共占用4个字节。ASCII码文件可在屏幕上按字符显示， 例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。 由于是按字符显示，因此能读懂文件内容。</p><p>　　二进制文件是按二进制的编码方式来存放文件的。 例如， 数5678的存储形式为： 00010110 00101110只占二个字节。二进制文件虽然也可在屏幕上显示，但其内容无法读懂。C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。</p><p>　</p><p>　　在Ｃ语言中，文件操作都是由库函数来完成的。 在下章将介绍主要的文件操作函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-文件的基本概念（需要理解）&quot;&gt;&lt;a href=&quot;#1-文件的基本概念（需要理解）&quot; class=&quot;headerlink&quot; title=&quot;1.文件的基本概念（需要理解）&quot;&gt;&lt;/a&gt;1.文件的基本概念（需要理解）&lt;/h4&gt;&lt;p&gt;​    所谓“文件”一般是指存储在外部介质上数据的集合。一批文件是以数据的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存在外部介质上的数据，必须先按文件名找到指定的文件，然后再从该文件中读取数据。 &lt;/p&gt;
&lt;p&gt;​    普通文件是指驻留在磁盘或其它外部介质上的一个有序数据集，可以是源文件、目标文件、可执行程序； 也可以是一组待输入处理的原始数据，或者是一组输出的结果。对于源文件、目标文件、 可执行程序可以称作程序文件，对输入输出数据可称作数据文件。&lt;/p&gt;
&lt;p&gt;　　设备文件是指与主机相联的各种外部设备，如显示器、打印机、键盘等。在操作系统中，把外部设备也看作是一个文件来进行管理，把它们的输入、输出等同于对磁盘文件的读和写。&lt;/p&gt;
&lt;p&gt; 通常把显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的printf,putchar 函数就是这类输出。键盘通常被指定标准的输入文件， 从键盘上输入就意味着从标准输入文件上输入数据。scanf,getchar函数就属于这类输入。&lt;br&gt;
    
    </summary>
    
      <category term="文件" scheme="http://maojunjie666.top/categories/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="文件" scheme="http://maojunjie666.top/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://maojunjie666.top/2018/09/02/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://maojunjie666.top/2018/09/02/位运算/位运算/</id>
    <published>2018-09-02T01:39:35.062Z</published>
    <updated>2018-09-02T12:05:24.284Z</updated>
    
    <content type="html"><![CDATA[<h4 id="按位与运算"><a href="#按位与运算" class="headerlink" title="按位与运算"></a>按位与运算</h4><p>​    通常用来将某变量中的某些位清零而保留其他位不变，例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：</p><p>​        n= n &amp; 0xffffff00;</p><p>​    也可以写成：</p><p>​        n &amp; = 0xffffff00;</p><p>​    如果n是short类型的，则只需执行：</p><p>​        n &amp; = 0xff00;    如果要判断一个int型的变量n的第7位（从左往右，从0开始数）是否为1，则只需看表达式 n &amp;0x80的值是否等于0x80即可。<br><a id="more"></a></p><hr><h4 id="按位或运算"><a href="#按位或运算" class="headerlink" title="按位或运算"></a>按位或运算</h4><p>​    通常用来将变量中的某些位置成1，而保留其他位不变，例如，如果需要int型变量n的低8位全置成1，而其余位不变，则可以执行：</p><p>​        n | = 0xff；</p><hr><h4 id="按位异或运算"><a href="#按位异或运算" class="headerlink" title="按位异或运算"></a>按位异或运算</h4><p>​    异或运算的特点是：</p><p>​        a^b==c  那么  c^b ==a   以及  c^a ==b ，此规律可以用来做最简单的快速加密和解密。</p><p>​    且一个数异或另一个数两次，得到的仍为这个数本身：</p><p>​        a ^ b ^ b = a  </p><hr><h4 id="按位非运算"><a href="#按位非运算" class="headerlink" title="按位非运算"></a>按位非运算</h4><p>​    是单目运算，其功能是将操作数中的二进制位中的0变成1,1变成0。</p><p>例如：表达式”~21”是无符号整型数0xffffea，运行下面的语句：</p><pre><code>printf(&quot;%d,%u,%x&quot;,\~21,\~21,~21)；</code></pre><p>​    输入结果是：</p><pre><code>&gt;-22,4294967274,ffffffea</code></pre><hr><h4 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h4><p>​    其计算结果是将左操作数的各二进制位全部左移若干位后得到的值，右操作数指明了要左移的位数，左移时，高位丢弃，右边低位补0，左移运算符不会改变左操作数的值。</p><p>​    例如，常数9有32位，其二进制表示是：</p><p>​        0000 0000 0000 0000 0000 0000 0000 1001</p><p>​    表达式”9&lt;&lt;4”就是将上面的二进制数左移4位，得到：</p><p>​        0000 0000 0000 0000 0000 0000 1001 0000</p><p>​    即为10进制是144。</p><p>实际上，左移1位，就等于是乘以2，左移n位，就是乘以2的n次方，而左移操作比乘法操作快的多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">short</span> n2 =<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> n3 =<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">15</span>;</span><br><span class="line">    n1&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    n2&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    n3&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    c&lt;&lt;=<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n1="</span>%x,n2=%d,n3=%d,c=%x,c&lt;&lt;<span class="number">4</span>=%d<span class="string">",n1,n2,n3,c,c&lt;&lt;4);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述程序的输出结果是：</p><blockquote><p>n1=78000,n2=-32768,n3=32768,c=c0,c&lt;&lt;4=3072</p></blockquote><hr><p><strong>敲黑板，记重点</strong></p><p>①语句n1&lt;&lt;=15，对n1左移15位，将32位的n1用二进制表示出来后，即可得知新的n1值是0x78000。</p><p>②语句n2&lt;&lt;=15,对n2左移15位，注意n2是short类型的，只有16位，表示为二进制就是0000000000001111，因此左移15位后，一共从左边移出去了（丢弃了）3个1，左移后n2中存放的二进制数就是1000000000000000,由于n2是short类型，此时n2的最高位是1，因此n2实际上表示的是负数，所以在语句中输出为-32768。</p><p>③语句n3&lt;&lt;=15，对n3左移15位，左移后n3存放的二进制数也是1000000000000000，但是由于n3是无符号的，表示的值总是非负数，所以n3输出为32768。</p><p>④c&lt;&lt;=6,对c左移6位，由于c是 unsigned char类型的，一共只有8位，其二进制表示就是00001111，因此左移6位后，就变为11000000，输出十六进制为c0。</p><p>⑤c&lt;&lt;4,表达式计算的过程是首先将c转换成一个int类型的临时变量（32位，用十六进制表示就是00000000000000c0），然后将该临时变量左移4位，得到的结果是十六进制的0000000000000c00,换算成十进制就是3072。（因为占位符为%d，所以会转换成int临时变量）</p><p>⑥表达式c&lt;&lt;4并不会改变c的值，就像c+4不会改变c的值一样。</p><hr><h4 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h4><p>​    右移运算符是双目运算符，其计算结果是把”&gt;&gt;”的左操作数的各二进制位全部右移若干位后得到的值，要移动的位数就是”&gt;&gt;”的右操作数，移出最右边的位全部被丢弃。</p><p>​    对于有符号数，如long、int、short、char类型变量，在右移时，符号位(即最高位)将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时右边高位就补充1，原符号位为0，则右移时高位就补充0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">short</span> n2 =<span class="number">-15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> n3 =<span class="number">0xffe0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">15</span>;</span><br><span class="line">    n1&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">    n2&gt;&gt;=<span class="number">3</span>;</span><br><span class="line">    n3&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">    c&gt;&gt;=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n1=%x,n2=%d,n3=%x,c=%x"</span>,n1,n2,n3,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出结果是：</p><pre><code>&gt;n1=3,n2=-2,n3=ffe,c=1</code></pre><p><strong>敲黑板，记重点</strong></p><p>①执行语句n1&gt;&gt;=2时，n1的值是0xf，右移两位后变成0x3。</p><p>②执行语句n2&gt;&gt;=3时，n2是有符号16位整数，而原来的值为负数，表示成二进制是1111 1111 1111 0001，由于最高位（符号位）是1，右移时仍然在最高位补充1，所以右移完成后其二进制形式是1111 1111 1111 1110，对于一个有符号16位整数来说，这个二进制形式代表-2。</p><p>③执行语句n3&gt;&gt;=4时，n3是无符号的16位整数，原来的值为0xffe0，尽管最高位是1，但由于它是无符号整数，所以右移时高位补充0，因此右移4位后，n3的值变为0xffe。</p><p>④执行语句c&gt;&gt;=3时，c是无符号的，原来的值为0xf，右移三位后自然就变成了1。</p><p>实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。</p><hr><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>​    有两个int类型的变量a和n(0&lt;=n&lt;=31),要求写一个表达式，使该表达式的值和a的第n位相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;按位与运算&quot;&gt;&lt;a href=&quot;#按位与运算&quot; class=&quot;headerlink&quot; title=&quot;按位与运算&quot;&gt;&lt;/a&gt;按位与运算&lt;/h4&gt;&lt;p&gt;​    通常用来将某变量中的某些位清零而保留其他位不变，例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：&lt;/p&gt;
&lt;p&gt;​        n= n &amp;amp; 0xffffff00;&lt;/p&gt;
&lt;p&gt;​    也可以写成：&lt;/p&gt;
&lt;p&gt;​        n &amp;amp; = 0xffffff00;&lt;/p&gt;
&lt;p&gt;​    如果n是short类型的，则只需执行：&lt;/p&gt;
&lt;p&gt;​        n &amp;amp; = 0xff00;    如果要判断一个int型的变量n的第7位（从左往右，从0开始数）是否为1，则只需看表达式 n &amp;amp;0x80的值是否等于0x80即可。&lt;br&gt;
    
    </summary>
    
      <category term="位运算" scheme="http://maojunjie666.top/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="位运算" scheme="http://maojunjie666.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>网原杂项笔记(第4章)</title>
    <link href="http://maojunjie666.top/2018/09/02/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E5%8E%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://maojunjie666.top/2018/09/02/网络原理/网原第4章笔记/</id>
    <published>2018-09-02T01:39:35.053Z</published>
    <updated>2018-09-05T12:54:07.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-IP地址及其表示方法"><a href="#1-IP地址及其表示方法" class="headerlink" title="1.IP地址及其表示方法"></a>1.IP地址及其表示方法</h4><p>IP地址表示方法{&lt;网络号&gt;,&lt;主机号&gt;}，一共32位。</p><p>注：表示IP地址的时候不允许十进制和二进制混用。<br><a id="more"></a><br>| 地址类型 | 地址范围                    | 网络号 | 主机号 | 网络号二进制表示 |<br>| ——– | ————————— | —— | —— | —————- |<br>| A类      | 1.0.0.0 ~ 126.255.255.255   | 8位    | 24位   | 0                |<br>| B类      | 128.0.0.0 ~ 191.255.255.255 | 16位   | 16位   | 10               |<br>| C类      | 192.0.0.0 ~ 223.255.255.255 | 24位   | 8位    | 110              |<br>| D类      | \                           | \      | \      | 1110             |<br>| E类      | \                           | \      | \      | 1111             |</p><p>从IP地址的结构来看，IP地址不仅仅指明一台主机，而是还指明了主机所连接的网络。</p><hr><h4 id="2-默认路由"><a href="#2-默认路由" class="headerlink" title="2.默认路由"></a>2.默认路由</h4><p>默认路由的地址是0.0.0.0 ，如果配置路由表，把ip地址改成0.0.0.0即可</p><hr><h4 id="3-ARP协议的工作方式"><a href="#3-ARP协议的工作方式" class="headerlink" title="3.ARP协议的工作方式"></a>3.ARP协议的工作方式</h4><p>详见课本P124-P127页</p><hr><h4 id="4-IP数据报的格式"><a href="#4-IP数据报的格式" class="headerlink" title="4.IP数据报的格式"></a>4.IP数据报的格式</h4><p>重点了解内容：</p><p>首部长度、片偏移</p><p>片偏移中：</p><p>MF=1表示还有分片，MF=0表示这已经是若干个数据报分片中的最后一个。</p><p>DF表示不能分片，只有当DF=0才允许分片。</p><hr><h4 id="5-IP分组的转发流程"><a href="#5-IP分组的转发流程" class="headerlink" title="5.IP分组的转发流程"></a>5.IP分组的转发流程</h4><p>详见课本P132-P134页</p><hr><h4 id="6-划分子网"><a href="#6-划分子网" class="headerlink" title="6.划分子网"></a>6.划分子网</h4><p><strong>划分子网的原因：</strong></p><p>①IP空间利用率低</p><p>②给每一个主机分配网络号会造成路由表过大，影响网络性能。</p><p>③两级IP地址不够灵活。</p><p>划分子网后，两级IP地址就变成了三级IP地址，{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><hr><h4 id="7-子网掩码"><a href="#7-子网掩码" class="headerlink" title="7.子网掩码"></a>7.子网掩码</h4><p>使用子网掩码的意义：可以判断网络是否进行了子网划分。</p><p>无论是否划分子网，将子网掩码与IP地址进行与运算，就能立即计算出IP地址的网络地址。</p><p>若IP地址同属于一个子网，则这些IP虽然不同，但与子网掩码做与运算后，都能得出同一个网络地址。</p><hr><h4 id="8-使用子网时的分组转发"><a href="#8-使用子网时的分组转发" class="headerlink" title="8.使用子网时的分组转发"></a>8.使用子网时的分组转发</h4><p>详见课本P140-141页</p><hr><h4 id="9-无分类编址CIDR（构造超网）"><a href="#9-无分类编址CIDR（构造超网）" class="headerlink" title="9.无分类编址CIDR（构造超网）"></a>9.无分类编址CIDR（构造超网）</h4><p><strong>斜线记法</strong></p><p>如128.14.35.7/20 =10000000 00001110 00100011 00000111</p><p>这样，这个地址的最大最小地址可以很快得出：将20位后的位全置为0，即可得到最小地址，全置为1，得到最大地址。</p><p>10000000 00001110 0010 0000 0000 0000  =128.14.32.0</p><p>10000000 00001110 0010 1111 1111 1111  =128.14.47.255</p><hr><p><strong>路由聚合</strong></p><p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合称为路由聚合。</p><p>网络前缀越短，其地址块所包含的地址数就越多。</p><p>具体路由聚合举例：见课本P144页。</p><hr><p><strong>最长前缀匹配</strong></p><p>具体例子见课本P145页。</p><hr><h4 id="10-ICMP报文"><a href="#10-ICMP报文" class="headerlink" title="10.ICMP报文"></a>10.ICMP报文</h4><p><strong>应用：</strong>  </p><p>ping命令：测试连通性<br>tracert命令：跟踪沿途路径</p><hr><h4 id="11-RIP协议（动态路由）"><a href="#11-RIP协议（动态路由）" class="headerlink" title="11.RIP协议（动态路由）"></a>11.RIP协议（动态路由）</h4><p>基于距离的学习过程。</p><p><strong>特点：</strong></p><p>①仅和相邻的路由器交换信息。</p><p>②路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</p><p>③按固定的时间间隔交换路由信息。</p><p>路由表中最重要的信息是：到某个网络的距离（即最短距离），以及应经过的下一跳地址，路由表更新的原则是找出到每个目的网络的最短距离，这种更新算法称为距离向量算法。</p><hr><h4 id="12-距离向量算法"><a href="#12-距离向量算法" class="headerlink" title="12.距离向量算法"></a>12.距离向量算法</h4><p>详见课本P155-P156页。</p><hr><h4 id="13-内部网关协议OSPF"><a href="#13-内部网关协议OSPF" class="headerlink" title="13.内部网关协议OSPF"></a>13.内部网关协议OSPF</h4><p> 基于路由表的查表转发过程。</p><hr><h4 id="14-虚拟专用网VPN（了解）"><a href="#14-虚拟专用网VPN（了解）" class="headerlink" title="14.虚拟专用网VPN（了解）"></a>14.虚拟专用网VPN（了解）</h4><p>  保留地址（私网地址）<br>  10.0.0.0——10.255.255.255<br>  172.16.0.0——172.31.255.255<br>  192.168.0.0——192.168.255.255</p><p>详见课本P185-187页</p><hr><h4 id="15-网络地址转换NAT（了解）"><a href="#15-网络地址转换NAT（了解）" class="headerlink" title="15.网络地址转换NAT（了解）"></a>15.网络地址转换NAT（了解）</h4><p>详见课本P187-P189页</p><hr><h4 id="16-IP地址和物理地址的区别"><a href="#16-IP地址和物理地址的区别" class="headerlink" title="16.IP地址和物理地址的区别"></a>16.IP地址和物理地址的区别</h4><p>为什么要使用这两种不同的地址？ IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。从而把整个因特网看成为一个单一的、抽象的网络在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><hr><h4 id="17-看累了？刷会儿题吧"><a href="#17-看累了？刷会儿题吧" class="headerlink" title="17.看累了？刷会儿题吧"></a>17.看累了？刷会儿题吧</h4><p>推荐习题：</p><p>4-07、4-09、4-10 、4-17 、4-18 、4-19 、4-20 、 4-21 、4-22 、4-26、4-27 、4-29 、4-30 、</p><p>4-31、4-34、4-35 、4-37 、4-41 、4-42 、4-47 、4-48  、4-49 、4-51、4-52 、4-54 、4-55、</p><p>4-56、4-58。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-IP地址及其表示方法&quot;&gt;&lt;a href=&quot;#1-IP地址及其表示方法&quot; class=&quot;headerlink&quot; title=&quot;1.IP地址及其表示方法&quot;&gt;&lt;/a&gt;1.IP地址及其表示方法&lt;/h4&gt;&lt;p&gt;IP地址表示方法{&amp;lt;网络号&amp;gt;,&amp;lt;主机号&amp;gt;}，一共32位。&lt;/p&gt;
&lt;p&gt;注：表示IP地址的时候不允许十进制和二进制混用。&lt;br&gt;
    
    </summary>
    
      <category term="网络原理" scheme="http://maojunjie666.top/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="http://maojunjie666.top/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>网络原理笔记(1-3章)</title>
    <link href="http://maojunjie666.top/2018/09/02/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E5%8E%9F%E7%AC%94%E8%AE%B0(1-3%E7%AB%A0)/"/>
    <id>http://maojunjie666.top/2018/09/02/网络原理/网原笔记(1-3章)/</id>
    <published>2018-09-02T01:39:35.025Z</published>
    <updated>2018-09-05T12:54:03.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-考试题型"><a href="#0-考试题型" class="headerlink" title="0.考试题型"></a>0.考试题型</h4><p>1.选择10题，2分<br>2.填空10空，1分<br>3.简答4题，每题5分<br>4.综合设计，5道题，50分。</p><p>综合设计题：<br>①给一个场景，根据所学去设计解决方案。<br>②抓取真实的网络数据，对其进行分析。<br><a id="more"></a></p><hr><h4 id="1-三种交换方式的对比"><a href="#1-三种交换方式的对比" class="headerlink" title="1.三种交换方式的对比"></a>1.三种交换方式的对比</h4><p>（1）电路交换</p><p>优点：建立连接使得所需通信资源得到可靠保障，连续传送大量数据时效率高。</p><p>缺点：电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。</p><p>适用场合：适合于数据量很大的实时性传输，核心路由之间可以使用电路交换。</p><p>（2）报文交换</p><p>优点：无须预约传输带宽，动态逐段利用传输资源，整个报文采用存储—转发的思想，对突发式数据通信效率高，通信迅速。</p><p>缺点：存在存储转发时延。</p><p>适用场合：突发性的数据，且端到端的通路有很少段的链路组成时，采用报文交换传送数据较为合适。</p><p> （3）分组交换</p><p>优点：具有报文交换之高效、迅速的优点，且各分组小，路由灵活，网络生存性能好。</p><p>缺点：存储转发时延以及额外的开销</p><p>适用场合：突发性的数据，且端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。</p><hr><h4 id="2-网络排错"><a href="#2-网络排错" class="headerlink" title="2.网络排错"></a>2.网络排错</h4><p>根据五层协议体系结构，由低层到高层依次排查错误：</p><p>物理层：检测网线是否破损，水晶头是否接触不良，网卡是否被禁用</p><p>链路层：检测MAC地址是否有效（MAC地址认证、MAC地址修改）</p><p>网络层：检测IP地址、网关、子网掩码是否正确配置</p><p>传输层：端口是否被禁用</p><p>应用层：检测DNS是否正确配置，浏览器是否设置代理</p><hr><h4 id="3-四种时延"><a href="#3-四种时延" class="headerlink" title="3.四种时延"></a>3.四种时延</h4><p><img src="https://i.loli.net/2018/07/05/5b3dca4a2de70.png" alt="1.png"></p><p>时延的计算：</p><p>​    发送时延=数据帧长度(bit)/发送速率（bit/s)</p><p>​    传播时延=信道长度(bit)/电磁波在信道上的传播速率（m/s)</p><p>​    时延带宽积= 传播时延*带宽</p><p><strong>注：发送时延和信道的长度无关，而传播时延与发送速率无关</strong></p><hr><h4 id="4-往返时间RTT和有效数据率"><a href="#4-往返时间RTT和有效数据率" class="headerlink" title="4.往返时间RTT和有效数据率"></a>4.往返时间RTT和有效数据率</h4><p>发送时间=数据长度/发送速率</p><p>有效数据率=数据长度/(发送时间+RTT)</p><p><strong>注：RTT题目会给出</strong></p><hr><h4 id="5-计算机网络五层模型"><a href="#5-计算机网络五层模型" class="headerlink" title="5.计算机网络五层模型"></a>5.计算机网络五层模型</h4><p><strong>①应用层</strong>：通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。</p><p>应用层交互的数据单元称为：<strong>报文</strong>。</p><p><strong>重要协议：</strong> DNS协议、HTTP协议、STMP协议</p><hr><p><strong>②运输层：</strong>负责向两台主机中进程之间的通信提供通用的数据传输服务。具有复用和分用的功能。</p><p><strong>重要协议</strong>：TCP协议和UDP协议</p><hr><p><strong>③网络层</strong>：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。</p><p>网络成的交互数据单元称为：<strong>IP数据报或数据报（分组和数据报同义）</strong></p><p><strong>重要协议</strong>：TCP/IP协议</p><p><strong>网络层设备：</strong>路由器</p><hr><p><strong>④数据链路层：</strong>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。在两个相邻结点直接传输数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点的链路上传送帧。</p><p>数据链路层的交互数据单元称为：<strong>帧</strong></p><p><strong>重要协议：</strong>PPP协议和 CSMA/CD协议</p><p><strong>数据链路层设备：</strong>交换机（网桥）</p><hr><p><strong>⑤物理层：</strong>物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。在物理层上所传数据的的单位是比特。</p><p><strong>物理层的设备：</strong>集线器（内部是总线型结构）</p><hr><h4 id="6-物理层的四个特性"><a href="#6-物理层的四个特性" class="headerlink" title="6.物理层的四个特性"></a>6.物理层的四个特性</h4><p> 机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<br> 电气特性：指明在接口电缆的各条线上出现的电压的范围。<br> 功能特性：指明某条线上出现的某一电平的电压表示何意。<br> 过程特性：指明对于不同功能的各种可能事件的出现顺序。 </p><hr><h4 id="7-数字信号和模拟信号"><a href="#7-数字信号和模拟信号" class="headerlink" title="7.数字信号和模拟信号"></a>7.数字信号和模拟信号</h4><p>数字信号：代表消息参数的取值是离散的</p><p>模拟信号：代表消息的参数取值是连续的</p><hr><h4 id="8-三种通信方式"><a href="#8-三种通信方式" class="headerlink" title="8.三种通信方式"></a>8.三种通信方式</h4><p>单向通信：又叫单工通信，只能发送而不能收到回馈，入电视，广播等。</p><p>双向交替通信：又叫半双工通信，双方都能发送信息，只是一方发送时另一方不能发送。</p><p>双向同时通信：又叫全双工通信，双方可以同时发送和接受信息。</p><hr><h4 id="9-码元的概念"><a href="#9-码元的概念" class="headerlink" title="9.码元的概念"></a>9.码元的概念</h4><p>码元：一码元可以携带n比特的信息，n的取值和码元的状态数相关。</p><p> 码元的传输速率（波特）与比特速率（bps或者b/s）的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Baud = log2M (bit/s)</span><br><span class="line">其中M是信号的编码数。也可以写成:Rbit = Rbaud log2M，上式中：Rbit-比特率，Rbaud-波特率。</span><br></pre></td></tr></table></figure><hr><h4 id="10-曼彻斯特和差分曼彻斯特编码"><a href="#10-曼彻斯特和差分曼彻斯特编码" class="headerlink" title="10.曼彻斯特和差分曼彻斯特编码"></a>10.曼彻斯特和差分曼彻斯特编码</h4><p>曼彻斯特：从低跳变到高代表0，从高跳变到低代表1。（bit和bit之间无跳转）</p><p>差分曼特斯特:跳变要看前一位bit，跳转代表0，不跳转代表1。(bit和bit之间有跳转)，且第一位是不确定的。</p><hr><h4 id="11-奈氏准则和香农公式"><a href="#11-奈氏准则和香农公式" class="headerlink" title="11.奈氏准则和香农公式"></a>11.奈氏准则和香农公式</h4><p><strong>奈奎斯特</strong>(Nyquist)推导出在理想低通信道下的最高码元传输速率的公式:</p><p>理想低通信道的最高码元传输速率 = 2W Baud</p><p>这里W是理想低通信道①的带宽,单位为赫(Hz);</p><p>Baud是波特,是码元传输速率的单位,1波特为每秒传送1个码元.</p><p>再根据香农公式推导出：C=2W*log₂(M)</p><p>其中，C为数据传输速率，W为带宽，单位HZ，M为信号状态数</p><p>上式就是著名的奈氏准则.奈氏准则的另一种表达方法是:每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元.</p><hr><p><strong>香农公式：</strong></p><p>C=W*log₂（1+S/N) （bit/s)<br>该式通常称为香农公式。C是码元速率的极限值(W为信道带宽，单位Bit/s)；S是信号功率（瓦），N是噪声功率（瓦）。<br>香农公式中的S/N是为信号与噪声的功率之比，为无量纲单位。如：S/N=1000（即，信号功率是噪声功率的1000倍）<br>但是，当讨论信噪比时，常以分贝（dB）为单位。公式如下：<br>SNR（信噪比，单位为dB)=10 lg（S/N)<br>换算一下：<br>S/N=10^(SNR/10）</p><hr><h4 id="12-信道复用技术"><a href="#12-信道复用技术" class="headerlink" title="12.信道复用技术"></a>12.信道复用技术</h4><p>频分复用：像大厅中不同的人同时用不同的语言交流</p><p>时分复用：像大厅中不同的人按一定的时间周期讲话。</p><p>统计时分复用：加了一个集中器，同时连接多个低速用户， 在时分复用的基础上，用户发送来的数据就收集起来，当缓存满了就发送出去，这样可以提高利用率。</p><p>波分复用：光的频分复用</p><p>码分复用：利用向量的叠加性原理来计算规格化内积。</p><hr><h4 id="13-数据链路层的基本问题"><a href="#13-数据链路层的基本问题" class="headerlink" title="13.数据链路层的基本问题"></a>13.数据链路层的基本问题</h4><p>三个基本问题<br>封装成帧：在一段数据的前后分别添加首部和尾部。</p><p>透明传输：让所有的信息都能传输，使用字节填充（转义字符）</p><p>帧的定界符：SOH和EOT，表示帧开始和帧结束。</p><p>他们的16进制编码分别为01（00000001）和04（000001000）。</p><p>转义符ESC：十六进制编码为(1B)</p><p>差错检测：CRC检测的计算。</p><hr><h4 id="14-ppp协议（点对点协议）"><a href="#14-ppp协议（点对点协议）" class="headerlink" title="14.ppp协议（点对点协议）"></a>14.ppp协议（点对点协议）</h4><p>PPP协议的首部：7E FF 03 协议 </p><p>PPP协议的尾部：FCS 7E </p><p>7E: 标志着一个帧的开始或结束，为定界符，若出现两个标志字段，这表示这是一个空帧，应当丢弃。</p><p>FF:为地址字段。</p><p>0x03：为控制字段。</p><p>协议字段：2个字节。</p><p>数据部分：不能超过1500字节。</p><p>FCS：帧检验序列，2个字节。</p><hr><p><strong>字节填充</strong>（实现透明传输）</p><p>信息字段中如果有7E，则加上转义字符0x7D，并使用字节填充。</p><p>①若出现0x7E，则填充为（0x7D，0x5E）</p><p>②若出现0x7D，则填充为(0x7D, 0x5D)</p><p>③若出现ASCII码的控制字符（数值小于0x20），则在前面加一个0x7D的字节，并把编码加以改变，例如，出现0x03，则把他们转变为(0x7D,0x23)  加20。</p><hr><p><strong>零比特填充</strong></p><p>如果发现5个连续的1，立即插入一个0，这样就保证不会出现6个连续的1，接收端在进行扫描时，如果发现5个连续的1，就把5个1后的1个0删除，以还原成原来的信息。</p><hr><h4 id="15-CSMA-CD协议"><a href="#15-CSMA-CD协议" class="headerlink" title="15.CSMA/CD协议"></a>15.CSMA/CD协议</h4><p><strong>碰撞检测</strong></p><p>争用期（Contention Period）就是以太网端到端往返时间2τ，又称为碰撞窗口（Collision Window）。 在局域网的分析中，常把总线上的单程端到端传播时延记为τ。通常取51.2微秒为争用期时间，对于10Mb/s以太网，期间可以发送512bit数据，即64字节。</p><p>CSMA/CD协议的最短数据帧长(bit):2倍信号传播时延(s)*数据传输速率(bps)=</p><p>2<em>(   两点的距离(m)    /（信号传播速率\</em>数据传输速率)     )</p><hr><p><strong>极限信道利用率</strong></p><p>Smax = 1 / (1+a)  其中a为( τ / T0)  τ为单程端时延，T0为帧的发送时间</p><hr><h4 id="16-MAC地址"><a href="#16-MAC地址" class="headerlink" title="16.MAC地址"></a>16.MAC地址</h4><p>硬件地址又称为物理地址或mac地址，全球统一，48位。</p><p>目标mac地址全为1即为广播地址。</p><p>查看mac地址的方法：ipconfig -all。</p><hr><h4 id="17-以太网交换机学习功能"><a href="#17-以太网交换机学习功能" class="headerlink" title="17.以太网交换机学习功能"></a>17.以太网交换机学习功能</h4><p>基于源mac地址的学习，记录在交换机的交换表中。具体见课本p100页</p><hr><h4 id="18-看累了刷会儿题吧"><a href="#18-看累了刷会儿题吧" class="headerlink" title="18.看累了刷会儿题吧"></a>18.看累了刷会儿题吧</h4><p>第一章推荐习题：1-03 、 1-05  、 1-10  、1-13   、1-15  、 1-17  、1-19  、1-22 、1 -29</p><p>第二章推荐习题：2-07 、 2-08  、 2-09  、2-13   、2-16</p><p>第三章推荐习题：3-07 、 3-08  、 3-09  、3-10   、3-20  、 3-22  、3-33</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-考试题型&quot;&gt;&lt;a href=&quot;#0-考试题型&quot; class=&quot;headerlink&quot; title=&quot;0.考试题型&quot;&gt;&lt;/a&gt;0.考试题型&lt;/h4&gt;&lt;p&gt;1.选择10题，2分&lt;br&gt;2.填空10空，1分&lt;br&gt;3.简答4题，每题5分&lt;br&gt;4.综合设计，5道题，50分。&lt;/p&gt;
&lt;p&gt;综合设计题：&lt;br&gt;①给一个场景，根据所学去设计解决方案。&lt;br&gt;②抓取真实的网络数据，对其进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="网络原理" scheme="http://maojunjie666.top/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="http://maojunjie666.top/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：深度优先搜索DFS(一)</title>
    <link href="http://maojunjie666.top/2018/09/02/%E6%90%9C%E7%B4%A2/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://maojunjie666.top/2018/09/02/搜索/算法学习：深度优先搜索/</id>
    <published>2018-09-02T01:39:35.023Z</published>
    <updated>2018-09-05T12:59:28.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>南阳理工学院校园里有一些小河和一些湖泊，现在，我们把它们通一看成水池，假设有一张我们学校的某处的地图，这个地图上仅标识了此处是否是水池，现在，你的任务来了，请用计算机算出该地图中共有几个水池。</p></blockquote><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>第一行输入一个整数N，表示共有N组测试数据<br>每一组数据都是先输入该地图的行数m(0&lt;m&lt;100)与列数n(0&lt;n&lt;100)，<br>然后，输入接下来的m行每行输入n个数，表示此处有水还是没水（1表示此处是水池，0表示此处是地面）</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>输出该地图中水池的个数。<br>要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2<br>3 4<br>1 0 0 0<br>0 0 1 1<br>1 1 1 0<br>5 5<br>1 1 1 1 0<br>0 0 1 0 1<br>0 0 0 0 0<br>1 1 1 0 0<br>0 0 1 1 1</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>3</p></blockquote><hr><p>这题是一道简单的dfs题目，dfs题，说白了就是暴力搜索的优化版本，属于不撞南墙不回头的算法，除非有东西阻挡，不然就会一直往下走，直到走完为止。</p><p>这题是求水池数目，我们可以用dfs对每个点的上下左右进行搜索，如果某个点的上下左右(某一个或多个)为1，则把这个点设置成0,一趟搜索来，我们可以把跟这个点连接的水池全部标记为0，然后给计数器变量加1，代表这整个为1个水池。只要对所有点都进行一遍dfs，则可以求出所有水池数目。</p><p><strong>技巧：</strong><br>①我们不用二维数组的第一行和第一列，并且将二维数组设置为num[105][105]，这样既可以防止数组越界，又可以用第1和101行已经第1列和101列来作为外围边界。<br>②初始时将二维数组全部设置为0，这样外围就存在边界了。<br>③将数组定义在外部，这样可以使dfs无序传数组的参数进入。<br><strong>Coding：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">using namespace std;</span><br><span class="line">int arr[N][N];</span><br><span class="line"></span><br><span class="line">void dfs(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    if(arr[a-1][b]==1)&#123;arr[a-1][b]=0,dfs(a-1,b);&#125;  //向上搜索</span><br><span class="line">    if(arr[a+1][b]==1)&#123;arr[a+1][b]=0,dfs(a+1,b);&#125;  //向下搜索</span><br><span class="line">    if(arr[a][b-1]==1)&#123;arr[a][b-1]=0,dfs(a,b-1);&#125;  //向左搜索</span><br><span class="line">    if(arr[a][b+1]==1)&#123;arr[a][b+1]=0,dfs(a,b+1);&#125;  //向右搜索</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)</span><br><span class="line">                cin&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(arr[i][j]==1)   //代表此点为水池</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    dfs(i,j);     //将与该水池相邻的水池都标记为0</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;南阳理工学院校园里有一些小河和一些湖泊，现在，我们把它们通一看成水池，假设有一张我们学校的某处的地图，这个地图上仅标识了此处是否是水池，现在，你的任务来了，请用计算机算出该地图中共有几个水池。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="DFS" scheme="http://maojunjie666.top/tags/DFS/"/>
    
      <category term="深度优先搜索" scheme="http://maojunjie666.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：深度优先搜索DFS(二)</title>
    <link href="http://maojunjie666.top/2018/09/02/%E6%90%9C%E7%B4%A2/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(2)/"/>
    <id>http://maojunjie666.top/2018/09/02/搜索/算法学习：深度优先搜索(2)/</id>
    <published>2018-09-02T01:39:35.014Z</published>
    <updated>2018-09-05T12:59:38.130Z</updated>
    
    <content type="html"><![CDATA[<p>##Oil Deposits</p><blockquote><p>Problem Description<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.</p></blockquote><a id="more"></a><blockquote><p>Input<br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either \’*’, representing the absence of oil, or ‘@’, representing an oil pocket.</p></blockquote><blockquote><p>Output<br>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p></blockquote><blockquote><p>Sample Input<br>1 1<br><em><br>3 5</em>@<em>@</em><br><strong>@</strong><br><em>@</em>@<em><br>1 8<br>@@<em>**</em>@</em><br>5 5<br><strong>*<em>@</em>@@<em>@</em>@</strong>@<br>@@@*@<br>@@**@<br>0 0 </p></blockquote><blockquote><p>Sample Output<br>0<br>1<br>2<br>2</p></blockquote><hr><p><strong>Thinking：</strong><br>这题是刚才那道水池问题的升级版，只不过这次是向八个方向搜索，根据水池那题的思路，我们可以得到一种代码，还有另一种使用二维向量和循环的方法，使代码更加简洁，这里两种方法都附上。</p><p><strong>Code1:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归出口判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[a][b]!=<span class="string">'@'</span>||a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&gt;n<span class="number">-1</span>||b&gt;m<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(judge(a,b))<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    arr[a][b]=<span class="string">'*'</span>;</span><br><span class="line">    <span class="comment">//向八个方向搜索</span></span><br><span class="line">    dfs(a<span class="number">-1</span>,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a<span class="number">-1</span>,b);</span><br><span class="line">    dfs(a<span class="number">-1</span>,b+<span class="number">1</span>);</span><br><span class="line">    dfs(a,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a,b+<span class="number">1</span>);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m &amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'@'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Code2:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[a][b]!=<span class="string">'@'</span>||a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&gt;n<span class="number">-1</span>||b&gt;m<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(judge(a,b))<span class="keyword">return</span> ;</span><br><span class="line">    arr[a][b]=<span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(a+moves[i][<span class="number">0</span>],b+moves[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m &amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'@'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##Oil Deposits&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Problem Description&lt;br&gt;The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DFS" scheme="http://maojunjie666.top/categories/DFS/"/>
    
    
      <category term="DFS" scheme="http://maojunjie666.top/tags/DFS/"/>
    
      <category term="深度优先搜索" scheme="http://maojunjie666.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数组和指针(一)</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/数组和指针/</id>
    <published>2018-09-02T01:39:35.000Z</published>
    <updated>2018-09-02T08:33:16.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h4><p>​    数组的下标可以是任意整数，可以是负数，也可以大于等于数组的元素个数，还能是小数（截取整数部分），如果出现这以下的情况，编译的时候也不会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> an[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) an[<span class="number">-2</span>]=<span class="number">5</span>;</span><br><span class="line">(<span class="number">2</span>) an[<span class="number">200</span>]=<span class="number">10</span>;</span><br><span class="line">(<span class="number">3</span>) an[<span class="number">10</span>]=<span class="number">20</span>;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">int</span> m =an[<span class="number">30</span>];</span><br></pre></td></tr></table></figure><p>这些语句的语法都没有任何问题，编译的时候也不会报错，那么an[-2]是什么含义呢？</p><p>它表示，数组an的起始地址为n，那么a[-2]就代表位于地址 n+(-2)*sizeof(int)处的一个int类型变量，即位于n-8处的一个int型变量。地址n-8处，可能存放的是其他变量，也可能存放的是其他指令，往该处写入数据，就可能意外更改其他变量的值，甚至更改程序的指令，程序继续运行就有可能出错。</p><p>向上述这些情况，就成为数组越界，语句4使m被赋了一个不可预料的值，在有的操作系统中，程序的某些内存区域是不能读取的，如果an[30]正好位于这样的区域，执行到语句(4)就会立即引发错误。</p><p>如果数组越界导致指令被修改的话，甚至会导致在调试器里调试的时候，程序不按照应当的次序运行的怪现象。比如单步调试程序的时候，明明碰到一个条件为真的if语句，却没有执行那个为真的分支。</p><hr><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>​    在32位系统中，指针是4个字节的，在64位系统中，指针是8个字节的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p =（<span class="keyword">int</span>*)<span class="number">10000</span>；<span class="comment">//这个指针的内容就代表内存地址10000，也可以说p指向内存地址10000</span></span><br><span class="line"><span class="comment">//上述语句执行后，如果想对内存地址10000起始的若干字节进行读写，就通过表达式"*p"来进行，因为表达式"*p"就代表地址p开始的若干字节。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*p = <span class="number">5000</span>；  <span class="comment">//往内存地址10000处的若干字节的内存空间里写入数值5000</span></span><br><span class="line"><span class="keyword">int</span> n =*p;  <span class="comment">//将内存地址10000处起始的若干字节的内容赋值给n，实际效果是使得n=5000</span></span><br></pre></td></tr></table></figure><p>显然，从等号两边的表达式类型应该兼容可以推想出，表达式”*p”的类型应该是int。</p><p>这里的若干字节就是一个int的所占的字节，sizeof(int)=4</p><blockquote><p>T * p;   // T可以是任意类型的名字，例如double，int，char等，下文碰到的T都是这个意思</p></blockquote><p>那么变量p就是一个指针变量（简称指针），p的类型 是T<em>，表达式”T\</em>“的类型是T。而通过表达式”*p”,我们就可以读写从地址p开始的size(T)个字节。</p><p><strong>敲黑板，记笔记</strong></p><p>​    通俗的说，可以认为，表达式”<em>p”可以等价于存放在地址p处的一个T类型的变量，表达式”\</em>P”中的”*“被称作间接引用运算符。</p><p>​    需要记住的是，不论T是什么类型，sizeof(T*)的值都是4或者8，一般来说编译器都是4个字节。</p><p>​    记住，对于类型为T的变量x，表达式”&amp;x”就表示变量x的地址，表达式”&amp;x”的类型是T *。</p><h5 id="不同类型的指针是不能直接进行赋值的"><a href="#不同类型的指针是不能直接进行赋值的" class="headerlink" title="不同类型的指针是不能直接进行赋值的"></a>不同类型的指针是不能直接进行赋值的</h5><p>​    不同类型的指针，如果不经过强制类型转换，是不能直接互相赋值的，如下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">int</span> * pn, <span class="keyword">char</span> *pc, <span class="keyword">char</span> c =<span class="number">0x65</span>;</span><br><span class="line">(<span class="number">2</span>)pn = pc;</span><br><span class="line">(<span class="number">3</span>)pn =&amp; c;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">int</span> n =*pn;</span><br><span class="line">(<span class="number">5</span>) *pn = <span class="number">0x12345678</span>;</span><br></pre></td></tr></table></figure><p>​    语句2和语句3都会在编译的时候保存，错误信息是类型不兼容，因为在这两条语句中，等号左边的类型是int <em>，而等号右边的类型是 char </em>。语句4则没有问题，虽然表达式”&amp;c”的类型是char *,但是其值经过强制类型转换后，赋给pn是可以的，语句4执行的效果是使得pn指向c的地址。</p><p>​    思考题：语句5的执行效果是使得n的值变为0x65吗，语句6编译会不会出错？如果不出错，执行后会有什么结果呢？会不会有问题？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数组越界&quot;&gt;&lt;a href=&quot;#数组越界&quot; class=&quot;headerlink&quot; title=&quot;数组越界&quot;&gt;&lt;/a&gt;数组越界&lt;/h4&gt;&lt;p&gt;​    数组的下标可以是任意整数，可以是负数，也可以大于等于数组的元素个数，还能是小数（截取整数部分），如果出现这以下的情
      
    
    </summary>
    
    
      <category term="C语言" scheme="http://maojunjie666.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>链表的基本操作（整表删除篇）</title>
    <link href="http://maojunjie666.top/2018/09/02/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4%E7%AF%87%EF%BC%89/"/>
    <id>http://maojunjie666.top/2018/09/02/链表/链表的基本操作（整表删除篇）/</id>
    <published>2018-09-02T01:39:34.991Z</published>
    <updated>2018-09-05T12:52:08.940Z</updated>
    
    <content type="html"><![CDATA[<p>注：<strong>这里跟上篇一样，均未写释放链表的操作，以后内容将补上</strong></p><p>当我们不打算在使用这个单链表时，我们需要把它销毁，思路如下：<br><a id="more"></a><br>①声明一个结点p和q；</p><p>②将第一个结点赋值给p；</p><p>③循环：</p><p>​    (1)将下一个结点赋值给q；</p><p>​    (2)释放p；</p><p>​    (3)将q赋值给p。</p><p>具体实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearList</span><span class="params">(Node **L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=(*L)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//头结点的指针域设为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head,*p;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"遍历链表：\n"</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    ClearList(&amp;head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：&lt;strong&gt;这里跟上篇一样，均未写释放链表的操作，以后内容将补上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们不打算在使用这个单链表时，我们需要把它销毁，思路如下：&lt;br&gt;
    
    </summary>
    
      <category term="链表" scheme="http://maojunjie666.top/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="链表" scheme="http://maojunjie666.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
