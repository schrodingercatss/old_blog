<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哲♂学家的小黑屋</title>
  
  <subtitle>Rick&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maojunjie666.top/"/>
  <updated>2018-11-20T08:36:16.583Z</updated>
  <id>http://maojunjie666.top/</id>
  
  <author>
    <name>Schoringercatss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>神奇的魔术牌</title>
    <link href="http://maojunjie666.top/2018/11/20/%E6%95%B0%E8%AE%BA/pokermagic/"/>
    <id>http://maojunjie666.top/2018/11/20/数论/pokermagic/</id>
    <published>2018-11-20T08:24:41.885Z</published>
    <updated>2018-11-20T08:36:16.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="神奇的魔术牌"><a href="#神奇的魔术牌" class="headerlink" title="神奇的魔术牌"></a>神奇的魔术牌</h4><p>这个游戏的套路其实是组合数学里面的一个排列问题，只要牌数是奇数且为3个倍数，就能成立。下面我抛开代码，就数学问题来分析这个算法的可行性。<br><a id="more"></a></p><hr><h4 id="基础玩法—9张牌"><a href="#基础玩法—9张牌" class="headerlink" title="基础玩法—9张牌"></a>基础玩法—9张牌</h4><p>1、从一副扑克牌中随便找出9张纸牌。</p><p>2、让玩家从这9张中随便找出一张，牢记这张牌。</p><p>3、把9张牌分成3组，每组3张。（让牌背向上，从左到右，从上到下依次）</p><p>4、从第一堆牌开始询问玩家他所选的牌有没有在里面。</p><p>5、将有的那一组放在没有的两堆中间，然后又开始分三堆，再次询问玩家。</p><p>6、将有的那一组放在没有的两堆中间，从上往下数，玩家所选的牌一定在第5张。</p><hr><h4 id="升级版玩法—15张牌"><a href="#升级版玩法—15张牌" class="headerlink" title="升级版玩法—15张牌"></a>升级版玩法—15张牌</h4><p>1、从一副扑克牌中随便找出15张纸牌。</p><p>2、让玩家从这15张中随便找出一张，牢记这张牌。</p><p>3、把9张牌分成3组，每组5张。（让牌背向上，从左到右，从上到下依次）</p><p>4、从第一堆牌开始询问玩家他所选的牌有没有在里面。（第一次）</p><p>5、将有的那一组放在没有的两堆中间，然后又开始分三堆，再次询问玩家。（第二次）</p><p>6、将有的那一组放在没有的两堆中间，然后又开始分三堆，再次询问玩家。（第三次）</p><p>7、将有的那一组放在没有的两堆中间，从上往下数，玩家所选的牌一定在第8张。</p><hr><h4 id="升级—21张牌"><a href="#升级—21张牌" class="headerlink" title="升级—21张牌"></a>升级—21张牌</h4><p>1、从一副扑克牌中随便找出21张纸牌。</p><p>2、让玩家从这21张中随便找出一张，牢记这张牌。</p><p>3、把21张牌分成3组，每组7张。（让牌背向上，从左到右，从上到下依次）</p><p>4、从第一堆牌开始询问玩家他所选的牌有没有在里面。（第一次）</p><p>5、将有的那一组放在没有的两堆中间，然后又开始分三堆，再次询问玩家。（第二次）</p><p>6、将有的那一组放在没有的两堆中间，然后又开始分三堆，再次询问玩家。（第三次）</p><p>7、将有的那一组放在没有的两堆中间，从上往下数，玩家所选的牌一定在第11张。</p><hr><h4 id="数学原理的分析"><a href="#数学原理的分析" class="headerlink" title="数学原理的分析"></a>数学原理的分析</h4><p>图中计数原理的声明：<br>1、分组时，牌背面朝上，从左至右，从下到上；</p><p><img src="https://i.loli.net/2018/11/20/5bf38b95e258d.jpg" alt="1.jpg"><br>2、下文中所说的牌位置n的计数方法为，牌背面朝上，从上往下，从左到右数；</p><p><img src="https://i.loli.net/2018/11/20/5bf38bb01197d.jpg" alt="2.jpg"></p><hr><h4 id="九张牌玩法的数学原理解释"><a href="#九张牌玩法的数学原理解释" class="headerlink" title="九张牌玩法的数学原理解释"></a>九张牌玩法的数学原理解释</h4><p>以9张牌为例，从数学角度分析；</p><p>1、从牌库中抽出9张牌，是一个随机事件，对结果无任何影响；</p><p>2、玩家从9张牌中随机选取一张，那么这张牌的初始位置为n(n=1~9);</p><p><img src="https://i.loli.net/2018/11/20/5bf38bfc2a5cc.jpg" alt="3.jpg"></p><p>3、按照游戏的操作流程，此时把9张牌分成3组A、B、C，每组3张，依次询问玩家，以便确认所选的牌在哪一组，并将这一组放置在三组的中间位置，此时所选这张牌的位置n={4、5、6}。</p><p><img src="https://i.loli.net/2018/11/20/5bf38bfbc53ad.jpg" alt="4.jpg"></p><p>4、按照游戏的操作流程，此时把9张牌分成3组A、B、C，每组3张，此时牌的排序变化如下，n={2、5、8}：</p><p><img src="https://i.loli.net/2018/11/20/5bf38bfc39a36.jpg" alt="5.jpg"></p><p>5、再次询问玩家，确认所选的牌在哪一组，并将这一组放置在三组的中间位置（无论在ABC那组），此时便可确认这张牌的位置n=5。</p><p><img src="https://i.loli.net/2018/11/20/5bf38bfb9ae21.jpg" alt="6.jpg"></p><hr><h4 id="十五张牌玩法的数学原理解释"><a href="#十五张牌玩法的数学原理解释" class="headerlink" title="十五张牌玩法的数学原理解释"></a>十五张牌玩法的数学原理解释</h4><p>1、从牌库中抽出15张牌，是一个随机事件，对结果无任何影响；</p><p>2、玩家从15张牌中随机选取一张，那么这张牌的初始位置为n(n=1~15);</p><p><img src="https://i.loli.net/2018/11/20/5bf38cdee50a2.jpg" alt="1.jpg"></p><p>3、按照游戏的操作流程，此时把15张牌分成3组，每组5张，依次询问玩家，以便确认所选的牌在哪一组，并将这一组放置在三组的中间位置，即放在B组中，此时所选这张牌的位置n={6、7、8、9、10}</p><p><img src="https://i.loli.net/2018/11/20/5bf38cdee353d.jpg" alt="2.jpg"></p><p>4、按照游戏的操作流程，此时再把15张牌分成3组，每组5张。此时中间一组的位置被重新放置，如下图所示：依次询问玩家，确认所选的牌在哪一组，此时所选这张牌的位置n={3、4、8、12、13}。若在A组，n={3、4}，若在B组，n=8,若在C组，n={12、13}</p><p><img src="https://i.loli.net/2018/11/20/5bf38cdef2788.jpg" alt="3.jpg"></p><p>5、将这一组放置在三组的中间位置，即放在B组的位置，此时所选这张牌的位置n={7、8、9}。若在A组过来的，n={8、9}，若在B组过来的n=8,若在C组过来的n={7、8}；</p><p><img src="https://i.loli.net/2018/11/20/5bf38cdf17b90.jpg" alt="4.jpg"></p><p>6、此时再把15张牌分成3组，每组5张，</p><p>　　若是A组过来的：那么再次分配以后，n={8、13}：</p><p>　　若是B组过来的：那么再次分配以后，n=8：</p><p>　　若是C组过来的：那么再次分配以后，n={3、8}：</p><p><img src="https://i.loli.net/2018/11/20/5bf38cdf27335.jpg" alt="5.jpg"></p><hr><h4 id="游-ren-戏-lei-的本质"><a href="#游-ren-戏-lei-的本质" class="headerlink" title="游(ren)戏(lei)的本质"></a>游(ren)戏(lei)的本质</h4><p>1、游戏的本质是一个数学的排列问题；</p><p>2、每次询问都是一个筛选过程；</p><p>3、只要询问和排列的数量足够，无论多少张牌都可以算出目标牌的具体位置;</p><hr><h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>1、分三组的情况下，扑克的数量可以为${9、15、21、27、33、39…}$,假设扑克总数量为$m$，则:$m = 6 n + 3$,其中n为正整数;</p><p>2、游戏最多的操作数次数为k，则：$K= 2+ ⌈\frac{n-1}{3} ⌉$其中($ ⌈\frac{n-1}{3} ⌉$,为向上取整运算符,比如$⌈5.20⌉ = 6$ )</p><hr><h4 id="合理猜想"><a href="#合理猜想" class="headerlink" title="合理猜想"></a>合理猜想</h4><p>既然分三组可以玩，那么分其他奇数组也应该可以玩；<br>1、假设扑克牌分组数量为m，m=2i+1，i为正整数；</p><p>2、抽取的扑克牌总数为M，则：</p><p>$M =(2i+1)(2n+1)$(其中n、i为正整数)</p><p>3、最多需要操作的次数为K，则：</p><p>$K = 2 + ⌈\frac{n-i}{2i+1} ⌉$(其中n、i为正整数)</p><p>有兴趣的同学可以使用数学归纳法去证明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;神奇的魔术牌&quot;&gt;&lt;a href=&quot;#神奇的魔术牌&quot; class=&quot;headerlink&quot; title=&quot;神奇的魔术牌&quot;&gt;&lt;/a&gt;神奇的魔术牌&lt;/h4&gt;&lt;p&gt;这个游戏的套路其实是组合数学里面的一个排列问题，只要牌数是奇数且为3个倍数，就能成立。下面我抛开代码，就数学问题来分析这个算法的可行性。&lt;br&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://maojunjie666.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://maojunjie666.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>院程序设计大赛（低年级组题解）</title>
    <link href="http://maojunjie666.top/2018/11/15/%E9%A2%98%E8%A7%A3/%E9%99%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E4%BD%8E%E5%B9%B4%E7%BA%A7%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <id>http://maojunjie666.top/2018/11/15/题解/院程序设计大赛低年级组题解/</id>
    <published>2018-11-15T10:10:50.929Z</published>
    <updated>2018-11-15T14:46:11.400Z</updated>
    
    <content type="html"><![CDATA[<p>出题人感想：咱们很多同学还是很不错的，但是还是太依赖python的语言特性了，希望以后能抛弃python尝试用c语言去写题目，这次的题目难度很合理，控制在我能20分钟AK的范围，然后还把F题给削弱了，希望大家不要来205砍我（TvT）。<br><a id="more"></a></p><hr><h4 id="A题：听说你用不了sum函数了"><a href="#A题：听说你用不了sum函数了" class="headerlink" title="A题：听说你用不了sum函数了"></a>A题：听说你用不了sum函数了</h4><p>这题很简单，输入以后，遍历整个列表，判断奇偶就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">while</span> n :</span><br><span class="line">    odd = even = <span class="number">0</span></span><br><span class="line">    l = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(l)):</span><br><span class="line">        <span class="keyword">if</span> l[i] % <span class="number">2</span>:</span><br><span class="line">            odd += l[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even += l[i]</span><br><span class="line"></span><br><span class="line">    print(odd, even)</span><br><span class="line">    n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="B题：听说你用不了sort函数了"><a href="#B题：听说你用不了sort函数了" class="headerlink" title="B题：听说你用不了sort函数了"></a>B题：听说你用不了sort函数了</h4><p>这题也很简单，因为数据范围很小，直接使用冒泡排序，然后排序规则中使用abs函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sort</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> abs(l[j]) &gt; abs(l[j + <span class="number">1</span>]):</span><br><span class="line">                l[j], l[j + <span class="number">1</span>] = l[j + <span class="number">1</span>], l[j]</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">while</span> n :</span><br><span class="line">    l = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">    l = my_sort(l[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        print(i,end=<span class="string">" "</span>)</span><br><span class="line">    print()</span><br><span class="line">    n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="C题：赤坂龙之介的困惑"><a href="#C题：赤坂龙之介的困惑" class="headerlink" title="C题：赤坂龙之介的困惑"></a>C题：赤坂龙之介的困惑</h4><p>进制转换，除基取整法和乘基取余法，导论你们都学了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change1</span><span class="params">(num)</span>:</span></span><br><span class="line">    map = <span class="string">"0123456789ABCDEF"</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">        res += map[num % <span class="number">15</span>]</span><br><span class="line">        num //= <span class="number">15</span></span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change2</span><span class="params">(num)</span>:</span></span><br><span class="line">    tmp = num[<span class="number">2</span>:]  </span><br><span class="line">    res = <span class="number">0</span>      </span><br><span class="line">    p = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">        res += int(i) * pow(<span class="number">1</span>/<span class="number">2</span>,p)  <span class="comment">#每个位的位权是(1/2)的cnt次方</span></span><br><span class="line">        p += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">str = input().split()</span><br><span class="line">num1 = int(str[<span class="number">0</span>])</span><br><span class="line">num2 = str[<span class="number">1</span>]  <span class="comment">#保留小数字符</span></span><br><span class="line">print(change1(num1),change2(num2))</span><br></pre></td></tr></table></figure><hr><h4 id="D题：昨日青空"><a href="#D题：昨日青空" class="headerlink" title="D题：昨日青空"></a>D题：昨日青空</h4><p>这题彩蛋，输出的答案必须跟”参考答案“完全相同，题干中还有提到概率，如果用单个次数除以总次数，得到的是频率，这题是一个绝对事件，在情况足够多时可以认为去两个电影院的概率是均等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n =int(input())</span><br><span class="line"><span class="keyword">while</span> n :</span><br><span class="line">    str = input()</span><br><span class="line">    print(<span class="string">"0.500000000000"</span>)</span><br><span class="line">    n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="E题：毛学姐的除法游戏"><a href="#E题：毛学姐的除法游戏" class="headerlink" title="E题：毛学姐的除法游戏"></a>E题：毛学姐的除法游戏</h4><p>  这个问题的关键是因子。两个数的最大公约数里包含了所有的共有的因子。  知道最大公约数后，进一步对b进行计算就知道了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">return</span> gcd(m, n % m)</span><br><span class="line"></span><br><span class="line">n, m = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">tmp = gcd(n, m)</span><br><span class="line">m = m / tmp</span><br><span class="line"><span class="keyword">if</span>( tmp % m == <span class="number">0</span>):</span><br><span class="line">    print(<span class="string">"Yes"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="F题：大佬的坐姿"><a href="#F题：大佬的坐姿" class="headerlink" title="F题：大佬的坐姿"></a>F题：大佬的坐姿</h4><p>相当于从第一个人开始，依次判断属性，0则向左延伸，1则向右延伸。即0从大到小排列，接上1从小到大排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n=int(input())</span><br><span class="line">l1=[]</span><br><span class="line">l2=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    flag, name=input().split()</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="string">'0'</span>:</span><br><span class="line">        l1.append(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.append(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l1)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    print(l1[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l2:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><hr><h4 id="G题：血小板网络"><a href="#G题：血小板网络" class="headerlink" title="G题：血小板网络"></a>G题：血小板网络</h4><p>因为数据范围特别小，所以可以暴力枚举，有两种思路，第一种用两个变量来记录，一个记录上一个点的距离，一个用来标记状态，如果前一个和后一个不等，对ok做一次与运算，如果ok==1，则可以判断这个点是圆心，然后输出即可，第二种是开了一个二维数组来储存距离，然后用循环遍历。</p><p>法一最优，而法二最容易想到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法一：</span></span><br><span class="line">x = [<span class="number">0</span>] * <span class="number">5201314</span>;</span><br><span class="line">y = [<span class="number">0</span>] * <span class="number">5201314</span>;</span><br><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    x[i], y[i] = [int(m) <span class="keyword">for</span> m <span class="keyword">in</span> input().split()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    ok = <span class="number">1</span></span><br><span class="line">    p = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i != j:</span><br><span class="line">            s = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])</span><br><span class="line">            <span class="keyword">if</span> p == <span class="number">-1</span>: </span><br><span class="line">                p = s;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ok = (ok <span class="keyword">and</span> (p==s))</span><br><span class="line">    <span class="keyword">if</span> ok:</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> ok == <span class="number">0</span>:</span><br><span class="line">    print(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法二：copy自某个妹纸</span></span><br><span class="line">n=int(input())</span><br><span class="line">I=[[int(x)<span class="keyword">for</span> x <span class="keyword">in</span> input().split()]<span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">a=<span class="number">0</span></span><br><span class="line">L=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i==j:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L.append(((I[i][<span class="number">0</span>]-I[j][<span class="number">0</span>])**<span class="number">2</span>+(I[i][<span class="number">1</span>]-I[j][<span class="number">1</span>])**<span class="number">2</span>)**<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> L.count(L[<span class="number">0</span>])==len(L):</span><br><span class="line">        print(i+<span class="number">1</span>)</span><br><span class="line">        a=<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">    print(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出题人感想：咱们很多同学还是很不错的，但是还是太依赖python的语言特性了，希望以后能抛弃python尝试用c语言去写题目，这次的题目难度很合理，控制在我能20分钟AK的范围，然后还把F题给削弱了，希望大家不要来205砍我（TvT）。&lt;br&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://maojunjie666.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>百练oj2979：最短前缀</title>
    <link href="http://maojunjie666.top/2018/09/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/%E7%99%BE%E7%BB%83oj2797%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%89%8D%E7%BC%80/"/>
    <id>http://maojunjie666.top/2018/09/20/字符串处理/百练oj2797：最短前缀/</id>
    <published>2018-09-20T11:00:38.062Z</published>
    <updated>2018-09-20T11:48:13.374Z</updated>
    
    <content type="html"><![CDATA[<p>这题有挺多的做法，我刚开始做的时候是O(n^3)的做法，使用三个循环，其中，对每个字符串进行遍历，从1-n(n代表字符串长度)来在其他字符串中进行暴力查找，如果没有找到，则说明这个就是最长公共前缀，如果在最后都没有找到最长公共前缀，那么就输出他本身即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:102400000,102400000"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _for(i,a,n)for(int i=a;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mt(arr,n) memset(arr,n,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf ~0u&gt;&gt;1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close();</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;v.pb(s);&#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,v.size()) &#123;</span><br><span class="line">        rep(j,<span class="number">1</span>,v[i].size()+<span class="number">1</span>)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp = v[i].substr(<span class="number">0</span>,j);</span><br><span class="line">            rep(k,<span class="number">0</span>,v.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(v[k].find(tmp)==<span class="number">0</span>)&#123;<span class="comment">//这里不能使用string::npos 因为可能中间有子串存在</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;v[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种更高效的做法就是，对各个字符串的最长前缀进行不停的迭代，当迭代到最后一遍时，就能找到该字符串的最长前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:102400000,102400000"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _for(i,a,n)for(int i=a;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mt(arr,n) memset(arr,n,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf ~0u&gt;&gt;1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close();</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</span><br><span class="line">        v.pb(s);</span><br><span class="line">    &#125;</span><br><span class="line">    mt(flag,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//寻找每一个串的跟其他串的最长公共前缀</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;v.size();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;v[i][k] != <span class="string">'\0'</span> &amp;&amp; v[j][k] != <span class="string">'\0'</span>;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][k]!=v[j][k])<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=flag[i])flag[i]++;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=flag[j])flag[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=flag[i];++j)<span class="keyword">if</span>(v[i][j]!=<span class="string">'\0'</span>)<span class="built_in">cout</span>&lt;&lt;v[i][j]; <span class="comment">//这里有可能最长的公共前缀等于自身长度，需要加一个判断，才能保证不越界</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题有挺多的做法，我刚开始做的时候是O(n^3)的做法，使用三个循环，其中，对每个字符串进行遍历，从1-n(n代表字符串长度)来在其他字符串中进行暴力查找，如果没有找到，则说明这个就是最长公共前缀，如果在最后都没有找到最长公共前缀，那么就输出他本身即可。&lt;/p&gt;
    
    </summary>
    
      <category term="字符串处理" scheme="http://maojunjie666.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    
      <category term="字符串处理" scheme="http://maojunjie666.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>openjudge百练---八进制小数</title>
    <link href="http://maojunjie666.top/2018/09/18/%E6%9D%82%E9%A1%B9/%E5%B7%A7%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
    <id>http://maojunjie666.top/2018/09/18/杂项/巧用占位符/</id>
    <published>2018-09-18T09:20:34.745Z</published>
    <updated>2018-09-18T09:35:17.671Z</updated>
    
    <content type="html"><![CDATA[<p>这题我们可以对八进制小数先进行进制转换，转换成十进制小数，然后再利用%g的忽略末尾无效0的特性，因为最大长度是45位小数，<br>所以我们使用%45.g即可。</p><p><a href="http://bailian.openjudge.cn/practice/2765/" target="_blank" rel="noopener">题目传送门</a><br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:102400000,102400000"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mt(arr,n) memset(arr,n,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf ~0u&gt;&gt;1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num)&#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">            n = (n)/<span class="number">8.0</span> + num[i]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n/=<span class="number">8.0</span>; <span class="comment">//处理小数点前面那个</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" [8] = %.45g [10]\n"</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题我们可以对八进制小数先进行进制转换，转换成十进制小数，然后再利用%g的忽略末尾无效0的特性，因为最大长度是45位小数，&lt;br&gt;所以我们使用%45.g即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bailian.openjudge.cn/practice/2765/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="进制转换" scheme="http://maojunjie666.top/categories/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    
      <category term="进制转换" scheme="http://maojunjie666.top/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>矩阵类模板</title>
    <link href="http://maojunjie666.top/2018/09/14/%E6%9D%82%E9%A1%B9/%E7%9F%A9%E9%98%B5%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <id>http://maojunjie666.top/2018/09/14/杂项/矩阵类模板/</id>
    <published>2018-09-14T11:59:13.290Z</published>
    <updated>2018-09-14T12:03:32.881Z</updated>
    
    <content type="html"><![CDATA[<p>【功能】实现矩阵的基本变化</p><p>【接口】</p><p>结构体：Matrix</p><a id="more"></a><p>成员变量：</p><p>​    int n,m：矩阵大小</p><p>​    int a[][]：矩阵内容</p><p>重载运算符：+、-、*</p><p>成员函数：</p><p>void Clear()：清空矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MANM =<span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> arr[MAXN][MAXM];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n=m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span>   <span class="comment">//矩阵加法</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n,tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)tmp.arr[i][j]=arr[i][j]+b.arr[i][j];</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span>  <span class="comment">//矩阵乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n,tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)tmp.arr[i][j]=arr[i][j]-b.arr[i][j];</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span> <span class="comment">//矩阵乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.Clear();</span><br><span class="line">        tmp.n=n,tmp.m=b.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)tmp.arr[i][j]=arr[i][k]*b.arr[k][j];</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【功能】实现矩阵的基本变化&lt;/p&gt;
&lt;p&gt;【接口】&lt;/p&gt;
&lt;p&gt;结构体：Matrix&lt;/p&gt;
    
    </summary>
    
      <category term="矩阵" scheme="http://maojunjie666.top/categories/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="模板" scheme="http://maojunjie666.top/categories/%E7%9F%A9%E9%98%B5/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="矩阵" scheme="http://maojunjie666.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>同余定理及大整数取余</title>
    <link href="http://maojunjie666.top/2018/09/11/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>http://maojunjie666.top/2018/09/11/数论/同余定理/</id>
    <published>2018-09-11T07:29:17.415Z</published>
    <updated>2018-09-11T10:30:13.723Z</updated>
    
    <content type="html"><![CDATA[<p><strong>同余定理</strong>：两个整数同时除以一个整数得到的余数相同，则二整数同余。记作a ≡ b(mod m)。</p><p>1.对于同一个除数，两个数之和（或差）与它们的余数之和（或差）同余。 </p><p>2.对于同一个除数，两个数的乘积与它们余数的乘积同余。 </p><a id="more"></a><p>3.对于同一个除数，如果有两个整数同余，那么它们的差就一  定能被这个除数整除。 </p><p>4.对于同一个除数，如果两个数同余，那么他们的乘方仍然同余。   </p><p><strong>高精度求模法和快速幂取模都是利用了同余定理。</strong></p><hr><p><strong>同余定理的加法乘法应用:</strong></p><blockquote><p>(a + b) % m = (a % m + b % m) % m</p><p>设 a = k1 <em> m + r1，b = k2 </em> m + r2<br>则 (a + b) % m = ((k1 <em> m + r1) + (k2 </em> m + r2)) % m<br>              = ((k1 + k2) * m + (r1 + r2)) % m<br>              = (r1 + r2) % m<br>              = (a % m + b % m) % m<br>所以 (a + b) % m = (a % m + b % m) % m</p><p> (a <em> b) % m = ((a % m) </em> (b % m)) % m</p></blockquote><blockquote><p>设 a = k1 <em> m + r1，b = k2 </em> m + r2<br>则 (a <em> b) % m = ((k1 </em> m + r1) <em> (k2 </em> m + r2)) % m<br>               = (k1 <em> k2 </em> m^2 + (k1 <em> r2 + k2 </em> r1) <em> m + r1 </em> r2) % m<br>               = (r1 <em> r2) % m<br>               = ((a % m) </em> (b % m)) % m<br>所以 (a <em> b) % m = ((a % m) </em> (b % m)) % m</p></blockquote><hr><h4 id="大数高精度取余"><a href="#大数高精度取余" class="headerlink" title="大数高精度取余"></a>大数高精度取余</h4><p><a href="http://nyoj.top/problem/205" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们可以利用同余定理的性质，使用大整数的高精度取余法，对逐个位进行取余操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input()&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,str.size())&#123;</span><br><span class="line">            ret=(ret*<span class="number">10</span>+str[i]-<span class="string">'0'</span>)%<span class="number">10003</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="例题二："><a href="#例题二：" class="headerlink" title="例题二："></a>例题二：</h4><blockquote><p>给出正整数 n 和 m，统计满足以下条件的正整数对 (a,b) 的数量</p><p>1≤a≤n,1≤b≤m;</p><p>a×b 是 2016 的倍数。</p><p>Input</p><p>输入包含不超过 30 组数据。</p><p>每组数据包含两个整数 n,m (1≤n,m≤109).</p><p>Output对于每组数据，输出一个整数表示满足条件的数量。 Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;32 63</span><br><span class="line">&gt;2016 2016</span><br><span class="line">&gt;1000000000 1000000000</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1</span><br><span class="line">&gt;30576</span><br><span class="line">&gt;7523146895502644</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>根据同余定理，要使a和b的乘积是2016的倍数，只需要a和b的模的乘积是2016的倍数即可。</p><p>首先，我们将n/2016,m/2016，求出1-n中有多少个2016的倍数，然后求1-m中有多少个2016的倍数，然后对n%2016进行取余，我们先进行预处理余数为i的个数，n/2016，m/2016，分别代表n中有多少轮2016，比如n/2016=2，则说明余数从0到2015滚了两轮，所以给a[i]的每一位赋值为2。然后把剩余的未处理的数再进行处理一遍，比如2017/2016=1,那么1-2016已经处理完毕，接下来处理2017%2016=1，说明还剩下1个数没有处理，处理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _for(i,a,n) for(int i=a;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> input() int t;cin&gt;&gt;t;while(t--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">2016</span>],b[<span class="number">2016</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close();</span><br><span class="line">    ll n,m,ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//预处理余数为i的个数</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2016</span>) a[i]=n/<span class="number">2016</span>,b[i]=m/<span class="number">2016</span>;</span><br><span class="line">        </span><br><span class="line">        _for(i,<span class="number">1</span>,n%<span class="number">2016</span>)a[i]++;</span><br><span class="line">        _for(i,<span class="number">1</span>,m%<span class="number">2016</span>)b[i]++;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2016</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2016</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>((i*j)%<span class="number">2016</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=a[i]*b[j];</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;同余定理&lt;/strong&gt;：两个整数同时除以一个整数得到的余数相同，则二整数同余。记作a ≡ b(mod m)。&lt;/p&gt;
&lt;p&gt;1.对于同一个除数，两个数之和（或差）与它们的余数之和（或差）同余。 &lt;/p&gt;
&lt;p&gt;2.对于同一个除数，两个数的乘积与它们余数的乘积同余。 &lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="http://maojunjie666.top/categories/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="高精度" scheme="http://maojunjie666.top/categories/%E6%95%B0%E8%AE%BA/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
    
      <category term="数论" scheme="http://maojunjie666.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="高精度" scheme="http://maojunjie666.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的基本术语</title>
    <link href="http://maojunjie666.top/2018/09/11/Data_structrue/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/"/>
    <id>http://maojunjie666.top/2018/09/11/Data_structrue/数据结构的基本术语/</id>
    <published>2018-09-11T00:08:04.517Z</published>
    <updated>2018-09-11T00:31:55.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h4><p> <strong>数据(Data)</strong> ：是客观事物的符号表示。在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素(Data Element)</strong> ：是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。</p><p>一个数据元素可由若干个数据项(Data Item)组成。数据项是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。<br><a id="more"></a><br><strong>数据对象(Data Object)</strong>：是性质相同的数据元素的集合，是数据的一个子集。如字符集合C={‘A’,’B’,’C,…}</p><p><strong>数据结构(Data Structure)：</strong>是指相互之间具有(存在)一定联系(关系)的数据元素的集合。元素之间的相互联系(关系)称为逻辑结构。数据元素之间的逻辑结构有四种基本类型。</p><blockquote><p>① 集合：结构中的数据元素除了“同属于一个集合”外，没有其它关系。</p><p>② 线性结构：结构中的数据元素之间存在一对一的关系。</p><p>③ 树型结构：结构中的数据元素之间存在一对多的关系。</p><p>④ 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</p></blockquote><hr><h4 id="数据结构形式的定义"><a href="#数据结构形式的定义" class="headerlink" title="数据结构形式的定义"></a>数据结构形式的定义</h4><p><strong>数据结构的形式定义是一个二元组：</strong><br>Data-Structure=(D，S)<br>其中：D是数据元素的有限集，S是D上关系的有限集。</p><p>数据元素之间的关系可以是元素之间代表某种含义的自然关系，也可以是为处理问题方便而人为定义的关系，这种自然或人为定义的 “关系”称为数据元素之间的逻辑关系，相应的结构称为逻辑结构。</p><hr><h4 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h4><p>数据结构在计算机内存中的存储包括数据元素的存储和元素之间的关系的表示。<br>元素之间的关系在计算机中有两种不同的表示方法：顺序表示和非顺序表示。</p><p>由此得出两种不同的存储结构：<strong>顺序存储结构和链式存储结构。</strong></p><p><strong>顺序存储结构：</strong>用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)。</p><p><strong>链式存储结构：</strong>在每一个数据元素中增加一个存放另一个元素地址的指针(pointer)，用该指针来表示数据元素之间的逻辑结构(关系)。</p><p>例：设有数据集合A={3.0,2.3,5.0,-8.5,11.0} ，两种不同的存储结构。</p><p><strong>顺序结构：</strong>数据元素存放的地址是连续的；</p><p><strong>链式结构：</strong>数据元素存放的地址是否连续没有要求。</p><p>数据的逻辑结构和物理结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p><p>在C语言中，用一维数组表示顺序存储结构；用结构体类型表示链式存储结构。</p><hr><h4 id="数据结构的三个组成部分"><a href="#数据结构的三个组成部分" class="headerlink" title="数据结构的三个组成部分"></a>数据结构的三个组成部分</h4><p><strong>逻辑结构：</strong> 数据元素之间逻辑关系的描述：D_S=（D，S）</p><p><strong>存储结构：</strong> 数据元素在计算机中的存储及其逻辑关系的表现称为数据的存储结构或物理结构。</p><p><strong>数据操作：</strong> 对数据要进行的运算。</p><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>数据类型(Data Type)：</strong>指的是一个值的集合和定义在该值集上的一组操作的总称。</p><p>数据类型是和数据结构密切相关的一个概念。 在C语言中数据类型有：基本类型和构造类型。</p><p>数据结构不同于数据类型，也不同于数据对象，它不仅要描述数据类型的数据对象，而且要描述数据对象各元素之间的相互关系。</p><hr><h4 id="数据结构的运算"><a href="#数据结构的运算" class="headerlink" title="数据结构的运算"></a>数据结构的运算</h4><p>数据结构的主要运算包括：</p><p>⑴ 建立(Create)一个数据结构；</p><p>⑵ 消除(Destroy)一个数据结构；</p><p>⑶ 从一个数据结构中删除(Delete)一个数据元素；</p><p>⑷ 把一个数据元素插入(Insert)到一个数据结构中；</p><p>⑸ 对一个数据结构进行访问(Access)；</p><p>⑹ 对一个数据结构(中的数据元素)进行修改(Modify)；</p><p>⑺ 对一个数据结构进行排序(Sort)；</p><p>⑻ 对一个数据结构进行查找(Search)。</p><hr><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p><strong>抽象数据类型(Abstract Data Type ，简称ADT)</strong>：是指一个数学模型以及定义在该模型上的一组操作。</p><p>ADT的定义仅是一组逻辑特性描述， 与其在计算机内的表示和实现无关。因此，不论ADT的内部结构如何变化，只要其数学特性不变，都不影响其外部使用。</p><p><strong>ADT的形式化定义是三元组：ADT=(D，S，P)</strong></p><p>其中：D是数据对象，S是D上的关系集，P是对D的基本操作集。</p><blockquote><p>ADT的一般定义形式是：</p><p>ADT &lt;抽象数据类型名&gt;{<br>    数据对象： &lt;数据对象的定义&gt;<br>    数据关系： &lt;数据关系的定义&gt;<br>    基本操作： &lt;基本操作的定义&gt;<br>} ADT &lt;抽象数据类型名&gt;</p><p>其中数据对象和数据关系的定义用伪码描述。</p></blockquote><blockquote><p>基本操作的定义是：</p><p>&lt;基本操作名&gt;(&lt;参数表&gt;)<br>   初始条件： &lt;初始条件描述&gt;<br>   操作结果： &lt;操作结果描述&gt;</p><p>初始条件：描述操作执行之前数据结构和参数应满足的条件;若不满足，则操作失败，返回相应的出错信息。</p><p>操作结果：描述操作正常完成之后，数据结构的变化状况和 应返回的结果。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;四个基本概念&quot;&gt;&lt;a href=&quot;#四个基本概念&quot; class=&quot;headerlink&quot; title=&quot;四个基本概念&quot;&gt;&lt;/a&gt;四个基本概念&lt;/h4&gt;&lt;p&gt; &lt;strong&gt;数据(Data)&lt;/strong&gt; ：是客观事物的符号表示。在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据元素(Data Element)&lt;/strong&gt; ：是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。&lt;/p&gt;
&lt;p&gt;一个数据元素可由若干个数据项(Data Item)组成。数据项是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://maojunjie666.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://maojunjie666.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>埃氏筛法和欧式筛法</title>
    <link href="http://maojunjie666.top/2018/09/11/%E6%95%B0%E8%AE%BA/%E4%B8%A4%E7%A7%8D%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    <id>http://maojunjie666.top/2018/09/11/数论/两种质数筛法/</id>
    <published>2018-09-10T23:22:42.687Z</published>
    <updated>2018-09-11T07:29:05.426Z</updated>
    
    <content type="html"><![CDATA[<h4 id="埃氏筛法O（nlogn）"><a href="#埃氏筛法O（nlogn）" class="headerlink" title="埃氏筛法O（nlogn）"></a>埃氏筛法O（nlogn）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N+<span class="number">5</span>];</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(prime,prime+N,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">if</span>(prime[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*<span class="number">2</span>;j&lt;=N;j+=i)</span><br><span class="line">                prime[j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isprime();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(prime[i])</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="欧式筛法O（n）"><a href="#欧式筛法O（n）" class="headerlink" title="欧式筛法O（n）"></a>欧式筛法O（n）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">11000000</span>],primesize;</span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">11000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getlist</span><span class="params">(<span class="keyword">int</span> listsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</span><br><span class="line">    isprime[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=listsize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i])prime[++primesize]=i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=primesize&amp;&amp;i*prime[j]&lt;=listsize;j++)</span><br><span class="line">         &#123;</span><br><span class="line">            isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prime[]数组中的素数是递增的,当i(i为合数）能整除prime[j]，那么i*prime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。</p><p>因为i中含有prime[j],prime[j]比prime[j+1]小，即i=k<em>prime[j]，那么i</em>prime[j+1]=(k<em>prime[j])</em>prime</p><p>[j+1]=k’*prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0这个条件之前以及第一次</p><p>满足改条件时,prime[j]必定是prime[j]*i的最小因子。</p><p>比如i =6 ，i可以整除2，i也可以整除3，这个时候为了防止重复筛选，我们选取最小的质因子，去筛12。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;埃氏筛法O（nlogn）&quot;&gt;&lt;a href=&quot;#埃氏筛法O（nlogn）&quot; class=&quot;headerlink&quot; title=&quot;埃氏筛法O（nlogn）&quot;&gt;&lt;/a&gt;埃氏筛法O（nlogn）&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="数论" scheme="http://maojunjie666.top/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://maojunjie666.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="质数筛法" scheme="http://maojunjie666.top/tags/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>南阳oj68:判断三点位置</title>
    <link href="http://maojunjie666.top/2018/09/10/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E5%88%A4%E6%96%AD%E4%B8%89%E7%82%B9%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/"/>
    <id>http://maojunjie666.top/2018/09/10/计算几何/判断三点位置关系/</id>
    <published>2018-09-10T15:51:34.836Z</published>
    <updated>2018-09-10T15:55:47.977Z</updated>
    
    <content type="html"><![CDATA[<p>利用矢量叉积判断是逆时针还是顺时针。</p><p>设矢量P = ( x1, y1 )，Q = ( x2, y2 )，则矢量叉积定义为由(0,0)、p1、p2和p1+p2 所组成的平行四边形的带符号的面积，即：P × Q = x1*y2 - x2*y1，其结果是一个标量。</p><a id="more"></a><p>显然有性质 P × Q = - ( Q × P ) 和 P × ( - Q ) = - ( P × Q )。</p><p>叉积的一个非常重要性质是可以通过它的符号判断两矢量相互之间的顺逆时针关系：　　</p><p>若 P × Q &gt; 0 , 则P在Q的顺时针方向。　　</p><p>若 P × Q &lt; 0 , 则P在Q的逆时针方向。　　</p><p>若 P × Q = 0 , 则P与Q共线，但可能同向也可能反向。</p><p>解释：a×b=(ay <em> bz - by </em> az, az <em> bx - ax </em> bz, ax <em> by - ay </em> bx) 又因为az bz都为0，所以a×b=（0，0， ax <em> by - ay </em> bx）根据右手系（叉乘满足右手系），若 P × Q &gt; 0,ax <em> by - ay </em> bx&gt;0,也就是大拇指指向朝上，所以P在Q的顺时针方向，一下同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp =<span class="number">1e-6</span>; <span class="comment">//esp用于控制精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI =<span class="built_in">acos</span>(<span class="number">-1.0</span>); <span class="comment">//pi</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> x,<span class="keyword">double</span> y):x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span>+(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x+b.x,a.y+b.y);&#125;<span class="comment">//加</span></span><br><span class="line">Vector <span class="keyword">operator</span>-(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x-b.x,a.y-b.y);&#125;<span class="comment">//减</span></span><br><span class="line">Vector <span class="keyword">operator</span>*(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x*p,a.y*p);&#125;<span class="comment">//乘</span></span><br><span class="line">Vector <span class="keyword">operator</span>/(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x/p,a.y/p);&#125;<span class="comment">//除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125; <span class="comment">//外积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2,x3,y3;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x1&amp;&amp;!y1&amp;&amp;!x2&amp;&amp;!y2&amp;&amp;!x3&amp;&amp;!y3)<span class="keyword">break</span>;</span><br><span class="line">        Vector A(x1,y1),B(x2,y2),C(x3,y3);</span><br><span class="line">        Vector AB=B-A,AC=C-A;</span><br><span class="line">        <span class="keyword">int</span> flag=Cross(AB,AC);</span><br><span class="line">        <span class="keyword">if</span>(flag&lt;<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用矢量叉积判断是逆时针还是顺时针。&lt;/p&gt;
&lt;p&gt;设矢量P = ( x1, y1 )，Q = ( x2, y2 )，则矢量叉积定义为由(0,0)、p1、p2和p1+p2 所组成的平行四边形的带符号的面积，即：P × Q = x1*y2 - x2*y1，其结果是一个标量。&lt;/p&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://maojunjie666.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="计算几何" scheme="http://maojunjie666.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>康托展开和逆康托展开</title>
    <link href="http://maojunjie666.top/2018/09/10/%E6%95%B0%E8%AE%BA/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <id>http://maojunjie666.top/2018/09/10/数论/康托展开/</id>
    <published>2018-09-10T15:10:45.311Z</published>
    <updated>2018-09-10T15:32:15.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h4><p>这里主要为了讲解康托展开的思路，实现的算法复杂度为O(n^2)，实际当n很大时，内层循环计算在当前位之后小于当前位的个数可以用 <strong>线段树</strong>来处理计算，而不用每次都遍历，这样复杂度可以降为O(nlogn)。</p><a id="more"></a><p>在 <img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D79/sign=d9e56bf2d154564ee165e630b2de073a/b219ebc4b74543a91297ad2d12178a82b8011446.jpg" alt="img"> 5个数的排列组合中，计算 34152的康托展开值。</p><p>首位是3，则小于3的数有两个，为1和2， <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D57/sign=82f2c35a8bd6277fed12323f2a38b4fa/d1a20cf431adcbef73fa29e7a0af2edda2cc9f00.jpg" alt="img"> ，则首位小于3的所有排列组合为 <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D94/sign=db112176d533c895a27e947fd01340bb/0df3d7ca7bcb0a46262addd86763f6246a60afc3.jpg" alt="img"></p><p>第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此 <img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D57/sign=a5d1832f9525bc312f5d019f5fdf30a9/aa64034f78f0f73627e71ae00655b319ebc41331.jpg" alt="img"> 。</p><p>第三位是1，则在其之后小于1的数有0个，所以 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D57/sign=77db5956e550352ab561250f5243cbad/d0c8a786c9177f3e2a21aaec7ccf3bc79f3d563d.jpg" alt="img"> 。</p><p>第四位是5，则在其之后小于5的数有1个，为2，所以 <img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D55/sign=882208b2fa246b607f0eb271eaf8e2ac/dc54564e9258d10985f5ff53dd58ccbf6c814d38.jpg" alt="img"> 。</p><p>最后一位就不用计算啦，因为在它之后已经没有数了，所以 <img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D29/sign=4327609e74f0f736dcfe4b080b555348/359b033b5bb5c9eafd8d5502d939b6003bf3b3d1.jpg" alt="img"> 固定为0</p><p>根据公式：</p><p><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D322/sign=f917ca3d8613632711edc431a38da056/359b033b5bb5c9eafd065502d939b6003bf3b35e.jpg" alt="img"> </p><p>　　所以比34152小的组合有61个，即34152是排第62。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//康托展开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[] =&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> smaller =<span class="number">0</span> ;  <span class="comment">//在当前位之后小于其的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])smaller++;</span><br><span class="line">        &#125;</span><br><span class="line">        x+=arr[n-i<span class="number">-1</span>]*smaller; <span class="comment">//因为从0开始数，所以要多减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//康托展开值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m []=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cantor(m,<span class="number">5</span>)+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//比34152小的组合有61个，所以34152排第62个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h4><p>（根据排第几推出当前序列）</p><p>一开始已经提过了，康托展开是一个全排列到一个自然数的<strong>双射</strong>，因此是可逆的。即对于上述例子，在（1，2，3，4，5）给出61可以算出起排列组合为 34152。由上述的计算过程可以容易的逆推回来，具体过程如下：</p><ul><li>用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。</li><li>用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。</li><li>用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。</li><li>用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。</li><li>最后一位自然就是剩下的数2啦。</li><li>通过以上分析，所求排列组合为 34152。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[] =&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decantor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v; <span class="comment">//存放当前可选数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a; <span class="comment">//所求排列组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)v.pb(i);  <span class="comment">//因为这里是12345，如果不是，可能需要更改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> r =x%arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> t =x/arr[i<span class="number">-1</span>];</span><br><span class="line">        x=r;</span><br><span class="line">        sort(v.begin(),v.end());</span><br><span class="line">        a.pb(v[t]);</span><br><span class="line">        v.erase(v.begin()+t); <span class="comment">//移出选做当前位的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)<span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    decantor(<span class="number">61</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="康托展开的应用"><a href="#康托展开的应用" class="headerlink" title="康托展开的应用"></a>康托展开的应用</h4><p>应用最多的场景也是上述讲的它的特性。</p><ul><li>给定一个自然数集合组合一个全排列，所其中的一个排列组合在全排列中从大到小排第几位。<br>在上述例子中，在（1，2，3，4，5）的全排列中，34152的排列组合排在第62位。</li><li>反过来，就是逆康托展开，求在一个全排列中，第n个全排列是多少。<br>比如求在（1，2，3，4，5）的全排列中，第62个排列组合是34152。[注意具体计算中，要先 -1 才是其康托展开的值。]</li><li>另外康托展开也是一个数组到一个数的映射，因此也是可用于hash，用于空间压缩。比如在保存一个序列，我们可能需要开一个数组，如果能够把它映射成一个自然数， 则只需要保存一个整数，大大压缩空间。比如八数码问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;康托展开&quot;&gt;&lt;a href=&quot;#康托展开&quot; class=&quot;headerlink&quot; title=&quot;康托展开&quot;&gt;&lt;/a&gt;康托展开&lt;/h4&gt;&lt;p&gt;这里主要为了讲解康托展开的思路，实现的算法复杂度为O(n^2)，实际当n很大时，内层循环计算在当前位之后小于当前位的个数可以用 &lt;strong&gt;线段树&lt;/strong&gt;来处理计算，而不用每次都遍历，这样复杂度可以降为O(nlogn)。&lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="http://maojunjie666.top/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://maojunjie666.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="康托展开" scheme="http://maojunjie666.top/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>计算几何----向量基本运算模板</title>
    <link href="http://maojunjie666.top/2018/09/10/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/"/>
    <id>http://maojunjie666.top/2018/09/10/计算几何/向量运算/</id>
    <published>2018-09-10T06:43:43.820Z</published>
    <updated>2018-09-10T15:59:41.479Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章内容包含了向量的基本运算，如加减乘除，点乘，叉乘，逆时针旋转，求模，判断两个向量是否相等，</p><p>两个点之间的距离，还有利用外积求三角形面积等等。</p><a id="more"></a><p><strong>向量：</strong></p><p>v1=(x1,y1) ，v2=(x2,y2)</p><hr><p><strong>向量的加减与数乘：</strong></p><p>v1 ± v2=（ x1 ± x2 , y1 ± y2 )</p><hr><p><strong>内积：</strong></p><p>v1 · v2 =|v1|·|v2|cos&lt;v1,v2&gt; = x1x2 + y1y2</p><hr><p><strong>外积：</strong></p><p>|v1×v2| = |v1|·|v2|sin&lt;v1,v2&gt;</p><p>（注：在数字上并无二维向量外积的定义，但我们常将下图操作定义为二维向量的外积：</p><p><img src="https://i.loli.net/2018/09/10/5b96127c83a14.png" alt="2.png"></p><p>且有如下性质：</p><p>(1) 顺时针为负，逆时针为正</p><p>(2) v1||v2  ⇔  v1 × v2  = 0</p><p>(3) 外积的几何意义为平行四边形的有向面积。</p><hr><p><strong>向量旋转公式：</strong></p><p>x‘ = xcosθ - ysinθ</p><p>y’ = xsinθ + ycosθ</p><hr><h4 id="基本向量运算模板"><a href="#基本向量运算模板" class="headerlink" title="基本向量运算模板"></a>基本向量运算模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp =<span class="number">1e-6</span>; <span class="comment">//esp用于控制精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI =<span class="built_in">acos</span>(<span class="number">-1.0</span>); <span class="comment">//pi</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> x,<span class="keyword">double</span> y):x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span>+(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x+b.x,a.y+b.y);&#125;<span class="comment">//加</span></span><br><span class="line">Vector <span class="keyword">operator</span>-(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x-b.x,a.y-b.y);&#125;<span class="comment">//减</span></span><br><span class="line">Vector <span class="keyword">operator</span>*(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x*p,a.y*p);&#125;<span class="comment">//乘</span></span><br><span class="line">Vector <span class="keyword">operator</span>/(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x/p,a.y/p);&#125;<span class="comment">//除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  <span class="comment">//精度三态函数(&gt;0,&lt;0,=0)，判断这个值与0的关系</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;esp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)  <span class="comment">//判断向量是否相等</span></span><br><span class="line">&#123;<span class="keyword">return</span> dcmp(a.x-b.x)==<span class="number">0</span> &amp;&amp; dcmp(a.y-b.y)==<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y;&#125;  <span class="comment">//点积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(a,a));&#125; <span class="comment">//模</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(Dot(a,b)/Length(a)/Length(b));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125; <span class="comment">//外积</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector a,<span class="keyword">double</span> rad)</span>  <span class="comment">//逆时针旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> Vector(a.x*<span class="built_in">cos</span>(rad)-a.y*<span class="built_in">sin</span>(rad),a.x*<span class="built_in">sin</span>(rad)+a.y*<span class="built_in">cos</span>(rad));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125; <span class="comment">//两点间距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(b-a,c-a)/<span class="number">2</span>);&#125; <span class="comment">//三角形面积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">b</span><span class="params">(<span class="number">6</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    Vector c;</span><br><span class="line">    c=a*<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c.x&lt;&lt;<span class="string">" "</span>&lt;&lt;c.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Area(a,b,c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章内容包含了向量的基本运算，如加减乘除，点乘，叉乘，逆时针旋转，求模，判断两个向量是否相等，&lt;/p&gt;
&lt;p&gt;两个点之间的距离，还有利用外积求三角形面积等等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://maojunjie666.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="计算几何" scheme="http://maojunjie666.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part4)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B48%E6%9C%882%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年8月2日/</id>
    <published>2018-09-08T15:13:32.877Z</published>
    <updated>2018-09-09T02:54:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>内容：继承中方法的关系、方法的重写、重写和重载的区别、final关键字、final修饰的变量初始化的时机、多态、多态中的向上和向下转型、</p><p>多态的优缺点、instanceof关键字</p><hr><h4 id="继承中方法的关系"><a href="#继承中方法的关系" class="headerlink" title="继承中方法的关系"></a>继承中方法的关系</h4><p>1.同名方法:</p><p>同名方法会被子类的方法所覆盖，这种也被称为重写。<br><a id="more"></a><br>可以使用super.方法名（参数）来调用父类方法。</p><p>2.不同名方法：</p><p>不同名方法子类可以调用父类的非私有方法</p><hr><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>重写：子父类出现了一模一样的方法，特别的(返回值类型可以是字符类)，暂时先认为返回值也相同。</p><p>方法重写的应用：</p><p>当子类需要父类的功能时，而功能主题子类有自己的内容时，可以重写父类的方法，这样既沿袭了父类的功能，又定义了子类的内容。</p><p><strong>注：父类中，私有的方法是不能被重写的。</strong></p><p>子类重写父类方法时，访问的权限不能更低。 public&gt;protected&gt;defaulat&gt;private</p><p>父类的静态方法，子类必须通过静态方法进行重写。其实这个算不上方法重写（以后会学到）</p><p>子类重写父类方法时，最好声明的一模一样。</p><hr><h4 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h4><p>override和overload中，overload可以改变返回值类型</p><p>override：子父类出现了一模一样的方法，与返回值类型有关，返回值是一致（或者是子父类）的</p><p>overload：本类中出现的方法名一样，参数列表不同的方法，与返回值类型无关。</p><p>子类对象调用方法的时候：先找子类本身，再找父类。</p><hr><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final关键字修饰的特点：</p><p>*修饰类后，类就不能被继承</p><p>*修饰变量，变量就变成了常量，只能被赋值一次</p><p>*修饰方法，方法就不能被重写</p><p>如果想一个类里面的所有方法都不被重写，那就在类名前加一个final</p><p>java自带的String类就是final类，其他类的可以查看java API文档。</p><p>一般修饰常量和public static 一起共用，比如：public static final double PI  = 3.1415926；</p><p>final关键字修饰局部变量：</p><p>基本类型，修饰后是值不能改变</p><p>引用类型，是地址值不能被改变，对象中的属性可以改变。</p><hr><h4 id="final修饰的变量初始化的时机"><a href="#final修饰的变量初始化的时机" class="headerlink" title="final修饰的变量初始化的时机"></a>final修饰的变量初始化的时机</h4><p>final修饰的成员变量不会被编译器初始化的，因为它帮你初始化是无意义的，需要进行显式初始化。</p><p>final在构造完成之前显式初始化即可。如下列代码，是在构造方法中完成的显示初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num；</span><br><span class="line">    <span class="comment">//num = 10;  放在此处也可以，但必须放在第一个构造方法之前或第一个构造方法之中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：事物存在的多种形态</p><p>多态的前提：</p><p>1.要有继承关系</p><p>2.要有方法重写</p><p>3.要有父类引用指向子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coding;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"动物吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();  <span class="comment">//父类引用指向子类</span></span><br><span class="line">a.eat();</span><br><span class="line">System.out.println(a.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态中成员访问特点"><a href="#多态中成员访问特点" class="headerlink" title="多态中成员访问特点"></a>多态中成员访问特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>如上述代码，最终输出的num是父类的num，而不是子类的num</p><p>技巧：编译看左边（父类），运行看左边（父类）</p><p>在编译器编译的过程中，虽然调用了子类的构造方法，子类同时也会调用父类的构造方法，将子类和父类的变量划分区域，因为左边是父类的类型名，所以，最后返回的引用（地址）指向的是父类的那一块内存，而不是子类的那一块。</p><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>技巧：编译看左边（父类），运行看右边（子类）。(动态绑定）</p><p>（静态和类相关，算不上重写，所以，访问的还是左边的，只有非静态的成员方法满足上述技巧）</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如果子类中存在父类没有的变量或者方法，如果没有调用的话，编译是不会出错的，比如子类有一个叫num的变量或者方法，父类没有，只要下面的代码不去调用这个变量或者方法，编译器是不会去报错的。</p><p>如果子类中没有父类的方法，比如父类中有一个叫show的方法，编译的时候因为看左边不会出错，调用的时候，虽然子类没有，但是相当于子类把父类的show方法继承了下来，所以仍然不会报错。</p><p>题目一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">zi</span> <span class="keyword">extends</span> <span class="title">fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 =<span class="number">10</span>;    <span class="comment">//不调用就不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   <span class="comment">//子类有，父类没有，子类只要不调用就不会报错</span></span><br><span class="line">System.out.println(<span class="string">"method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">fu f = <span class="keyword">new</span> zi();</span><br><span class="line"><span class="comment">//f.method();  //子类有，父类没有，不调用就不会报错</span></span><br><span class="line">f.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目二：输出zi<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();   <span class="comment">//show方法相当与继承了父类，因为运行看右边，所以运行子类的show2方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目三：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();   <span class="comment">//虽然调用了父类的show方法，但是还是会运行子类的show方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="多态中的向上和向下转型"><a href="#多态中的向上和向下转型" class="headerlink" title="多态中的向上和向下转型"></a>多态中的向上和向下转型</h4><p>父类引用指向子类对象就是向上转型(子类提升为父类）</p><p>Fater a = new Son();</p><p>Son s = (Son)a;  //向下转型，这样，s能看到整个对象，而a只能看到父类的那一块内存。</p><hr><h4 id="多态的优缺点"><a href="#多态的优缺点" class="headerlink" title="多态的优缺点"></a>多态的优缺点</h4><p><strong>多态的优点：</strong></p><p>1.提高了代码的维护性（继承保证）</p><p>2.提高了代码的扩展性（多态保证）</p><p>3.可以当做形式参数，接受任意子类对象。</p><hr><p><strong>多态的缺点：</strong></p><p>不能使用子类的特有属性和行为，必须通过向下转型才能使用。</p><p>开发的时候是很少在创建对象的时候父类引用指向子类对象，直接创建子类。</p><p><strong>总结：</strong><br>当参数的时候使用多态更好，因为增强了方法的扩展性。</p><hr><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>用法：</p><p>引用名  instanceof  数据类型</p><p>判断前面的引用是否是后面的数据类型。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：继承中方法的关系、方法的重写、重写和重载的区别、final关键字、final修饰的变量初始化的时机、多态、多态中的向上和向下转型、&lt;/p&gt;
&lt;p&gt;多态的优缺点、instanceof关键字&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;继承中方法的关系&quot;&gt;&lt;a href=&quot;#继承中方法的关系&quot; class=&quot;headerlink&quot; title=&quot;继承中方法的关系&quot;&gt;&lt;/a&gt;继承中方法的关系&lt;/h4&gt;&lt;p&gt;1.同名方法:&lt;/p&gt;
&lt;p&gt;同名方法会被子类的方法所覆盖，这种也被称为重写。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part3)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B48%E6%9C%881%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年8月1日/</id>
    <published>2018-09-08T15:13:32.862Z</published>
    <updated>2018-09-09T02:54:28.316Z</updated>
    
    <content type="html"><![CDATA[<p>内容：继承的基本概念、继承的注意事项、继承中成员变量的关系、this和super关键字、继承中构造方法的关系及注意、</p><p>java的代码块、构造函数与静态代码块、构造代码块的作用</p><hr><h4 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h4><p>java中支持单继承，继承能提高代码的复用性，但同时也增加了类的耦合性，这个耦合性有利有弊，比如修改最上层类时，它下层的类也会随之改变，但是也有利于维护代码。<br><a id="more"></a><br><strong>注：继承体现的是一种关系。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoA</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoB</span> <span class="keyword">extends</span> <span class="title">DemoA</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Democ</span> <span class="keyword">extends</span> <span class="title">DemoB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoC"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想用这个继承体系的所有功能，使用最底层的类创建对象。如DemoC。<br>如果想看这个体系中的共性功能，使用最顶层的类创建对象。如DemoA。</p><hr><h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4><p>1.子类只能继承父类所有非私有成员（成员方法和成员变量）</p><p>2.子类不能继承父类的构造方法，因为构造方法名与类名是一样的。但可以通过super关键字去访问父类的构造方法。</p><p>3.一个类不写extends语句，默认基础object超类。</p><p>4.不要为了部分功能而去继承：例如：</p><p>项目经理：姓名 工号 工资 奖金</p><p>程序员  ：姓名 工号 工资</p><p>这个时候，不应该项目经理去继承程序员，也不应该让程序员去继承项目经理，（项目经理一去公司就管程序员叫爹的吗23333）<br>应该抽象出一个员工类，让项目经理和程序员同时去继承他们。苹果也不应该去继承香蕉，应该抽象出水果类，让他们俩同时继承水果类。</p><p><strong>判断方法：假设法，假设A是B或者B是A的一种，那么这个时候就可以考虑使用继承了。</strong></p><hr><h4 id="继承中成员变量的关系"><a href="#继承中成员变量的关系" class="headerlink" title="继承中成员变量的关系"></a>继承中成员变量的关系</h4><p>1.不同名的变量：子类直接使用父类变量的值。<br>2.同名的变量：子类和父类同名时，就近原则，使用子类的变量。</p><p>但是在开发过程中，不会出现这种情况，子类继承父类就是为了使用父类的成员，既然存在了，子类就没必要再定义了。</p><hr><h4 id="this和super关键字"><a href="#this和super关键字" class="headerlink" title="this和super关键字"></a>this和super关键字</h4><p>this：代表当前对象的引用，谁来调用我，我就代表谁。<br>super：代表当前对象父类的引用。</p><p>this和super的使用区别：<br>this.成员变量 : 既可以调用本类的成员变量，也可以调用父类的成员变量(前提是本类没有重名的变量）。</p><p>super.成员变量  :只能调用父类的成员变量。</p><hr><h4 id="继承中构造方法的关系"><a href="#继承中构造方法的关系" class="headerlink" title="继承中构造方法的关系"></a>继承中构造方法的关系</h4><p><strong>子类所以的构造方法默认都会访问父类中空参构造方法。</strong>为什么呢？因为子类会继承父类中的数据，可能还会使用父类的数据</p><p>所以，子类完成初始化之前，一定要完成父类数据的初始化。</p><p>其实，每一个构造方法的第一条语句默认都是：super() 。</p><p><strong>如果某一个类不写extends语句，默认基础Object类，它是最顶层的父类。</strong></p><hr><h4 id="继承中构造方法的注意"><a href="#继承中构造方法的注意" class="headerlink" title="继承中构造方法的注意"></a>继承中构造方法的注意</h4><p>1.父类中没有空参构造方法怎么办？<br>在子类中的所有构造函数中第一句声明，super(参数),其中参数为父类的构造函数的参数。</p><p>2.子类的无参构造函数要调用父类中的有参构造函数。<br>法一：super(参数）<br>法二：在子类的无参构造函数中加上：this(参数），这样访问的是子类的有参构造函数，而子类的有参构造中如果含有super（参数）语句，则相当于间接调用了父类的有参构造函数。</p><p><strong>注：对super的调用必须是构造函数的第一句，不用同时出现this和super语句。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">System.out.println(<span class="string">"父类有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//super(5);直接调用父类有参构造</span></span><br><span class="line"><span class="keyword">this</span>(<span class="number">5</span>);  <span class="comment">//访问Son的有参构造，间接调用父类有参构造</span></span><br><span class="line">System.out.println(<span class="string">"子类无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(num);</span><br><span class="line">System.out.println(<span class="string">"子类有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="java的代码块"><a href="#java的代码块" class="headerlink" title="java的代码块"></a>java的代码块</h4><p><strong>普通代码块</strong>：就是在方法后面使用”{}”括起来的代码片段,不能单独执行,必须调下其方法名才可以执行.</p><p><strong>静态代码块</strong>：在类中使用static修饰,并使用”{}”括起来的代码片段,用于静态变量的初始化或对象创建前的环境初始化.</p><p><strong>同步代码块</strong>：使用synchronize关键字修饰,并使用”{}”括起来的代码片段.它表示在同一时间只能有一个线程进入到该方法快中,是一种多线程保护机制.</p><p><strong>构造代码块</strong>：在类中没与任何的前缀或后缀,并使用”{}”括起来的代码片段.</p><hr><h4 id="构造函数与静态代码块"><a href="#构造函数与静态代码块" class="headerlink" title="构造函数与静态代码块"></a>构造函数与静态代码块</h4><p>当main函数入栈时，fater.class和son.class被加载进内容，static代码块随他们一起进入内存，所以先输出：父类静态代码块，子类静态代码块<br>当创建子类对象时，父类先完成初始化，所以先输出父类构造代码块，父类构造方法，然后初始化子类，输出子类构造代码块，子类构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"父类静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"父类构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"子类静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"子类构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="构造代码块的作用"><a href="#构造代码块的作用" class="headerlink" title="构造代码块的作用"></a>构造代码块的作用</h4><p><strong>1.初始化实例变量</strong></p><p>如果每个构造函数都需要初始化变量,即可通过构造代码块来实现.从而取代在每个构造函数调用初始化实例变量的方法.</p><p><strong>2.初始化实例环境</strong></p><p>一个对象必须在适当的场景下才能存在,如果没有适当的场景,则就需要在创建对象的时候创建此场景.</p><p>①编译器会把构造代码块插入到每个构造函数的最前端</p><p>②由于是插入到构造函数的的前面,自然在通过new关键字生成一个实例的时候会先执行构造代码块,然后在执行其他代码(注意:构造代码块不是在构造函数之前运行,而是依托于构造函数)</p><p>③在每个构造函数中都运行。</p><p>应用，计数器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">new</span> Client(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Client(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(Client.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码最终会输出3。</p><p>显然Java编译器是足够聪明的.这是因为,在插入到每个构造函数中的时候,有个例外,就是如果遇到this关键字(也就是构造函数调用自身其他的构造函数时)不插入构造代码块.</p><p>那为什么编译器这么聪明呢?这是因为构造代码块的出现就是为了提取构造函数的共同量,减少各个构造函数的代码而产生的。</p><p><strong>总结：</strong><br>灵活适当的使用构造代码块会让你的代码更加的简约和清晰.代码的质量自然很高很多,逼格也高了许多,有没有.</p><p><strong>最后还有一点需要注意的,千万不要认为this是特殊情况,那super也会类似处理.其实不会,在构造代码块的处理上,super方法没有任何特殊的地方.编译器只是把构造代码块插入到super方法之后执行而已.</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：继承的基本概念、继承的注意事项、继承中成员变量的关系、this和super关键字、继承中构造方法的关系及注意、&lt;/p&gt;
&lt;p&gt;java的代码块、构造函数与静态代码块、构造代码块的作用&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;继承的基本概念&quot;&gt;&lt;a href=&quot;#继承的基本概念&quot; class=&quot;headerlink&quot; title=&quot;继承的基本概念&quot;&gt;&lt;/a&gt;继承的基本概念&lt;/h4&gt;&lt;p&gt;java中支持单继承，继承能提高代码的复用性，但同时也增加了类的耦合性，这个耦合性有利有弊，比如修改最上层类时，它下层的类也会随之改变，但是也有利于维护代码。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part2)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B47%E6%9C%8830%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年7月30日/</id>
    <published>2018-09-08T15:13:32.860Z</published>
    <updated>2018-09-09T02:54:17.598Z</updated>
    
    <content type="html"><![CDATA[<p>内容：包的概念、Scanner类闭合的意义、ArrayList的用法、类或变量与public关键字、四个关键字的访问范围</p><hr><h4 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h4><p>package是在使用多个类或接口时，为了避免名称重复而采用的一种措施，直接在程序中加入package关键字即可。</p><p>Java中提供的包主要有以下3种用途:</p><p>  1) 将功能相近的类放在同一个包中，可以方便查找与使用。<br><a id="more"></a><br>  2) 由于在不同包中可以存在同名类，所以使用包在一定程度上可以避免命名冲突。</p><p>  3) 在Java中，某次访问权限是以包为单位的。</p><p>一个包中可以包含一个或多个类。</p><hr><p>下述是在java文件中指定一个包名：</p><p>package net.com.cn</p><p>“.”号的意义：点号可以看做是\号。</p><p>package net.com.cn，这时它就会生成多级文件夹，先生成net文件夹，然后在net文件夹中生成com文件夹，最后在com文件夹中生成cn文件夹<br>，我们编译生成的.class 文件就会放到cn 文件夹中。</p><p><strong>总结：</strong><br>包不仅方便管理类，还创造出了命名空间，这样就错开相同名称的类，几个程序员都设计出了某个同名类，我们可以通过包来区分，最后，包可以通过限制同一包之间的类才能相互存取以维护安全性。</p><hr><h4 id="Scanner类的闭合"><a href="#Scanner类的闭合" class="headerlink" title="Scanner类的闭合"></a>Scanner类的闭合</h4><p>close方法的作用是关闭输入的流，释放内存。属于IO流的类如果不关闭会一直占用资源。</p><hr><h4 id="AarryList的用法"><a href="#AarryList的用法" class="headerlink" title="AarryList的用法"></a>AarryList的用法</h4><p>AarryList是一个动态扩容的升级版数组，它只能存储对象，而不能存储primitive主数据类型。</p><p>调用包：import java.util.AarryList;</p><hr><p>基本操作：<br>①定义:</p><p>AarryList<object name=""> mylist = new AarryList<object name="">();</object></object></p><p>②加入元素：</p><p>mylist.add(object);</p><p>③查询容量:</p><p>mylist.size();</p><p>④查询特定元素:</p><p>myList.contains(object);  //查到返回true，否则返回false;</p><p>⑤查询特定元素位置:</p><p>mylist.indexOf(object); //未查询到返回-1</p><p>⑤判断集合是否为空:</p><p>mylist.isEmpty();</p><p>⑥删除元素：</p><p>mylist.remove(object or index); //可输入对象名或者对象的下标</p><p>⑦得到特定索引的对象：<br>mylist.get(index)； //返回对象的引用</p><hr><h4 id="public关键字"><a href="#public关键字" class="headerlink" title="public关键字"></a>public关键字</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>1.在一个文件中,有且只能有一个public类,该类与文件同名</p><p>2.在一个文件中,可以不存在public类</p><p>3.在一个文件中,可以不存在与文件同名的类(前提是此文件中没有public类)</p><p><strong>简而言之(一个java文件中只能有一个主类，一个主类必须与java文件名相同）</strong></p><p><strong>如果加上public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。</strong></p><p><strong>如果不加public,则默认的修饰词是default ,代表只对同包开放。</strong></p><hr><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>由public修饰的变量称为公共变量，可被任何包中的任何类访问。不带public等关键字默认为default 。</p><p>由protected修饰的变量称为受保护变量，可被声明它的类和派生的子类以及同一个包中的类访问。</p><hr><h4 id="四个关键字的访问范围"><a href="#四个关键字的访问范围" class="headerlink" title="四个关键字的访问范围"></a>四个关键字的访问范围</h4><p><img src="_v_images/_范围_1532946522_12676.png" alt="范围"></p><p>public：</p><p>具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。</p><p>protected：</p><p>主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。</p><p>default：</p><p>有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。</p><p>private：</p><p>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。</p><p><strong>总结：</strong><br>private关键字:只能在本类访问</p><p>default关键字：只能在本类或者同一个包下的类（子类和无关类）访问</p><p>protected关键字：本类、同一个包下的（子类和无关类）、不同包下的子类访问</p><p>public 关键字:所有包都能访问</p><hr><p>注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。</p><p><strong>区别：</strong></p><p>public：可以被所有其他类所访问</p><p>private：只能被自己访问和修改</p><p>protected：自身、子类及同一个包中类可以访问</p><p>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p><p><strong>注意：</strong><br>1、能够访问标为public protected的成员变量和方法；</p><p>2、如果子类与父类在同一包内，还能访问默认（无修饰符）的成员变量与方法。</p><p>3、不能访问标为private的成员。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：包的概念、Scanner类闭合的意义、ArrayList的用法、类或变量与public关键字、四个关键字的访问范围&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;包的概念&quot;&gt;&lt;a href=&quot;#包的概念&quot; class=&quot;headerlink&quot; title=&quot;包的概念&quot;&gt;&lt;/a&gt;包的概念&lt;/h4&gt;&lt;p&gt;package是在使用多个类或接口时，为了避免名称重复而采用的一种措施，直接在程序中加入package关键字即可。&lt;/p&gt;
&lt;p&gt;Java中提供的包主要有以下3种用途:&lt;/p&gt;
&lt;p&gt;  1) 将功能相近的类放在同一个包中，可以方便查找与使用。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part1)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B47%E6%9C%8827%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年7月27日/</id>
    <published>2018-09-08T15:13:32.824Z</published>
    <updated>2018-09-08T15:19:44.298Z</updated>
    
    <content type="html"><![CDATA[<p>内容：lang包、java的变量赋值、jshell的使用、java编译器的优化、赋值的下划线、java变量的初始值、java中的相等、java中的五个内存区</p><hr><h4 id="java的lang包"><a href="#java的lang包" class="headerlink" title="java的lang包"></a>java的lang包</h4><p>在编译过程中，编译器会自动帮你引入lang包，输出语句就在这个包中。<br>java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图：<br><a id="more"></a><br><img src="https://i.loli.net/2018/09/08/5b93e6b73822e.png" alt="_lang包_1532947499_9626.png"></p><hr><h4 id="java的变量赋值"><a href="#java的变量赋值" class="headerlink" title="java的变量赋值"></a>java的变量赋值</h4><p>java中为布尔类型定义了一种叫boolean类型，它只有两种取值，true和false，跟C语言不一样，java中的数字不能作为布尔值。<br>除了boolean类型，其他七种基本类型，byte/short/char/int/long/float/double，都是互相兼容的。</p><p>1.在java中，小类型可以赋值给大类型，而大类型只有通过强制类型转换才能赋值给小类型。</p><p>2.在java中，如果浮点数后面不带f，默认是double类型的，如果float =5.6；这样会报错，大类型不能直接赋值给小类型。</p><p>byte b =5;</p><p>short s =b;  //允许</p><p>byte b1 =s; //不允许</p><p>byte b1 =(byte)s; //允许，使用了强制类型转换</p><p>3.在java中，浮点数必须通过强制类型转换才能赋值给整型<br>int a =5.6;  //报错，编译器提示：这样做会损失精度<br>int a =(int)5.6;  //允许，使用了强制类型转换。</p><hr><h4 id="jshell的使用"><a href="#jshell的使用" class="headerlink" title="jshell的使用"></a>jshell的使用</h4><p>jdk9以上版本提供了一个jshell工具，这个类似python的IDLE这个shell，运行短代码时，无需写出全部代码，只需写出其中一句即可。</p><p>使用方法：在cmd中输入jshell，回车即可，如果要退出，输入:/exit 即可退出jshell并返回到cmd窗口。</p><hr><h4 id="java编译器的优化（常量优化）"><a href="#java编译器的优化（常量优化）" class="headerlink" title="java编译器的优化（常量优化）"></a>java编译器的优化（常量优化）</h4><p>对于btye、short、char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个<br>(btye)(short)(char)强制类型转换。</p><p>1.如果右侧没有超过左侧范围，则强制转换。</p><p>2.如果右侧超过了左侧范围，则编译过程直接报错。</p><p>3.特殊情况，如果右侧存在变量，这个运算情况编译器不会优化。</p><p>4.在给变量赋值的时候，如果右侧表达式中全为常量，没有任何变量，那么编译器javac将会直接将若干个表达式得到结果，如以下情况：<br>short result = 5 + 8；    这个5+8会直接得到结果，而不用在编译器后运算，这样13会被强制类型转换，不会报错，而如果右侧存在一个或以上的变量，那么编译器会直接报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//short + short ---&gt;int+int--&gt;int</span></span><br><span class="line"><span class="keyword">short</span> result = a + b;  <span class="comment">//报错，左侧需要int类型</span></span><br><span class="line"><span class="keyword">short</span> result1 = <span class="number">5</span> + <span class="number">8</span>; <span class="comment">//不会报错，javac会进行优化</span></span><br></pre></td></tr></table></figure><hr><h4 id="赋值的下划线"><a href="#赋值的下划线" class="headerlink" title="赋值的下划线"></a>赋值的下划线</h4><p>在java中，提供了一个”_“符号，来分隔较长变量，提高了程序的可读性，”_“这个符号类似注释，在编译过程中会被去掉，且这个符号除了数字的开头和末尾不能出现，其余地方都可以出现。</p><p>int a =123_456_789;</p><p>double a = 123.456_678_789;</p><hr><h4 id="java变量的初始值"><a href="#java变量的初始值" class="headerlink" title="java变量的初始值"></a>java变量的初始值</h4><p>在java中，实例变量的初始值默认是0或者null，而局部变量不一样，局部变量如果没有初始值，是不能直接去使用的。<br>局部变量：定义在方法中的变量。<br>实例变量：定义在类中的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> m =x+n;</span><br></pre></td></tr></table></figure><p>上述代码中的x和n就是局部变量，而n不给其赋初始值也不会报错，因为n是一个参数，不给func函数对应的参数编译器在这之前就会报错，所以n不用给其赋初值，而x，未经初始化直接使用编译器是回报错的。</p><hr><h4 id="java中的相等"><a href="#java中的相等" class="headerlink" title="java中的相等"></a>java中的相等</h4><p>在java中的主数据类型里，可以直接用”==”号判断两个变量是否相等，双等号是判断两个变量是否具有相同的字节组合。</p><p><strong>但：用”==”号，只能判断两个引用变量是否指向同一个对象。</strong></p><p>如果要判断两个引用变量真正意义上的相等，那就需要使用equal()方法了。</p><hr><h4 id="java的五个内存区"><a href="#java的五个内存区" class="headerlink" title="java的五个内存区"></a>java的五个内存区</h4><p>①栈(stack):存放的都是方法中的局部变量。</p><p>局部变量：方法的参数，或者是方法{}内部的变量</p><p>作用域：一旦超出作用域，立刻从栈内存当中消失。</p><hr><p>②堆(Heap)：凡是new出来的东西，都在堆当中。</p><p>堆内存里面的东西都要一个地址值，16进制</p><p>堆内存里面的数据，都有一个默认值，规则：</p><p>如果是整数：默认为0</p><p>如果是浮点数：默认为0.0</p><p>如果是字符：默认为’\u000’</p><p>如果是布尔值：默认为false</p><p>如果是引用类型：默认为null</p><hr><p>③方法区(Method Area)：存储.class相关信息，包含方法的信息。</p><hr><p>④本地方法栈(Native Method Stack)：与操作系统相关。</p><hr><p>⑤寄存器（pc Register）：与CPU相关</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：lang包、java的变量赋值、jshell的使用、java编译器的优化、赋值的下划线、java变量的初始值、java中的相等、java中的五个内存区&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;java的lang包&quot;&gt;&lt;a href=&quot;#java的lang包&quot; class=&quot;headerlink&quot; title=&quot;java的lang包&quot;&gt;&lt;/a&gt;java的lang包&lt;/h4&gt;&lt;p&gt;在编译过程中，编译器会自动帮你引入lang包，输出语句就在这个包中。&lt;br&gt;java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 2 A题：Winner</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR2-A%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR2-A题/</id>
    <published>2018-09-08T03:06:33.000Z</published>
    <updated>2018-09-08T15:19:10.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/2/problem/A" target="_blank" rel="noopener">题目传送门</a></p><p>这道题我开始准备使用map+stable_sort来做，但是无论是map或是unorder_map，都会改变输入的顺序，导致某一组答案错误。</p><p>所以我们可以使用map来进行纯模拟的操作。</p><p>首先，在输入的同时把最终各个人的分数加起来，然后找到最大值。</p><p>其次，再次模拟一遍游戏，当找到第一个达到m且最终的分数也大于等于m的人，输出即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;P;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp,mmp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close();</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    rep(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;m;</span><br><span class="line">        v1.pb(s);v2.pb(m);</span><br><span class="line">        mp[s]+=m;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:mp) m=max(m,x.second);  <span class="comment">//求最大值</span></span><br><span class="line"></span><br><span class="line">    rep(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        mmp[v1[i]]+=v2[i];</span><br><span class="line">        <span class="keyword">if</span>(mmp[v1[i]]&gt;=m&amp;&amp;mp[v1[i]]&gt;=m)&#123; <span class="comment">//在最终分数是最大的人，且率先达到最高分数</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/2/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这道题我开始准备使用map+stable_sort来做，但是无论是map或是unorder_map，都会改变输入的顺序，导致某一组答案错误。&lt;/p&gt;
&lt;p&gt;所以我们可以使用map来进行纯模拟的操作。&lt;/p&gt;
&lt;p&gt;首先，在输入的同时把最终各个人的分数加起来，然后找到最大值。&lt;/p&gt;
&lt;p&gt;其次，再次模拟一遍游戏，当找到第一个达到m且最终的分数也大于等于m的人，输出即可。&lt;br&gt;
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1题解 C题：Ancient Berland Circus</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1C%E9%A2%98%20/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1C题 /</id>
    <published>2018-09-07T16:17:01.775Z</published>
    <updated>2018-09-08T15:19:25.387Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/C" target="_blank" rel="noopener">题目传送门</a></p><p>题意：</p><p>给出三个点的坐标，这三个点可能是多个正多边形的顶点，求其中面积最小的多边形的面积</p><p>题解：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.外接圆的求法： </span><br><span class="line">(1) 有给定的坐标我们不难求出三条边的边长，rea,reb,rec;</span><br><span class="line">(2) 又海伦公式得到三角形的面积： 周长cc=(rea+reb+rec)/2.0 </span><br><span class="line">面积等于： ss=sqrt(cc*(cc-rea)*(cc-reb)*(cc-rec));</span><br><span class="line">(3) rr=rea*reb*rec/(4*ss);  //证明在底下</span><br><span class="line">得到外接圆的半径之后：</span><br><span class="line">   我们再来求出每一条边对应的圆心角a,b,c;</span><br><span class="line">   求出a,b,c圆心角的最大公约数st;</span><br><span class="line">这样我们就可以知道他是边数： 2*pi/st;</span><br><span class="line">所以得到最小单位的三角形的面积为Area=rr*rr*sin(st)/2;</span><br><span class="line">总面积只需再剩上他的边数就可以得到。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设三角形的三边的边长分别为a，b，c</span><br><span class="line">三角形的面积公式：S=1/2absinC</span><br><span class="line">由正弦定理可得a/sinA=b/sinB=c/sinC=2r(外接圆半径)</span><br><span class="line">所以整理可得S=abc/(4r)</span><br><span class="line">证毕，可得上述的步骤(3)</span><br></pre></td></tr></table></figure><p>本题收获：</p><p>1.学会了浮点数求gcd 的方法，依然是辗转相除法，但是需要用到fmod(x,y) (求出x/y的余数)，而且误差要控制在0.01左右，太精确会出错</p><p>2.误差处理，因不能过于相信公式，忽略了计算机中每一步浮点运算都可能带来误差，应该尽量减少误差</p><p>比如求三个圆心角的时候，直接用公式，最终的三个角的和，和360度的值相差很大，需要先求出两个小圆心角，最后减去，才能保证误差尽量小。</p><!-- more --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp=<span class="number">0.01</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> x,y;</span><br><span class="line">  <span class="comment">//求两点之间的长度</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">solen</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-x)*(a.x-x)+(a.y-y)*(a.y-y));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dgcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> <span class="comment">//浮点数最小公倍数，esp不要设置的太小，否则误差会很大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;esp?a:dgcd(b,<span class="built_in">fmod</span>(a,b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node a,b,c;</span><br><span class="line">  <span class="keyword">double</span> rea,reb,rec,Area;</span><br><span class="line">  <span class="keyword">double</span> angle[<span class="number">3</span>];  <span class="comment">//角度</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y,&amp;c.x,&amp;c.y);</span><br><span class="line">        rea=a.solen(b);</span><br><span class="line">        reb=a.solen(c);</span><br><span class="line">        rec=b.solen(c);</span><br><span class="line">   <span class="comment">//海伦公式</span></span><br><span class="line">   <span class="keyword">double</span> cc=(rea+reb+rec)/<span class="number">2.0</span>;</span><br><span class="line">   Area=<span class="built_in">sqrt</span>(cc*(cc-rea)*(cc-reb)*(cc-rec));</span><br><span class="line">  <span class="comment">//求得外接圆半径r</span></span><br><span class="line">   <span class="keyword">double</span>  rr=rea*reb*rec/(<span class="number">4</span>*Area);</span><br><span class="line">   angle[<span class="number">0</span>]=<span class="built_in">acos</span>(<span class="number">1</span>-rea*rea/(<span class="number">2</span>*rr*rr));</span><br><span class="line">   angle[<span class="number">1</span>]=<span class="built_in">acos</span>(<span class="number">1</span>-reb*reb/(<span class="number">2</span>*rr*rr));</span><br><span class="line">   angle[<span class="number">2</span>]=<span class="number">2</span>*PI-angle[<span class="number">0</span>]-angle[<span class="number">1</span>];   <span class="comment">//这里用2π减去上面两个角，可以让精度更准</span></span><br><span class="line">   <span class="comment">//求出角之间的最大公约数</span></span><br><span class="line">   <span class="keyword">double</span> ff=angle[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">     ff=dgcd(ff,angle[i]);</span><br><span class="line">  <span class="comment">//边数乘最小单位三角形的面积即可。</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,(rr*rr*PI*<span class="built_in">sin</span>(ff))/ff);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;给出三个点的坐标，这三个点可能是多个正多边形的顶点，求其中面积最小的多边形的面积&lt;/p&gt;
&lt;p&gt;题解：&lt;br&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://maojunjie666.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
      <category term="计算几何" scheme="http://maojunjie666.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1题解 B题：Spreadsheets</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1B%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1B题/</id>
    <published>2018-09-07T16:12:19.237Z</published>
    <updated>2018-09-08T00:45:08.856Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/B" target="_blank" rel="noopener">题目传送门</a></p><p>这题考的就是进制转换和字符串处理，这题我的方法ac的特别繁琐，然后在看了国外一个dalao的代码，发现特别巧妙，于是学过来自己写了一份。</p><p>这题的10进制转16进制不是单纯的进制转换，因为这题的26进制是没有0的，所以我们需要对能整数26进制的数做一下特殊处理。以下这种处理方式是对这个数进行减一（默认最低位是1，所以要给这个数减一）。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//递归倒序输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        print((n<span class="number">-1</span>)/<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'A'</span>+(n<span class="number">-1</span>)%<span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>],*p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        gets(str);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(str,<span class="string">"%*c%d%*c%d"</span>,&amp;x,&amp;y)==<span class="number">2</span>)&#123; <span class="comment">//巧用sscanf和*号跳过字符</span></span><br><span class="line">            print(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">             <span class="comment">//截取前半字母转成数字，后半段直接用指针输出，因为p正好指向第一个数字</span></span><br><span class="line">            <span class="keyword">for</span>(p=str;*p&gt;=<span class="string">'A'</span>;++p) sum=sum*<span class="number">26</span>+(*p-<span class="string">'A'</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"R%sC%d\n"</span>,p,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题考的就是进制转换和字符串处理，这题我的方法ac的特别繁琐，然后在看了国外一个dalao的代码，发现特别巧妙，于是学过来自己写了一份。&lt;/p&gt;
&lt;p&gt;这题的10进制转16进制不是单纯的进制转换，因为这题的26进制是没有0的，所以我们需要对能整数26进制的数做一下特殊处理。以下这种处理方式是对这个数进行减一（默认最低位是1，所以要给这个数减一）。&lt;/p&gt;
    
    </summary>
    
      <category term="字符串处理" scheme="http://maojunjie666.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
      <category term="字符串处理" scheme="http://maojunjie666.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1 A题：Theatre Square</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1A%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1A题/</id>
    <published>2018-09-07T16:10:46.079Z</published>
    <updated>2018-09-08T15:19:16.943Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/A" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们不能直接用剧院广场的面积去除以瓷砖面积，因为瓷砖不能被分割，瓷砖的总面积可以大于剧院广场的总面积。因此，我们可以分别针对剧院广场的长和宽分别除以瓷砖的边长a来计算覆盖长和覆盖宽各需要多少瓷砖，然后乘起来即可。这题交了2次才AC，又忘了考虑数据范围，因为长或宽最大为10亿，肯定有longlong范围的数据。<a id="more"></a><br><!-- more --><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a;</span><br><span class="line">    ll s=<span class="built_in">ceil</span>(n*<span class="number">1.0</span>/a);</span><br><span class="line">    ll v=<span class="built_in">ceil</span>(m*<span class="number">1.0</span>/a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,s*v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们不能直接用剧院广场的面积去除以瓷砖面积，因为瓷砖不能被分割，瓷砖的总面积可以大于剧院广场的总面积。因此，我们可以分别针对剧院广场的长和宽分别除以瓷砖的边长a来计算覆盖长和覆盖宽各需要多少瓷砖，然后乘起来即可。这题交了2次才AC，又忘了考虑数据范围，因为长或宽最大为10亿，肯定有longlong范围的数据。
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 E题：The Forest</title>
    <link href="http://maojunjie666.top/2018/09/06/%E6%90%9C%E7%B4%A2/The%20Forest/"/>
    <id>http://maojunjie666.top/2018/09/06/搜索/The Forest/</id>
    <published>2018-09-06T13:55:07.558Z</published>
    <updated>2018-09-06T14:00:01.524Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/E" target="_blank" rel="noopener">题目传送门</a></p><p>这题特别容易错的地方就是在判断出口E的时候没有判断是否越界，当第一组数据范围大，第二组小，且第一组的数据没有清零，就会导致第二次的测试用例有两个E，导致答案错误。所以要么对数据清零，要么就提前进行越界判断，此外，y0和y1在math库中已经有定义，如果include了math库或者使用了万能头文件，就会引发编译错误。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,x1,y1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    node now,next;</span><br><span class="line">    now.x=x;</span><br><span class="line">    now.y=y;</span><br><span class="line">    now.step=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vis[now.x][now.y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            next.x=now.x+dis[i][<span class="number">0</span>];</span><br><span class="line">            next.y=now.y+dis[i][<span class="number">1</span>];</span><br><span class="line">            next.step=now.step+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(next.x&lt;<span class="number">0</span>||next.x&gt;=n||next.y&lt;<span class="number">0</span>||next.y&gt;=m||</span><br><span class="line">               arr[next.x][next.y]==<span class="string">'T'</span>||vis[next.x][next.y]); <span class="comment">//先判断越界，不然可能有上次残留的E</span></span><br><span class="line">             <span class="keyword">if</span>(arr[next.x][next.y]==<span class="string">'E'</span>)<span class="keyword">return</span> next.step;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;next.x&lt;&lt;<span class="string">" "</span>&lt;&lt;next.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    vis[next.x][next.y]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]==<span class="string">'S'</span>)x1=i,y1=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=bfs(x1,y1);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(arr[i][j])&amp;&amp;arr[i][j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=bfs(i,j);</span><br><span class="line">                    <span class="keyword">if</span>(temp!=<span class="number">-1</span>&amp;&amp;temp&lt;=ans)sum+=(arr[i][j]-<span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题特别容易错的地方就是在判断出口E的时候没有判断是否越界，当第一组数据范围大，第二组小，且第一组的数据没有清零，就会导致第二次的测试用例有两个E，导致答案错误。所以要么对数据清零，要么就提前进行越界判断，此外，y0和y1在math库中已经有定义，如果include了math库或者使用了万能头文件，就会引发编译错误。&lt;/p&gt;
    
    </summary>
    
      <category term="BFS" scheme="http://maojunjie666.top/categories/BFS/"/>
    
    
      <category term="BFS" scheme="http://maojunjie666.top/tags/BFS/"/>
    
      <category term="广度优先搜索" scheme="http://maojunjie666.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
