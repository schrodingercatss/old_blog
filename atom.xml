<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哲♂学家的小黑屋</title>
  
  <subtitle>Rick&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maojunjie666.top/"/>
  <updated>2018-09-10T06:48:36.341Z</updated>
  <id>http://maojunjie666.top/</id>
  
  <author>
    <name>Schoringercatss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算几何----向量基本运算模板</title>
    <link href="http://maojunjie666.top/2018/09/10/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/"/>
    <id>http://maojunjie666.top/2018/09/10/计算几何/向量运算/</id>
    <published>2018-09-10T06:43:43.820Z</published>
    <updated>2018-09-10T06:48:36.341Z</updated>
    
    <content type="html"><![CDATA[<p><strong>向量：</strong></p><p>v1=(x1,y1) ，v2=(x2,y2)</p><hr><p><strong>向量的加减与数乘：</strong></p><p>v1 ± v2=（ x1 ± x2 , y1 ± y2 )</p><a id="more"></a><hr><p><strong>内积：</strong></p><p>v1 · v2 =|v1|·|v2|cos&lt;v1,v2&gt; = x1x2 + y1y2</p><hr><p><strong>外积：</strong></p><p>|v1×v2| = |v1|·|v2|sin&lt;v1,v2&gt;</p><p>（注：在数字上并无二维向量外积的定义，但我们常将下图操作定义为二维向量的外积：</p><p><img src="https://i.loli.net/2018/09/10/5b96127c83a14.png" alt="2.png"></p><p>且有如下性质：</p><p>(1) 顺时针为负，逆时针为正</p><p>(2) v1||v2  ⇔  v1 × v2  = 0</p><p>(3) 外积的几何意义为平行四边形的有向面积。</p><hr><p><strong>向量旋转公式：</strong></p><p>x‘ = xcosθ - ysinθ</p><p>y’ = xsinθ + ycosθ</p><hr><h4 id="基本向量运算模板"><a href="#基本向量运算模板" class="headerlink" title="基本向量运算模板"></a>基本向量运算模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp =<span class="number">1e-6</span>; <span class="comment">//esp用于控制精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI =<span class="built_in">acos</span>(<span class="number">-1.0</span>); <span class="comment">//pi</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> x,<span class="keyword">double</span> y):x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span>+(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x+b.x,a.y+b.y);&#125;<span class="comment">//加</span></span><br><span class="line">Vector <span class="keyword">operator</span>-(Vector a,Vector b)&#123;<span class="keyword">return</span> Vector(a.x-b.x,a.y-b.y);&#125;<span class="comment">//减</span></span><br><span class="line">Vector <span class="keyword">operator</span>*(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x*p,a.y*p);&#125;<span class="comment">//乘</span></span><br><span class="line">Vector <span class="keyword">operator</span>/(Vector a,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(a.x/p,a.y/p);&#125;<span class="comment">//除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  <span class="comment">//精度三态函数(&gt;0,&lt;0,=0)，判断这个值与0的关系</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;esp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)  <span class="comment">//判断向量是否相等</span></span><br><span class="line">&#123;<span class="keyword">return</span> dcmp(a.x-b.x)==<span class="number">0</span> &amp;&amp; dcmp(a.y-b.y)==<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y;&#125;  <span class="comment">//点积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(a,a));&#125; <span class="comment">//模</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(Dot(a,b)/Length(a)/Length(b));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a,Vector b)</span></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125; <span class="comment">//外积</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector a,<span class="keyword">double</span> rad)</span>  <span class="comment">//逆时针旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> Vector(a.x*<span class="built_in">cos</span>(rad)-a.y*<span class="built_in">sin</span>(rad),a.x*<span class="built_in">sin</span>(rad)+a.y*<span class="built_in">cos</span>(rad));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125; <span class="comment">//两点间距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(b-a,c-a)/<span class="number">2</span>);&#125; <span class="comment">//三角形面积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">b</span><span class="params">(<span class="number">6</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    Vector c;</span><br><span class="line">    c=a*<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c.x&lt;&lt;<span class="string">" "</span>&lt;&lt;c.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Area(a,b,c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;向量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;v1=(x1,y1) ，v2=(x2,y2)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;向量的加减与数乘：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;v1 ± v2=（ x1 ± x2 , y1 ± y2 )&lt;/p&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://maojunjie666.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="计算几何" scheme="http://maojunjie666.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part4)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B48%E6%9C%882%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年8月2日/</id>
    <published>2018-09-08T15:13:32.877Z</published>
    <updated>2018-09-09T02:54:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>内容：继承中方法的关系、方法的重写、重写和重载的区别、final关键字、final修饰的变量初始化的时机、多态、多态中的向上和向下转型、</p><p>多态的优缺点、instanceof关键字</p><hr><h4 id="继承中方法的关系"><a href="#继承中方法的关系" class="headerlink" title="继承中方法的关系"></a>继承中方法的关系</h4><p>1.同名方法:</p><p>同名方法会被子类的方法所覆盖，这种也被称为重写。<br><a id="more"></a><br>可以使用super.方法名（参数）来调用父类方法。</p><p>2.不同名方法：</p><p>不同名方法子类可以调用父类的非私有方法</p><hr><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>重写：子父类出现了一模一样的方法，特别的(返回值类型可以是字符类)，暂时先认为返回值也相同。</p><p>方法重写的应用：</p><p>当子类需要父类的功能时，而功能主题子类有自己的内容时，可以重写父类的方法，这样既沿袭了父类的功能，又定义了子类的内容。</p><p><strong>注：父类中，私有的方法是不能被重写的。</strong></p><p>子类重写父类方法时，访问的权限不能更低。 public&gt;protected&gt;defaulat&gt;private</p><p>父类的静态方法，子类必须通过静态方法进行重写。其实这个算不上方法重写（以后会学到）</p><p>子类重写父类方法时，最好声明的一模一样。</p><hr><h4 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h4><p>override和overload中，overload可以改变返回值类型</p><p>override：子父类出现了一模一样的方法，与返回值类型有关，返回值是一致（或者是子父类）的</p><p>overload：本类中出现的方法名一样，参数列表不同的方法，与返回值类型无关。</p><p>子类对象调用方法的时候：先找子类本身，再找父类。</p><hr><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final关键字修饰的特点：</p><p>*修饰类后，类就不能被继承</p><p>*修饰变量，变量就变成了常量，只能被赋值一次</p><p>*修饰方法，方法就不能被重写</p><p>如果想一个类里面的所有方法都不被重写，那就在类名前加一个final</p><p>java自带的String类就是final类，其他类的可以查看java API文档。</p><p>一般修饰常量和public static 一起共用，比如：public static final double PI  = 3.1415926；</p><p>final关键字修饰局部变量：</p><p>基本类型，修饰后是值不能改变</p><p>引用类型，是地址值不能被改变，对象中的属性可以改变。</p><hr><h4 id="final修饰的变量初始化的时机"><a href="#final修饰的变量初始化的时机" class="headerlink" title="final修饰的变量初始化的时机"></a>final修饰的变量初始化的时机</h4><p>final修饰的成员变量不会被编译器初始化的，因为它帮你初始化是无意义的，需要进行显式初始化。</p><p>final在构造完成之前显式初始化即可。如下列代码，是在构造方法中完成的显示初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num；</span><br><span class="line">    <span class="comment">//num = 10;  放在此处也可以，但必须放在第一个构造方法之前或第一个构造方法之中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：事物存在的多种形态</p><p>多态的前提：</p><p>1.要有继承关系</p><p>2.要有方法重写</p><p>3.要有父类引用指向子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coding;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"动物吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();  <span class="comment">//父类引用指向子类</span></span><br><span class="line">a.eat();</span><br><span class="line">System.out.println(a.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态中成员访问特点"><a href="#多态中成员访问特点" class="headerlink" title="多态中成员访问特点"></a>多态中成员访问特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>如上述代码，最终输出的num是父类的num，而不是子类的num</p><p>技巧：编译看左边（父类），运行看左边（父类）</p><p>在编译器编译的过程中，虽然调用了子类的构造方法，子类同时也会调用父类的构造方法，将子类和父类的变量划分区域，因为左边是父类的类型名，所以，最后返回的引用（地址）指向的是父类的那一块内存，而不是子类的那一块。</p><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>技巧：编译看左边（父类），运行看右边（子类）。(动态绑定）</p><p>（静态和类相关，算不上重写，所以，访问的还是左边的，只有非静态的成员方法满足上述技巧）</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如果子类中存在父类没有的变量或者方法，如果没有调用的话，编译是不会出错的，比如子类有一个叫num的变量或者方法，父类没有，只要下面的代码不去调用这个变量或者方法，编译器是不会去报错的。</p><p>如果子类中没有父类的方法，比如父类中有一个叫show的方法，编译的时候因为看左边不会出错，调用的时候，虽然子类没有，但是相当于子类把父类的show方法继承了下来，所以仍然不会报错。</p><p>题目一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">zi</span> <span class="keyword">extends</span> <span class="title">fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 =<span class="number">10</span>;    <span class="comment">//不调用就不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   <span class="comment">//子类有，父类没有，子类只要不调用就不会报错</span></span><br><span class="line">System.out.println(<span class="string">"method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">fu f = <span class="keyword">new</span> zi();</span><br><span class="line"><span class="comment">//f.method();  //子类有，父类没有，不调用就不会报错</span></span><br><span class="line">f.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目二：输出zi<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();   <span class="comment">//show方法相当与继承了父类，因为运行看右边，所以运行子类的show2方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目三：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();   <span class="comment">//虽然调用了父类的show方法，但是还是会运行子类的show方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="多态中的向上和向下转型"><a href="#多态中的向上和向下转型" class="headerlink" title="多态中的向上和向下转型"></a>多态中的向上和向下转型</h4><p>父类引用指向子类对象就是向上转型(子类提升为父类）</p><p>Fater a = new Son();</p><p>Son s = (Son)a;  //向下转型，这样，s能看到整个对象，而a只能看到父类的那一块内存。</p><hr><h4 id="多态的优缺点"><a href="#多态的优缺点" class="headerlink" title="多态的优缺点"></a>多态的优缺点</h4><p><strong>多态的优点：</strong></p><p>1.提高了代码的维护性（继承保证）</p><p>2.提高了代码的扩展性（多态保证）</p><p>3.可以当做形式参数，接受任意子类对象。</p><hr><p><strong>多态的缺点：</strong></p><p>不能使用子类的特有属性和行为，必须通过向下转型才能使用。</p><p>开发的时候是很少在创建对象的时候父类引用指向子类对象，直接创建子类。</p><p><strong>总结：</strong><br>当参数的时候使用多态更好，因为增强了方法的扩展性。</p><hr><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>用法：</p><p>引用名  instanceof  数据类型</p><p>判断前面的引用是否是后面的数据类型。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：继承中方法的关系、方法的重写、重写和重载的区别、final关键字、final修饰的变量初始化的时机、多态、多态中的向上和向下转型、&lt;/p&gt;
&lt;p&gt;多态的优缺点、instanceof关键字&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;继承中方法的关系&quot;&gt;&lt;a href=&quot;#继承中方法的关系&quot; class=&quot;headerlink&quot; title=&quot;继承中方法的关系&quot;&gt;&lt;/a&gt;继承中方法的关系&lt;/h4&gt;&lt;p&gt;1.同名方法:&lt;/p&gt;
&lt;p&gt;同名方法会被子类的方法所覆盖，这种也被称为重写。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part3)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B48%E6%9C%881%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年8月1日/</id>
    <published>2018-09-08T15:13:32.862Z</published>
    <updated>2018-09-09T02:54:28.316Z</updated>
    
    <content type="html"><![CDATA[<p>内容：继承的基本概念、继承的注意事项、继承中成员变量的关系、this和super关键字、继承中构造方法的关系及注意、</p><p>java的代码块、构造函数与静态代码块、构造代码块的作用</p><hr><h4 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h4><p>java中支持单继承，继承能提高代码的复用性，但同时也增加了类的耦合性，这个耦合性有利有弊，比如修改最上层类时，它下层的类也会随之改变，但是也有利于维护代码。<br><a id="more"></a><br><strong>注：继承体现的是一种关系。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoA</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoB</span> <span class="keyword">extends</span> <span class="title">DemoA</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Democ</span> <span class="keyword">extends</span> <span class="title">DemoB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DemoC"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想用这个继承体系的所有功能，使用最底层的类创建对象。如DemoC。<br>如果想看这个体系中的共性功能，使用最顶层的类创建对象。如DemoA。</p><hr><h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4><p>1.子类只能继承父类所有非私有成员（成员方法和成员变量）</p><p>2.子类不能继承父类的构造方法，因为构造方法名与类名是一样的。但可以通过super关键字去访问父类的构造方法。</p><p>3.一个类不写extends语句，默认基础object超类。</p><p>4.不要为了部分功能而去继承：例如：</p><p>项目经理：姓名 工号 工资 奖金</p><p>程序员  ：姓名 工号 工资</p><p>这个时候，不应该项目经理去继承程序员，也不应该让程序员去继承项目经理，（项目经理一去公司就管程序员叫爹的吗23333）<br>应该抽象出一个员工类，让项目经理和程序员同时去继承他们。苹果也不应该去继承香蕉，应该抽象出水果类，让他们俩同时继承水果类。</p><p><strong>判断方法：假设法，假设A是B或者B是A的一种，那么这个时候就可以考虑使用继承了。</strong></p><hr><h4 id="继承中成员变量的关系"><a href="#继承中成员变量的关系" class="headerlink" title="继承中成员变量的关系"></a>继承中成员变量的关系</h4><p>1.不同名的变量：子类直接使用父类变量的值。<br>2.同名的变量：子类和父类同名时，就近原则，使用子类的变量。</p><p>但是在开发过程中，不会出现这种情况，子类继承父类就是为了使用父类的成员，既然存在了，子类就没必要再定义了。</p><hr><h4 id="this和super关键字"><a href="#this和super关键字" class="headerlink" title="this和super关键字"></a>this和super关键字</h4><p>this：代表当前对象的引用，谁来调用我，我就代表谁。<br>super：代表当前对象父类的引用。</p><p>this和super的使用区别：<br>this.成员变量 : 既可以调用本类的成员变量，也可以调用父类的成员变量(前提是本类没有重名的变量）。</p><p>super.成员变量  :只能调用父类的成员变量。</p><hr><h4 id="继承中构造方法的关系"><a href="#继承中构造方法的关系" class="headerlink" title="继承中构造方法的关系"></a>继承中构造方法的关系</h4><p><strong>子类所以的构造方法默认都会访问父类中空参构造方法。</strong>为什么呢？因为子类会继承父类中的数据，可能还会使用父类的数据</p><p>所以，子类完成初始化之前，一定要完成父类数据的初始化。</p><p>其实，每一个构造方法的第一条语句默认都是：super() 。</p><p><strong>如果某一个类不写extends语句，默认基础Object类，它是最顶层的父类。</strong></p><hr><h4 id="继承中构造方法的注意"><a href="#继承中构造方法的注意" class="headerlink" title="继承中构造方法的注意"></a>继承中构造方法的注意</h4><p>1.父类中没有空参构造方法怎么办？<br>在子类中的所有构造函数中第一句声明，super(参数),其中参数为父类的构造函数的参数。</p><p>2.子类的无参构造函数要调用父类中的有参构造函数。<br>法一：super(参数）<br>法二：在子类的无参构造函数中加上：this(参数），这样访问的是子类的有参构造函数，而子类的有参构造中如果含有super（参数）语句，则相当于间接调用了父类的有参构造函数。</p><p><strong>注：对super的调用必须是构造函数的第一句，不用同时出现this和super语句。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">System.out.println(<span class="string">"父类有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//super(5);直接调用父类有参构造</span></span><br><span class="line"><span class="keyword">this</span>(<span class="number">5</span>);  <span class="comment">//访问Son的有参构造，间接调用父类有参构造</span></span><br><span class="line">System.out.println(<span class="string">"子类无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(num);</span><br><span class="line">System.out.println(<span class="string">"子类有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="java的代码块"><a href="#java的代码块" class="headerlink" title="java的代码块"></a>java的代码块</h4><p><strong>普通代码块</strong>：就是在方法后面使用”{}”括起来的代码片段,不能单独执行,必须调下其方法名才可以执行.</p><p><strong>静态代码块</strong>：在类中使用static修饰,并使用”{}”括起来的代码片段,用于静态变量的初始化或对象创建前的环境初始化.</p><p><strong>同步代码块</strong>：使用synchronize关键字修饰,并使用”{}”括起来的代码片段.它表示在同一时间只能有一个线程进入到该方法快中,是一种多线程保护机制.</p><p><strong>构造代码块</strong>：在类中没与任何的前缀或后缀,并使用”{}”括起来的代码片段.</p><hr><h4 id="构造函数与静态代码块"><a href="#构造函数与静态代码块" class="headerlink" title="构造函数与静态代码块"></a>构造函数与静态代码块</h4><p>当main函数入栈时，fater.class和son.class被加载进内容，static代码块随他们一起进入内存，所以先输出：父类静态代码块，子类静态代码块<br>当创建子类对象时，父类先完成初始化，所以先输出父类构造代码块，父类构造方法，然后初始化子类，输出子类构造代码块，子类构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"父类静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"父类构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"子类静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"子类构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="构造代码块的作用"><a href="#构造代码块的作用" class="headerlink" title="构造代码块的作用"></a>构造代码块的作用</h4><p><strong>1.初始化实例变量</strong></p><p>如果每个构造函数都需要初始化变量,即可通过构造代码块来实现.从而取代在每个构造函数调用初始化实例变量的方法.</p><p><strong>2.初始化实例环境</strong></p><p>一个对象必须在适当的场景下才能存在,如果没有适当的场景,则就需要在创建对象的时候创建此场景.</p><p>①编译器会把构造代码块插入到每个构造函数的最前端</p><p>②由于是插入到构造函数的的前面,自然在通过new关键字生成一个实例的时候会先执行构造代码块,然后在执行其他代码(注意:构造代码块不是在构造函数之前运行,而是依托于构造函数)</p><p>③在每个构造函数中都运行。</p><p>应用，计数器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">new</span> Client(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Client(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(Client.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码最终会输出3。</p><p>显然Java编译器是足够聪明的.这是因为,在插入到每个构造函数中的时候,有个例外,就是如果遇到this关键字(也就是构造函数调用自身其他的构造函数时)不插入构造代码块.</p><p>那为什么编译器这么聪明呢?这是因为构造代码块的出现就是为了提取构造函数的共同量,减少各个构造函数的代码而产生的。</p><p><strong>总结：</strong><br>灵活适当的使用构造代码块会让你的代码更加的简约和清晰.代码的质量自然很高很多,逼格也高了许多,有没有.</p><p><strong>最后还有一点需要注意的,千万不要认为this是特殊情况,那super也会类似处理.其实不会,在构造代码块的处理上,super方法没有任何特殊的地方.编译器只是把构造代码块插入到super方法之后执行而已.</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：继承的基本概念、继承的注意事项、继承中成员变量的关系、this和super关键字、继承中构造方法的关系及注意、&lt;/p&gt;
&lt;p&gt;java的代码块、构造函数与静态代码块、构造代码块的作用&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;继承的基本概念&quot;&gt;&lt;a href=&quot;#继承的基本概念&quot; class=&quot;headerlink&quot; title=&quot;继承的基本概念&quot;&gt;&lt;/a&gt;继承的基本概念&lt;/h4&gt;&lt;p&gt;java中支持单继承，继承能提高代码的复用性，但同时也增加了类的耦合性，这个耦合性有利有弊，比如修改最上层类时，它下层的类也会随之改变，但是也有利于维护代码。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part2)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B47%E6%9C%8830%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年7月30日/</id>
    <published>2018-09-08T15:13:32.860Z</published>
    <updated>2018-09-09T02:54:17.598Z</updated>
    
    <content type="html"><![CDATA[<p>内容：包的概念、Scanner类闭合的意义、ArrayList的用法、类或变量与public关键字、四个关键字的访问范围</p><hr><h4 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h4><p>package是在使用多个类或接口时，为了避免名称重复而采用的一种措施，直接在程序中加入package关键字即可。</p><p>Java中提供的包主要有以下3种用途:</p><p>  1) 将功能相近的类放在同一个包中，可以方便查找与使用。<br><a id="more"></a><br>  2) 由于在不同包中可以存在同名类，所以使用包在一定程度上可以避免命名冲突。</p><p>  3) 在Java中，某次访问权限是以包为单位的。</p><p>一个包中可以包含一个或多个类。</p><hr><p>下述是在java文件中指定一个包名：</p><p>package net.com.cn</p><p>“.”号的意义：点号可以看做是\号。</p><p>package net.com.cn，这时它就会生成多级文件夹，先生成net文件夹，然后在net文件夹中生成com文件夹，最后在com文件夹中生成cn文件夹<br>，我们编译生成的.class 文件就会放到cn 文件夹中。</p><p><strong>总结：</strong><br>包不仅方便管理类，还创造出了命名空间，这样就错开相同名称的类，几个程序员都设计出了某个同名类，我们可以通过包来区分，最后，包可以通过限制同一包之间的类才能相互存取以维护安全性。</p><hr><h4 id="Scanner类的闭合"><a href="#Scanner类的闭合" class="headerlink" title="Scanner类的闭合"></a>Scanner类的闭合</h4><p>close方法的作用是关闭输入的流，释放内存。属于IO流的类如果不关闭会一直占用资源。</p><hr><h4 id="AarryList的用法"><a href="#AarryList的用法" class="headerlink" title="AarryList的用法"></a>AarryList的用法</h4><p>AarryList是一个动态扩容的升级版数组，它只能存储对象，而不能存储primitive主数据类型。</p><p>调用包：import java.util.AarryList;</p><hr><p>基本操作：<br>①定义:</p><p>AarryList<object name=""> mylist = new AarryList<object name="">();</object></object></p><p>②加入元素：</p><p>mylist.add(object);</p><p>③查询容量:</p><p>mylist.size();</p><p>④查询特定元素:</p><p>myList.contains(object);  //查到返回true，否则返回false;</p><p>⑤查询特定元素位置:</p><p>mylist.indexOf(object); //未查询到返回-1</p><p>⑤判断集合是否为空:</p><p>mylist.isEmpty();</p><p>⑥删除元素：</p><p>mylist.remove(object or index); //可输入对象名或者对象的下标</p><p>⑦得到特定索引的对象：<br>mylist.get(index)； //返回对象的引用</p><hr><h4 id="public关键字"><a href="#public关键字" class="headerlink" title="public关键字"></a>public关键字</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>1.在一个文件中,有且只能有一个public类,该类与文件同名</p><p>2.在一个文件中,可以不存在public类</p><p>3.在一个文件中,可以不存在与文件同名的类(前提是此文件中没有public类)</p><p><strong>简而言之(一个java文件中只能有一个主类，一个主类必须与java文件名相同）</strong></p><p><strong>如果加上public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。</strong></p><p><strong>如果不加public,则默认的修饰词是default ,代表只对同包开放。</strong></p><hr><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>由public修饰的变量称为公共变量，可被任何包中的任何类访问。不带public等关键字默认为default 。</p><p>由protected修饰的变量称为受保护变量，可被声明它的类和派生的子类以及同一个包中的类访问。</p><hr><h4 id="四个关键字的访问范围"><a href="#四个关键字的访问范围" class="headerlink" title="四个关键字的访问范围"></a>四个关键字的访问范围</h4><p><img src="_v_images/_范围_1532946522_12676.png" alt="范围"></p><p>public：</p><p>具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。</p><p>protected：</p><p>主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。</p><p>default：</p><p>有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。</p><p>private：</p><p>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。</p><p><strong>总结：</strong><br>private关键字:只能在本类访问</p><p>default关键字：只能在本类或者同一个包下的类（子类和无关类）访问</p><p>protected关键字：本类、同一个包下的（子类和无关类）、不同包下的子类访问</p><p>public 关键字:所有包都能访问</p><hr><p>注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。</p><p><strong>区别：</strong></p><p>public：可以被所有其他类所访问</p><p>private：只能被自己访问和修改</p><p>protected：自身、子类及同一个包中类可以访问</p><p>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p><p><strong>注意：</strong><br>1、能够访问标为public protected的成员变量和方法；</p><p>2、如果子类与父类在同一包内，还能访问默认（无修饰符）的成员变量与方法。</p><p>3、不能访问标为private的成员。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：包的概念、Scanner类闭合的意义、ArrayList的用法、类或变量与public关键字、四个关键字的访问范围&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;包的概念&quot;&gt;&lt;a href=&quot;#包的概念&quot; class=&quot;headerlink&quot; title=&quot;包的概念&quot;&gt;&lt;/a&gt;包的概念&lt;/h4&gt;&lt;p&gt;package是在使用多个类或接口时，为了避免名称重复而采用的一种措施，直接在程序中加入package关键字即可。&lt;/p&gt;
&lt;p&gt;Java中提供的包主要有以下3种用途:&lt;/p&gt;
&lt;p&gt;  1) 将功能相近的类放在同一个包中，可以方便查找与使用。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习杂项笔记(part1)</title>
    <link href="http://maojunjie666.top/2018/09/08/java/2018%E5%B9%B47%E6%9C%8827%E6%97%A5/"/>
    <id>http://maojunjie666.top/2018/09/08/java/2018年7月27日/</id>
    <published>2018-09-08T15:13:32.824Z</published>
    <updated>2018-09-08T15:19:44.298Z</updated>
    
    <content type="html"><![CDATA[<p>内容：lang包、java的变量赋值、jshell的使用、java编译器的优化、赋值的下划线、java变量的初始值、java中的相等、java中的五个内存区</p><hr><h4 id="java的lang包"><a href="#java的lang包" class="headerlink" title="java的lang包"></a>java的lang包</h4><p>在编译过程中，编译器会自动帮你引入lang包，输出语句就在这个包中。<br>java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图：<br><a id="more"></a><br><img src="https://i.loli.net/2018/09/08/5b93e6b73822e.png" alt="_lang包_1532947499_9626.png"></p><hr><h4 id="java的变量赋值"><a href="#java的变量赋值" class="headerlink" title="java的变量赋值"></a>java的变量赋值</h4><p>java中为布尔类型定义了一种叫boolean类型，它只有两种取值，true和false，跟C语言不一样，java中的数字不能作为布尔值。<br>除了boolean类型，其他七种基本类型，byte/short/char/int/long/float/double，都是互相兼容的。</p><p>1.在java中，小类型可以赋值给大类型，而大类型只有通过强制类型转换才能赋值给小类型。</p><p>2.在java中，如果浮点数后面不带f，默认是double类型的，如果float =5.6；这样会报错，大类型不能直接赋值给小类型。</p><p>byte b =5;</p><p>short s =b;  //允许</p><p>byte b1 =s; //不允许</p><p>byte b1 =(byte)s; //允许，使用了强制类型转换</p><p>3.在java中，浮点数必须通过强制类型转换才能赋值给整型<br>int a =5.6;  //报错，编译器提示：这样做会损失精度<br>int a =(int)5.6;  //允许，使用了强制类型转换。</p><hr><h4 id="jshell的使用"><a href="#jshell的使用" class="headerlink" title="jshell的使用"></a>jshell的使用</h4><p>jdk9以上版本提供了一个jshell工具，这个类似python的IDLE这个shell，运行短代码时，无需写出全部代码，只需写出其中一句即可。</p><p>使用方法：在cmd中输入jshell，回车即可，如果要退出，输入:/exit 即可退出jshell并返回到cmd窗口。</p><hr><h4 id="java编译器的优化（常量优化）"><a href="#java编译器的优化（常量优化）" class="headerlink" title="java编译器的优化（常量优化）"></a>java编译器的优化（常量优化）</h4><p>对于btye、short、char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个<br>(btye)(short)(char)强制类型转换。</p><p>1.如果右侧没有超过左侧范围，则强制转换。</p><p>2.如果右侧超过了左侧范围，则编译过程直接报错。</p><p>3.特殊情况，如果右侧存在变量，这个运算情况编译器不会优化。</p><p>4.在给变量赋值的时候，如果右侧表达式中全为常量，没有任何变量，那么编译器javac将会直接将若干个表达式得到结果，如以下情况：<br>short result = 5 + 8；    这个5+8会直接得到结果，而不用在编译器后运算，这样13会被强制类型转换，不会报错，而如果右侧存在一个或以上的变量，那么编译器会直接报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//short + short ---&gt;int+int--&gt;int</span></span><br><span class="line"><span class="keyword">short</span> result = a + b;  <span class="comment">//报错，左侧需要int类型</span></span><br><span class="line"><span class="keyword">short</span> result1 = <span class="number">5</span> + <span class="number">8</span>; <span class="comment">//不会报错，javac会进行优化</span></span><br></pre></td></tr></table></figure><hr><h4 id="赋值的下划线"><a href="#赋值的下划线" class="headerlink" title="赋值的下划线"></a>赋值的下划线</h4><p>在java中，提供了一个”_“符号，来分隔较长变量，提高了程序的可读性，”_“这个符号类似注释，在编译过程中会被去掉，且这个符号除了数字的开头和末尾不能出现，其余地方都可以出现。</p><p>int a =123_456_789;</p><p>double a = 123.456_678_789;</p><hr><h4 id="java变量的初始值"><a href="#java变量的初始值" class="headerlink" title="java变量的初始值"></a>java变量的初始值</h4><p>在java中，实例变量的初始值默认是0或者null，而局部变量不一样，局部变量如果没有初始值，是不能直接去使用的。<br>局部变量：定义在方法中的变量。<br>实例变量：定义在类中的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> m =x+n;</span><br></pre></td></tr></table></figure><p>上述代码中的x和n就是局部变量，而n不给其赋初始值也不会报错，因为n是一个参数，不给func函数对应的参数编译器在这之前就会报错，所以n不用给其赋初值，而x，未经初始化直接使用编译器是回报错的。</p><hr><h4 id="java中的相等"><a href="#java中的相等" class="headerlink" title="java中的相等"></a>java中的相等</h4><p>在java中的主数据类型里，可以直接用”==”号判断两个变量是否相等，双等号是判断两个变量是否具有相同的字节组合。</p><p><strong>但：用”==”号，只能判断两个引用变量是否指向同一个对象。</strong></p><p>如果要判断两个引用变量真正意义上的相等，那就需要使用equal()方法了。</p><hr><h4 id="java的五个内存区"><a href="#java的五个内存区" class="headerlink" title="java的五个内存区"></a>java的五个内存区</h4><p>①栈(stack):存放的都是方法中的局部变量。</p><p>局部变量：方法的参数，或者是方法{}内部的变量</p><p>作用域：一旦超出作用域，立刻从栈内存当中消失。</p><hr><p>②堆(Heap)：凡是new出来的东西，都在堆当中。</p><p>堆内存里面的东西都要一个地址值，16进制</p><p>堆内存里面的数据，都有一个默认值，规则：</p><p>如果是整数：默认为0</p><p>如果是浮点数：默认为0.0</p><p>如果是字符：默认为’\u000’</p><p>如果是布尔值：默认为false</p><p>如果是引用类型：默认为null</p><hr><p>③方法区(Method Area)：存储.class相关信息，包含方法的信息。</p><hr><p>④本地方法栈(Native Method Stack)：与操作系统相关。</p><hr><p>⑤寄存器（pc Register）：与CPU相关</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：lang包、java的变量赋值、jshell的使用、java编译器的优化、赋值的下划线、java变量的初始值、java中的相等、java中的五个内存区&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;java的lang包&quot;&gt;&lt;a href=&quot;#java的lang包&quot; class=&quot;headerlink&quot; title=&quot;java的lang包&quot;&gt;&lt;/a&gt;java的lang包&lt;/h4&gt;&lt;p&gt;在编译过程中，编译器会自动帮你引入lang包，输出语句就在这个包中。&lt;br&gt;java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://maojunjie666.top/categories/java/"/>
    
    
      <category term="java" scheme="http://maojunjie666.top/tags/java/"/>
    
      <category term="学习笔记" scheme="http://maojunjie666.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 2 A题：Winner</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR2-A%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR2-A题/</id>
    <published>2018-09-08T03:06:33.000Z</published>
    <updated>2018-09-08T15:19:10.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/2/problem/A" target="_blank" rel="noopener">题目传送门</a></p><p>这道题我开始准备使用map+stable_sort来做，但是无论是map或是unorder_map，都会改变输入的顺序，导致某一组答案错误。</p><p>所以我们可以使用map来进行纯模拟的操作。</p><p>首先，在输入的同时把最终各个人的分数加起来，然后找到最大值。</p><p>其次，再次模拟一遍游戏，当找到第一个达到m且最终的分数也大于等于m的人，输出即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> close() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;P;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp,mmp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close();</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    rep(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;m;</span><br><span class="line">        v1.pb(s);v2.pb(m);</span><br><span class="line">        mp[s]+=m;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:mp) m=max(m,x.second);  <span class="comment">//求最大值</span></span><br><span class="line"></span><br><span class="line">    rep(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        mmp[v1[i]]+=v2[i];</span><br><span class="line">        <span class="keyword">if</span>(mmp[v1[i]]&gt;=m&amp;&amp;mp[v1[i]]&gt;=m)&#123; <span class="comment">//在最终分数是最大的人，且率先达到最高分数</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/2/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这道题我开始准备使用map+stable_sort来做，但是无论是map或是unorder_map，都会改变输入的顺序，导致某一组答案错误。&lt;/p&gt;
&lt;p&gt;所以我们可以使用map来进行纯模拟的操作。&lt;/p&gt;
&lt;p&gt;首先，在输入的同时把最终各个人的分数加起来，然后找到最大值。&lt;/p&gt;
&lt;p&gt;其次，再次模拟一遍游戏，当找到第一个达到m且最终的分数也大于等于m的人，输出即可。&lt;br&gt;
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1题解 C题：Ancient Berland Circus</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1C%E9%A2%98%20/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1C题 /</id>
    <published>2018-09-07T16:17:01.775Z</published>
    <updated>2018-09-08T15:19:25.387Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/C" target="_blank" rel="noopener">题目传送门</a></p><p>题意：</p><p>给出三个点的坐标，这三个点可能是多个正多边形的顶点，求其中面积最小的多边形的面积</p><p>题解：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.外接圆的求法： </span><br><span class="line">(1) 有给定的坐标我们不难求出三条边的边长，rea,reb,rec;</span><br><span class="line">(2) 又海伦公式得到三角形的面积： 周长cc=(rea+reb+rec)/2.0 </span><br><span class="line">面积等于： ss=sqrt(cc*(cc-rea)*(cc-reb)*(cc-rec));</span><br><span class="line">(3) rr=rea*reb*rec/(4*ss);  //证明在底下</span><br><span class="line">得到外接圆的半径之后：</span><br><span class="line">   我们再来求出每一条边对应的圆心角a,b,c;</span><br><span class="line">   求出a,b,c圆心角的最大公约数st;</span><br><span class="line">这样我们就可以知道他是边数： 2*pi/st;</span><br><span class="line">所以得到最小单位的三角形的面积为Area=rr*rr*sin(st)/2;</span><br><span class="line">总面积只需再剩上他的边数就可以得到。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设三角形的三边的边长分别为a，b，c</span><br><span class="line">三角形的面积公式：S=1/2absinC</span><br><span class="line">由正弦定理可得a/sinA=b/sinB=c/sinC=2r(外接圆半径)</span><br><span class="line">所以整理可得S=abc/(4r)</span><br><span class="line">证毕，可得上述的步骤(3)</span><br></pre></td></tr></table></figure><p>本题收获：</p><p>1.学会了浮点数求gcd 的方法，依然是辗转相除法，但是需要用到fmod(x,y) (求出x/y的余数)，而且误差要控制在0.01左右，太精确会出错</p><p>2.误差处理，因不能过于相信公式，忽略了计算机中每一步浮点运算都可能带来误差，应该尽量减少误差</p><p>比如求三个圆心角的时候，直接用公式，最终的三个角的和，和360度的值相差很大，需要先求出两个小圆心角，最后减去，才能保证误差尽量小。</p><!-- more --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp=<span class="number">0.01</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> x,y;</span><br><span class="line">  <span class="comment">//求两点之间的长度</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">solen</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-x)*(a.x-x)+(a.y-y)*(a.y-y));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dgcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> <span class="comment">//浮点数最小公倍数，esp不要设置的太小，否则误差会很大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;esp?a:dgcd(b,<span class="built_in">fmod</span>(a,b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node a,b,c;</span><br><span class="line">  <span class="keyword">double</span> rea,reb,rec,Area;</span><br><span class="line">  <span class="keyword">double</span> angle[<span class="number">3</span>];  <span class="comment">//角度</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y,&amp;c.x,&amp;c.y);</span><br><span class="line">        rea=a.solen(b);</span><br><span class="line">        reb=a.solen(c);</span><br><span class="line">        rec=b.solen(c);</span><br><span class="line">   <span class="comment">//海伦公式</span></span><br><span class="line">   <span class="keyword">double</span> cc=(rea+reb+rec)/<span class="number">2.0</span>;</span><br><span class="line">   Area=<span class="built_in">sqrt</span>(cc*(cc-rea)*(cc-reb)*(cc-rec));</span><br><span class="line">  <span class="comment">//求得外接圆半径r</span></span><br><span class="line">   <span class="keyword">double</span>  rr=rea*reb*rec/(<span class="number">4</span>*Area);</span><br><span class="line">   angle[<span class="number">0</span>]=<span class="built_in">acos</span>(<span class="number">1</span>-rea*rea/(<span class="number">2</span>*rr*rr));</span><br><span class="line">   angle[<span class="number">1</span>]=<span class="built_in">acos</span>(<span class="number">1</span>-reb*reb/(<span class="number">2</span>*rr*rr));</span><br><span class="line">   angle[<span class="number">2</span>]=<span class="number">2</span>*PI-angle[<span class="number">0</span>]-angle[<span class="number">1</span>];   <span class="comment">//这里用2π减去上面两个角，可以让精度更准</span></span><br><span class="line">   <span class="comment">//求出角之间的最大公约数</span></span><br><span class="line">   <span class="keyword">double</span> ff=angle[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">     ff=dgcd(ff,angle[i]);</span><br><span class="line">  <span class="comment">//边数乘最小单位三角形的面积即可。</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,(rr*rr*PI*<span class="built_in">sin</span>(ff))/ff);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;给出三个点的坐标，这三个点可能是多个正多边形的顶点，求其中面积最小的多边形的面积&lt;/p&gt;
&lt;p&gt;题解：&lt;br&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://maojunjie666.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
      <category term="计算几何" scheme="http://maojunjie666.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1题解 B题：Spreadsheets</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1B%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1B题/</id>
    <published>2018-09-07T16:12:19.237Z</published>
    <updated>2018-09-08T00:45:08.856Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/B" target="_blank" rel="noopener">题目传送门</a></p><p>这题考的就是进制转换和字符串处理，这题我的方法ac的特别繁琐，然后在看了国外一个dalao的代码，发现特别巧妙，于是学过来自己写了一份。</p><p>这题的10进制转16进制不是单纯的进制转换，因为这题的26进制是没有0的，所以我们需要对能整数26进制的数做一下特殊处理。以下这种处理方式是对这个数进行减一（默认最低位是1，所以要给这个数减一）。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//递归倒序输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        print((n<span class="number">-1</span>)/<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'A'</span>+(n<span class="number">-1</span>)%<span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>],*p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        gets(str);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(str,<span class="string">"%*c%d%*c%d"</span>,&amp;x,&amp;y)==<span class="number">2</span>)&#123; <span class="comment">//巧用sscanf和*号跳过字符</span></span><br><span class="line">            print(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">             <span class="comment">//截取前半字母转成数字，后半段直接用指针输出，因为p正好指向第一个数字</span></span><br><span class="line">            <span class="keyword">for</span>(p=str;*p&gt;=<span class="string">'A'</span>;++p) sum=sum*<span class="number">26</span>+(*p-<span class="string">'A'</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"R%sC%d\n"</span>,p,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题考的就是进制转换和字符串处理，这题我的方法ac的特别繁琐，然后在看了国外一个dalao的代码，发现特别巧妙，于是学过来自己写了一份。&lt;/p&gt;
&lt;p&gt;这题的10进制转16进制不是单纯的进制转换，因为这题的26进制是没有0的，所以我们需要对能整数26进制的数做一下特殊处理。以下这种处理方式是对这个数进行减一（默认最低位是1，所以要给这个数减一）。&lt;/p&gt;
    
    </summary>
    
      <category term="字符串处理" scheme="http://maojunjie666.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
      <category term="字符串处理" scheme="http://maojunjie666.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Beta Round 1 A题：Theatre Square</title>
    <link href="http://maojunjie666.top/2018/09/08/codeforces/CFR1A%E9%A2%98/"/>
    <id>http://maojunjie666.top/2018/09/08/codeforces/CFR1A题/</id>
    <published>2018-09-07T16:10:46.079Z</published>
    <updated>2018-09-08T15:19:16.943Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1/problem/A" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们不能直接用剧院广场的面积去除以瓷砖面积，因为瓷砖不能被分割，瓷砖的总面积可以大于剧院广场的总面积。因此，我们可以分别针对剧院广场的长和宽分别除以瓷砖的边长a来计算覆盖长和覆盖宽各需要多少瓷砖，然后乘起来即可。这题交了2次才AC，又忘了考虑数据范围，因为长或宽最大为10亿，肯定有longlong范围的数据。<a id="more"></a><br><!-- more --><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a;</span><br><span class="line">    ll s=<span class="built_in">ceil</span>(n*<span class="number">1.0</span>/a);</span><br><span class="line">    ll v=<span class="built_in">ceil</span>(m*<span class="number">1.0</span>/a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,s*v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们不能直接用剧院广场的面积去除以瓷砖面积，因为瓷砖不能被分割，瓷砖的总面积可以大于剧院广场的总面积。因此，我们可以分别针对剧院广场的长和宽分别除以瓷砖的边长a来计算覆盖长和覆盖宽各需要多少瓷砖，然后乘起来即可。这题交了2次才AC，又忘了考虑数据范围，因为长或宽最大为10亿，肯定有longlong范围的数据。
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="codeforces" scheme="http://maojunjie666.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 E题：The Forest</title>
    <link href="http://maojunjie666.top/2018/09/06/%E6%90%9C%E7%B4%A2/The%20Forest/"/>
    <id>http://maojunjie666.top/2018/09/06/搜索/The Forest/</id>
    <published>2018-09-06T13:55:07.558Z</published>
    <updated>2018-09-06T14:00:01.524Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/E" target="_blank" rel="noopener">题目传送门</a></p><p>这题特别容易错的地方就是在判断出口E的时候没有判断是否越界，当第一组数据范围大，第二组小，且第一组的数据没有清零，就会导致第二次的测试用例有两个E，导致答案错误。所以要么对数据清零，要么就提前进行越界判断，此外，y0和y1在math库中已经有定义，如果include了math库或者使用了万能头文件，就会引发编译错误。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,x1,y1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    node now,next;</span><br><span class="line">    now.x=x;</span><br><span class="line">    now.y=y;</span><br><span class="line">    now.step=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vis[now.x][now.y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            next.x=now.x+dis[i][<span class="number">0</span>];</span><br><span class="line">            next.y=now.y+dis[i][<span class="number">1</span>];</span><br><span class="line">            next.step=now.step+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(next.x&lt;<span class="number">0</span>||next.x&gt;=n||next.y&lt;<span class="number">0</span>||next.y&gt;=m||</span><br><span class="line">               arr[next.x][next.y]==<span class="string">'T'</span>||vis[next.x][next.y]); <span class="comment">//先判断越界，不然可能有上次残留的E</span></span><br><span class="line">             <span class="keyword">if</span>(arr[next.x][next.y]==<span class="string">'E'</span>)<span class="keyword">return</span> next.step;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;next.x&lt;&lt;<span class="string">" "</span>&lt;&lt;next.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    vis[next.x][next.y]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]==<span class="string">'S'</span>)x1=i,y1=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=bfs(x1,y1);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(arr[i][j])&amp;&amp;arr[i][j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=bfs(i,j);</span><br><span class="line">                    <span class="keyword">if</span>(temp!=<span class="number">-1</span>&amp;&amp;temp&lt;=ans)sum+=(arr[i][j]-<span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题特别容易错的地方就是在判断出口E的时候没有判断是否越界，当第一组数据范围大，第二组小，且第一组的数据没有清零，就会导致第二次的测试用例有两个E，导致答案错误。所以要么对数据清零，要么就提前进行越界判断，此外，y0和y1在math库中已经有定义，如果include了math库或者使用了万能头文件，就会引发编译错误。&lt;/p&gt;
    
    </summary>
    
      <category term="BFS" scheme="http://maojunjie666.top/categories/BFS/"/>
    
    
      <category term="BFS" scheme="http://maojunjie666.top/tags/BFS/"/>
    
      <category term="广度优先搜索" scheme="http://maojunjie666.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 D题：Tu Hao&#39;s Problem</title>
    <link href="http://maojunjie666.top/2018/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AC%AC39%E9%98%B6%E5%8F%B0%E9%98%B6/"/>
    <id>http://maojunjie666.top/2018/09/06/动态规划/第39阶台阶/</id>
    <published>2018-09-06T03:49:45.622Z</published>
    <updated>2018-09-07T16:08:19.753Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/D" target="_blank" rel="noopener">题目传送门</a></p><p>这题是蓝桥杯的一道填空题改编过来的，因为是填空题，数据量也比较小，可以直接使用暴力递归的方式来解决，但是在oj上有时间限制1s，使用递归肯定会超时。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> stair,<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//stari用于表示剩余的楼梯的层数，当等于0时停止递归</span></span><br><span class="line"><span class="comment">//step是走过的步数，用来判断是否是偶数，是否符合要求</span></span><br><span class="line"> <span class="keyword">if</span>(stair&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">if</span>(stair==<span class="number">0</span>)<span class="comment">//39节楼梯全部走完</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(step%<span class="number">2</span> == <span class="number">0</span>)cnt++;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> func(stair<span class="number">-1</span>,step+<span class="number">1</span>);<span class="comment">//这一步走了一个台阶</span></span><br><span class="line"> func(stair<span class="number">-2</span>,step+<span class="number">1</span>);<span class="comment">//这一步走了两个台阶</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        func(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候如果再使用暴力递归就会超时，所以得采用动态规划的方法，先提取出递归式，然后把递归得到的值用数组存储起来，避免重复计算，省去了大部分的时间。我们在纸上先推导：</p><pre><code>1.如果只有一级台阶，那么最后一步是左脚的话，方法一共是1种，就是直接迈左脚上一级台阶，任务就完成了，可是如果最后一步是右脚的话，没有办法，因为先迈左脚，直接完成任务了，右脚都出不来。。。所以最后一步是右脚的方法种数为0。2.如果有两级台阶，那么最后一步是左脚的话，方法一共是1种，就是直接迈左脚直接上两级台阶，任务就完成了，可是如果最后一步是右脚的话，只有一种办法，就是左脚先迈一脚，再迈右脚，所以最后一步是右脚的方法种数为1。依次类推：当有三级台阶的时候，左脚方法为1，右脚为2，四级台阶的时候，左脚方法为3，右脚为2……然后发现一种规律：第i级台阶的左脚方法为前两级台阶的右脚方法之和，而右脚方法为前两级左脚方法之和，然后按照这个规律循环填表即可，代码如下：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">40</span>],r[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//1级台阶时 最后一只脚为左脚的方法为1</span></span><br><span class="line">    l[<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//2级台阶时 最后一只脚为左脚的方法为1</span></span><br><span class="line">    r[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//1级台阶时 最后一只脚为右脚的方法为0</span></span><br><span class="line">    r[<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//2级台阶时 最后一只脚为右脚的方法为1</span></span><br><span class="line">    <span class="comment">//可以合并写成： left[1]=left[2]=right[2]=1,right[1]=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">40</span>;++i)&#123;</span><br><span class="line">        l[i]=r[i<span class="number">-1</span>]+r[i<span class="number">-2</span>];<span class="comment">//左脚等于前两项右脚的和</span></span><br><span class="line">        r[i]=l[i<span class="number">-1</span>]+l[i<span class="number">-2</span>]; <span class="comment">//右脚等于前两项左脚的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp();</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其实我们还可以用排列组合的问题来解这道题。</p><p>假设有39阶台阶，那么问题可以转化为：</p><p>n = c(38, 1) + (36, 3) + … + c(20, 19) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cmn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cmn = cmn * (m - i) / (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cmn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">n += c(<span class="number">39</span> - i, i); <span class="comment">//39阶台阶</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题是蓝桥杯的一道填空题改编过来的，因为是填空题，数据量也比较小，可以直接使用暴力递归的方式来解决，但是在oj上有时间限制1s，使用递归肯定会超时。&lt;/p&gt;
    
    </summary>
    
      <category term="递归" scheme="http://maojunjie666.top/categories/%E9%80%92%E5%BD%92/"/>
    
      <category term="动态规划" scheme="http://maojunjie666.top/categories/%E9%80%92%E5%BD%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="排列组合" scheme="http://maojunjie666.top/categories/%E9%80%92%E5%BD%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
    
      <category term="递归" scheme="http://maojunjie666.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="动态规划" scheme="http://maojunjie666.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="排列组合" scheme="http://maojunjie666.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第三届ACM编程决赛-高年级组 B题：Is Sorted</title>
    <link href="http://maojunjie666.top/2018/09/06/%E6%8E%92%E5%BA%8F/Is%20Sorted/"/>
    <id>http://maojunjie666.top/2018/09/06/排序/Is Sorted/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-09-07T06:46:25.117Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/21/B" target="_blank" rel="noopener">题目传送门</a></p><p>因为这题的数据量不是太大，我们可以直接用冒泡排序的方式进行比较，如果在比较的过程中，发现前一个元素大于等于后一个元素，就说明数列不是严格递增数列，将flag置为false，跳出循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;=arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/21/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为这题的数据量不是太大，我们可以直接用冒泡排序的方式进行比较，如果在比较
      
    
    </summary>
    
      <category term="-排序" scheme="http://maojunjie666.top/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="http://maojunjie666.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第六届ACM编程决赛-低年级组 G题：做游戏</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%A8%A1%E6%8B%9F/%E5%81%9A%E6%B8%B8%E6%88%8F/"/>
    <id>http://maojunjie666.top/2018/09/05/模拟/做游戏/</id>
    <published>2018-09-05T14:25:43.495Z</published>
    <updated>2018-09-06T02:42:03.791Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/23/G" target="_blank" rel="noopener">题目传送门</a></p><p><strong>(特别注意，题目中可能有没有传送门的测试样例！！！)</strong></p><p>这题其实是一道水题，我们可以找到他的起点和终点（测试用例可能有起点不在第一个字符，或者终点不在最后一个字符的情况),第一遍从起点开始遍历，找到第一个传送阵记录到达传送阵的步数step，第二遍从终点开始遍历，找到离终点最近的一个传送阵，记录步数（只要找离起点和终点最近的传送阵即可，因为中间的传送阵根本不会到达），如果不是一个传送阵，就给步数加1（从一个传送阵到另一个传送阵消耗1个步数），否则不加。</p><p>然后用步数对他们掷骰子的情况一个一个的做减法，谁掷的点数先使step小于等于0，谁就剩，用奇偶判断即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k1=<span class="number">0</span>,k2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> len = a.size();</span><br><span class="line">   <span class="comment">//找到起点和终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'S'</span>)</span><br><span class="line">                x = i;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'E'</span>)</span><br><span class="line">                y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起点出发，找到最近的传送门</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="string">'@'</span>)</span><br><span class="line">                step++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k1=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从终点出发，找到最近的传送门</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="string">'@'</span>)</span><br><span class="line">                step++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k2=i;</span><br><span class="line">                <span class="keyword">if</span>(k1!=k2)step+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(k1!=k2)step+=1;  这里不能把这句放外面，题目样例有毒，可能没用传送门</span></span><br><span class="line">        <span class="comment">//可以改成(k1*k2 &amp;&amp; k1!=k2)step+=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            step -= arr[i];</span><br><span class="line">            <span class="keyword">if</span>(step &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, i % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"Tabris"</span> : <span class="string">"mengxiang000"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(step &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"None"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/23/G&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(特别注意，题目中可能有没有传送门的测试样例！！！)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这题其实是一道水题，我们可以找到他的起点和终点（测试用例可能有起点不在第一个字符，或者终点不在最后一个字符的情况),第一遍从起点开始遍历，找到第一个传送阵记录到达传送阵的步数step，第二遍从终点开始遍历，找到离终点最近的一个传送阵，记录步数（只要找离起点和终点最近的传送阵即可，因为中间的传送阵根本不会到达），如果不是一个传送阵，就给步数加1（从一个传送阵到另一个传送阵消耗1个步数），否则不加。&lt;/p&gt;
&lt;p&gt;然后用步数对他们掷骰子的情况一个一个的做减法，谁掷的点数先使step小于等于0，谁就剩，用奇偶判断即可。&lt;/p&gt;
    
    </summary>
    
      <category term="模拟" scheme="http://maojunjie666.top/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="http://maojunjie666.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---A题：星图</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%9D%82%E9%A1%B9/%E6%98%9F%E5%9B%BE/"/>
    <id>http://maojunjie666.top/2018/09/05/杂项/星图/</id>
    <published>2018-09-05T14:14:21.000Z</published>
    <updated>2018-09-05T08:40:12.529Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/A" target="_blank" rel="noopener">题目传送门</a></p><p>这题第一次做的时候没有做到一个合格acmer的基本素质，应首先判断输入的规模，再来确定算法复杂度，误以为题目简单，直接循环暴力搜索头铁就去做了，结果TLE。</p><p>在确认了输入规模后，确定了这道题必须先对原矩阵的行和列进行区间处理或者前缀和处理（计算前n项有多少个黑洞），然后在进行复杂度为O(1)的查询即可。</p><p>下列是使用区间处理的方法，维护矩阵的每行和每列的最大最小值，然后进行O(1)的查询即可。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;    <span class="comment">//在输入的时候先对 行进行处理</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;minv)minv=j; </span><br><span class="line">                <span class="keyword">if</span>(j&gt;maxv)maxv=j;</span><br><span class="line">            &#125;</span><br><span class="line">            row[i][<span class="number">0</span>]=minv,row[i][<span class="number">1</span>]=maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对列进行处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;minv)minv=i;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;maxv)maxv=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        col[j][<span class="number">0</span>]=minv;</span><br><span class="line">        col[j][<span class="number">1</span>]=maxv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,op);</span><br><span class="line">        x--,y--;  <span class="comment">//因为坐标是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'U'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;col[y][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;col[y][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;row[x][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;row[x][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题第一次做的时候没有做到一个合格acmer的基本素质，应首先判断输入的规模，再来确定算法复杂度，误以为题目简单，直接循环暴力搜索头铁就去做了，结果TLE。&lt;/p&gt;
&lt;p&gt;在确认了输入规模后，确定了这道题必须先对原矩阵的行和列进行区间处理或者前缀和处理（计算前n项有多少个黑洞），然后在进行复杂度为O(1)的查询即可。&lt;/p&gt;
&lt;p&gt;下列是使用区间处理的方法，维护矩阵的每行和每列的最大最小值，然后进行O(1)的查询即可。&lt;br&gt;
    
    </summary>
    
      <category term="区间处理" scheme="http://maojunjie666.top/categories/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
    
      <category term="区间处理" scheme="http://maojunjie666.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哈理工软件学院第六届ACM编程决赛-低年级组 D题：逃脱</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%90%9C%E7%B4%A2/%E9%80%83%E8%84%B1/"/>
    <id>http://maojunjie666.top/2018/09/05/搜索/逃脱/</id>
    <published>2018-09-05T14:14:21.000Z</published>
    <updated>2018-09-05T13:00:34.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/23/D" target="_blank" rel="noopener">题目传送门</a></p><p>这题开始没想到怎么处理火，火可以走一遍bfs，记录或到达各个点的步数即可，但是有一种更好的方式处理火到达的时间，判断某点x和y坐标与火的x和y坐标，因为火到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标与火坐标行或列的差的最大绝对值值即可。</p><p>人就可以直接BFS，找到出口E就返回步数，当走过一遍BFS后没有return返回步数，就表示他们无法逃脱。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> maze[<span class="number">35</span>][<span class="number">35</span>],fire[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,st,ed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,step;  <span class="comment">//点的坐标和到达所需步数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="comment">//火灾到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标行或列的最大值即可。</span></span><br><span class="line">            fire[i][j]=max(<span class="built_in">abs</span>(i-x),<span class="built_in">abs</span>(j-y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    node now,next;</span><br><span class="line">    now.x=st,now.y=ed,now.step=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            next.x=now.x+dis[i][<span class="number">0</span>];</span><br><span class="line">            next.y=now.y+dis[i][<span class="number">1</span>];</span><br><span class="line">            next.step=now.step+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里不用判断next的x和y坐标是否越界，因为越界肯定不会等于E。</span></span><br><span class="line">            <span class="keyword">if</span>(maze[next.x][next.y]==<span class="string">'E'</span> &amp;&amp;next.step&lt;=fire[next.x][next.y])<span class="keyword">return</span> next.step;</span><br><span class="line">            <span class="keyword">if</span>(next.x&lt;n &amp;&amp;next.y&lt;m &amp;&amp; next.x&gt;=<span class="number">0</span> &amp;&amp;next.y&gt;=<span class="number">0</span> &amp;&amp;maze[next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;</span><br><span class="line">               !vis[next.x][next.y] &amp;&amp; next.step&lt;fire[next.x][next.y])&#123;</span><br><span class="line">                    vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">                    q.push(next);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;maze[i][j];</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="string">'*'</span>)x=i,y=j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="string">'S'</span>)st=i,ed=j;</span><br><span class="line">        &#125;</span><br><span class="line">        Fire();</span><br><span class="line">        <span class="keyword">int</span> ans=bfs();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"T_T"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/23/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题开始没想到怎么处理火，火可以走一遍bfs，记录或到达各个点的步数即可，但是有一种更好的方式处理火到达的时间，判断某点x和y坐标与火的x和y坐标，因为火到了某行和某列，一定会烧到这一格身上，所以我们只需要找到这个坐标与火坐标行或列的差的最大绝对值值即可。&lt;/p&gt;
&lt;p&gt;人就可以直接BFS，找到出口E就返回步数，当走过一遍BFS后没有return返回步数，就表示他们无法逃脱。&lt;/p&gt;
    
    </summary>
    
      <category term="BFS" scheme="http://maojunjie666.top/categories/BFS/"/>
    
    
      <category term="BFS" scheme="http://maojunjie666.top/tags/BFS/"/>
    
      <category term="广度优先搜索" scheme="http://maojunjie666.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---C题：装进肚子</title>
    <link href="http://maojunjie666.top/2018/09/05/%E6%9D%82%E9%A1%B9/%E8%A3%85%E8%BF%9B%E8%82%9A%E5%AD%90/"/>
    <id>http://maojunjie666.top/2018/09/05/杂项/装进肚子/</id>
    <published>2018-09-05T08:23:27.483Z</published>
    <updated>2018-09-05T08:38:39.314Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/C" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们对结构体进行排序，但是不能分别对早上和晚上的甜蜜值进行分类排序，而应该根据他们的差值，来从大到小排序，这样我们得到的前k的个肯定是早上的甜蜜值较大的，后面的都是晚上甜蜜值更大的。举个栗子：</p><a id="more"></a><p>1  3 、2   4 、  3   9  、4  12        这四对数进行排序后，为：</p><p>1-3= - 2、  2-4 = - 2、   3-9 = - 6、   4-12 = - 8 </p><p>这样排序，我们可以把晚上甜蜜值更大留在后头，而早上甜蜜值较大的留在前头。</p><p>而且我们观察，如果有两组差值相同的，如果是都是早上吃的或者晚上吃的不用考虑，如果是一早一晚吃的，他们的和必定相等，比如早上是1，晚上就是4，早上是2，晚上就是3，不会影响最终答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mo,ev;</span><br><span class="line">&#125;arr[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.mo-a.ev&gt;b.mo-b.ev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].mo; <span class="comment">//第二行输入早上的甜蜜值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].ev; <span class="comment">//第三行输入晚上的甜蜜值</span></span><br><span class="line">    sort(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>,cmp);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=k)sum+=arr[i].mo;</span><br><span class="line">        <span class="keyword">else</span> sum+=arr[i].ev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们对结构体进行排序，但是不能分别对早上和晚上的甜蜜值进行分类排序，而应该根据他们的差值，来从大到小排序，这样我们得到的前k的个肯定是早上的甜蜜值较大的，后面的都是晚上甜蜜值更大的。举个栗子：&lt;/p&gt;
    
    </summary>
    
      <category term="区间处理" scheme="http://maojunjie666.top/categories/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
    
      <category term="区间处理" scheme="http://maojunjie666.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---E题：开心的涂刷</title>
    <link href="http://maojunjie666.top/2018/09/05/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BC%80%E5%BF%83%E7%9A%84%E6%B6%82%E5%88%B7/"/>
    <id>http://maojunjie666.top/2018/09/05/组合数学/开心的涂刷/</id>
    <published>2018-09-05T07:34:21.170Z</published>
    <updated>2018-09-05T08:41:36.762Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/E" target="_blank" rel="noopener">题目传送门</a></p><p>这题是一个组合数学问题。</p><p>分析： 一共有 m^n^ 个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，因为第一位的颜色还可以选,顾所有的可能应该为：m^n^−m∗(m−1)^n−1^,直接快速幂即可 </p><p>由取余公式我们可以得到   (n-m)%K = （n%k-m%k)%k</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x) (x)%MOD    <span class="comment">//注意给x带上括号，因为宏定义只是单纯的替换</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    a%=MOD;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll ans=mod(pow_mod(m,n)-mod(m)*pow_mod(m<span class="number">-1</span>,n<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mod(ans+MOD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题是一个组合数学问题。&lt;/p&gt;
&lt;p&gt;分析： 一共有 m^n^ 个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可，考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色，那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择，因为第一位的颜色还可以选,顾所有的可能应该为：m^n^−m∗(m−1)^n−1^,直接快速幂即可 &lt;/p&gt;
&lt;p&gt;由取余公式我们可以得到   (n-m)%K = （n%k-m%k)%k&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://maojunjie666.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://maojunjie666.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>西南民族大学程序设计竞赛---K题：免费wifi</title>
    <link href="http://maojunjie666.top/2018/09/05/%E8%B4%AA%E5%BF%83/free%20wifi/"/>
    <id>http://maojunjie666.top/2018/09/05/贪心/free wifi/</id>
    <published>2018-09-05T06:10:59.942Z</published>
    <updated>2018-09-05T08:39:59.727Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/64/K" target="_blank" rel="noopener">题目传送门</a></p><p>这题我们第一眼觉得是区间计数的题，可是我不会区间计数，于是就用了贪心算法来解。我们先对起始时间进行升序排序，如果起始时间相同，按照结束时间升序排序，对结束时间，我们使用一个小堆顶的优先队列来维护，这样可以保证结束时间最小的总在堆顶，然后比较下一个人的起始时间与堆顶结束时间，如果堆顶结束时间小于起始时间，就让堆顶的元素出列，给路由器数量加一，并且把m个人的结束时间加入堆中。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line">&#125;arr[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.st==b.st)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.ed&lt;b.ed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.st&lt;b.st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;arr[i].st&gt;&gt;arr[i].ed;</span><br><span class="line">    sort(arr,arr+n,cmp);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)pq.push(arr[i].ed);<span class="comment">//初始给m个人开1台</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;  <span class="comment">//至少1台</span></span><br><span class="line">    <span class="keyword">int</span> j=m; <span class="comment">//因为前面放置了编号0-m-1的人，所以j从编号m开始</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> top=pq.top();</span><br><span class="line">        <span class="keyword">if</span>(top&lt;arr[j].st)&#123;</span><br><span class="line">            pq.pop();</span><br><span class="line">            pq.push(arr[j++].ed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">                pq.push(arr[j++].ed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间计数的方法非常方便，只要找到真个区间中最大的那个值就行了，每重叠一次就加一，</p><p>因为求的是最少个数， 将时间段内的最大值sum找出，ans=int(ceil(1.0*sum/m)) </p><p>比如样例，区间计数后为：1 2 3 3 2 2 2 1 1 ，所以找到3就行，然后再根据m的值得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">            arr[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxv=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5000</span>;++i)maxv=max(arr[i],maxv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样处理可以不用ceil函数</span></span><br><span class="line">    <span class="keyword">if</span>(maxv%m==<span class="number">0</span>)ans=maxv/m;  </span><br><span class="line">    <span class="keyword">else</span> ans=maxv/m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/64/K&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题我们第一眼觉得是区间计数的题，可是我不会区间计数，于是就用了贪心算法来解。我们先对起始时间进行升序排序，如果起始时间相同，按照结束时间升序排序，对结束时间，我们使用一个小堆顶的优先队列来维护，这样可以保证结束时间最小的总在堆顶，然后比较下一个人的起始时间与堆顶结束时间，如果堆顶结束时间小于起始时间，就让堆顶的元素出列，给路由器数量加一，并且把m个人的结束时间加入堆中。&lt;br&gt;
    
    </summary>
    
      <category term="贪心" scheme="http://maojunjie666.top/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="贪心" scheme="http://maojunjie666.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>什么是EOF</title>
    <link href="http://maojunjie666.top/2018/09/02/C%E8%AF%AD%E8%A8%80/EOF/"/>
    <id>http://maojunjie666.top/2018/09/02/C语言/EOF/</id>
    <published>2018-09-02T14:14:21.000Z</published>
    <updated>2018-09-03T10:02:47.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是EOF？"><a href="#什么是EOF？" class="headerlink" title="什么是EOF？"></a>什么是EOF？</h4><p>很多萌新都问到，什么是eof，所以我特地写了一篇博文来介绍EOF。</p><p>首先来看，百度百科给其的定义：</p><p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。<br><a id="more"></a></p><hr><h4 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h4><p>简单来说，eof就是在文件末尾添加的一个字符。在C语言中，EOF是一个关键字，它的值是-1，这样不会与ASCII码冲突（这个以后再详说）</p><p>在window中，eof使用快捷键：<code>ctrl+z</code> 来输入。</p><p>又比如，在下面这个例子中，在8的末尾是有一个eof的，当读取完8后，继续往下读，读到了eof，结束读入。</p><blockquote><p>1 2</p><p>3 4</p><p>5 6</p><p>7 8</p></blockquote><p>EOF在OJ是用来针对多组输入问题的，当你不知道系统有几组输入时，你都可以使用EOF关键字判断，因为不论是有3组、4组还是n组，只要读到了EOF关键字，肯定能表示测试用例已经读完。</p><hr><h4 id="代码举例（C语言）"><a href="#代码举例（C语言）" class="headerlink" title="代码举例（C语言）"></a>代码举例（C语言）</h4><p>现在我们有一个不确定有多少组输入的A+B问题。</p><p>C语言比较方便，因为c语言中定义了EOF关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF)&#123;    <span class="comment">//这里当scanf读取正确时，返回参数个数，如果读到EOF，返回EOF</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当scanf返回EOF，不满足while循环的条件时就结束了输入，非常方便。</p><hr><h4 id="代码举例-python"><a href="#代码举例-python" class="headerlink" title="代码举例(python)"></a>代码举例(python)</h4><p>在python中，是没有定义eof关键字的，但是我们可以使用异常捕获来针对eof关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       print(sum(int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()))</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当捕获到eof时，就会执行pass语句，pass语句表示什么都不执行，然后循环就会结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是EOF？&quot;&gt;&lt;a href=&quot;#什么是EOF？&quot; class=&quot;headerlink&quot; title=&quot;什么是EOF？&quot;&gt;&lt;/a&gt;什么是EOF？&lt;/h4&gt;&lt;p&gt;很多萌新都问到，什么是eof，所以我特地写了一篇博文来介绍EOF。&lt;/p&gt;
&lt;p&gt;首先来看，百度百科给其的定义：&lt;/p&gt;
&lt;p&gt;EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://maojunjie666.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://maojunjie666.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>18级编程俱乐部新生赛div1轮题解</title>
    <link href="http://maojunjie666.top/2018/09/02/%E7%BC%96%E7%A8%8B%E4%BF%B1%E4%B9%90%E9%83%A8%E6%9C%88%E8%B5%9B/mrdiv1/"/>
    <id>http://maojunjie666.top/2018/09/02/编程俱乐部月赛/mrdiv1/</id>
    <published>2018-09-02T14:14:21.000Z</published>
    <updated>2018-09-04T10:03:26.333Z</updated>
    
    <content type="html"><![CDATA[<p>前言：这次的题目不算很难，都是你们学过的东西，比如第一题是排序，第二题的循环，第三题的斐波那契等等。</p><hr><h4 id="【新生阶段月赛NO-1】白细胞"><a href="#【新生阶段月赛NO-1】白细胞" class="headerlink" title="【新生阶段月赛NO.1】白细胞"></a>【新生阶段月赛NO.1】白细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=0" target="_blank" rel="noopener">传送门:</a> </p><p>这题非常的水，按非降序的方式排序，然后用循环模拟整个过程即可。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a,b=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L.sort()</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=i):</span><br><span class="line">        a-=i</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><hr><h4 id="【新生阶段月赛NO-2】红细胞"><a href="#【新生阶段月赛NO-2】红细胞" class="headerlink" title="【新生阶段月赛NO.2】红细胞"></a>【新生阶段月赛NO.2】红细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=1" target="_blank" rel="noopener">传送门:</a></p><p>这题无比的水，循环连乘即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">ans=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    ans*=i</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-3】杀手T细胞"><a href="#【新生阶段月赛NO-3】杀手T细胞" class="headerlink" title="【新生阶段月赛NO.3】杀手T细胞"></a>【新生阶段月赛NO.3】杀手T细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=2" target="_blank" rel="noopener">传送门:</a></p><p>这题观察可知，杀手t细胞可以走1步或跑2步，观察前几项可知为：1 2 3 5 8  ，显然是个斐波那契数列，循环走一波，ac。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   <span class="comment">#打表，打出前几项，然后在进行循环递推</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,<span class="number">32</span>):</span><br><span class="line">    L.append(L[i<span class="number">-1</span>]+L[i<span class="number">-2</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=int(input())</span><br><span class="line">        print(L[n])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-4】辅助T细胞"><a href="#【新生阶段月赛NO-4】辅助T细胞" class="headerlink" title="【新生阶段月赛NO.4】辅助T细胞"></a>【新生阶段月赛NO.4】辅助T细胞</h4><p><a href="hhttp://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=3" target="_blank" rel="noopener">传送门:</a></p><p>用python的孩子这题可以直接用字符串的方式来做，不过用c就的话，就需要用下面这种方式了。</p><p>这题我们显然可以用取余的方式来获得每一位，比如631，</p><p>631%10=1  取余一次再整除10，631//10=63  </p><p>63%10=3  再整除10，63//10=6</p><p>6%10=6  再整除10,  6//10=0</p><p>结束循环即可，使用一个变量记录6的个数，如果是2，就给计数器变量加1，最后输出计数器变量即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取余解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">sum=<span class="number">0</span> <span class="comment">#计数器变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">66</span>,n+<span class="number">1</span>):  <span class="comment">#i至少从66开始才会有2个6，如果小于66，这个循环不会执行</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">6</span>):cnt+=<span class="number">1</span>;</span><br><span class="line">        i=i//<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">2</span>):sum+=<span class="number">1</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    cnt=str(i).count(<span class="string">'6'</span>)</span><br><span class="line">    <span class="keyword">if</span> cnt==<span class="number">2</span>:</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-5】巨噬细胞"><a href="#【新生阶段月赛NO-5】巨噬细胞" class="headerlink" title="【新生阶段月赛NO.5】巨噬细胞"></a>【新生阶段月赛NO.5】巨噬细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=4" target="_blank" rel="noopener">传送门:</a></p><p>这题显然对10取余即可，只有（9+1）%10=0，这样正好模拟了向前推一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l=[(int(x)+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> input()]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">    print(l[i],end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-6】压轴：血小板是我的"><a href="#【新生阶段月赛NO-6】压轴：血小板是我的" class="headerlink" title="【新生阶段月赛NO.6】压轴：血小板是我的"></a>【新生阶段月赛NO.6】压轴：血小板是我的</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=5" target="_blank" rel="noopener">传送门:</a></p><p>这题是著名的约瑟夫环问题，有兴趣的孩子可以百度，我这题出的数据特别的小，所以可以用模拟的方法ac，如果数据量大，模拟的方式肯定会超时。</p><p>下面是用递推的方式来解这个问题，<strong>证明过程如下：</strong></p><blockquote><p>令f[n]表示当有n个候选人时，最后当选者的编号。<br>f[1] = 0<br>f[n] = (f[n - 1] + K) mod n</p></blockquote><p>接下来我们用数学归纳法来证明这个递推公式的正确性：</p><p>(1) <strong>f[1] = 0</strong></p><p>显然当只有1个候选人时，该候选人就是当选者，并且他的编号为0。</p><p>(2) <strong>f[n] = (f[n - 1] + K) mod n</strong></p><p>假设我们已经求解出了f[n - 1]，并且保证f[n - 1]的值是正确的。</p><p>现在先将n个人按照编号进行排序：</p><p>那么第一次被淘汰的人编号一定是K-1(假设K &lt; n，若K &gt; n则为(K-1) mod n)。将被选中的人标记为”#”：</p><p>第二轮报数时，起点为K这个候选人。并且只剩下n-1个选手。假如此时把k+1看作0’，k+2看作1’…</p><p>则对应有：</p><p>此时在0’,1’,…,n-2’上再进行一次K报数的选择。而f[n-1]的值已经求得，因此我们可以直接求得当选者的编号s’。</p><p>但是，该编号s’是在n-1个候选人报数时的编号，并不等于n个人时的编号，所以我们还需要将s’转换为对应的s。</p><p>通过观察，s和s’编号相对偏移了K，又因为是在环中，因此得到s = (s’+K) mod n。</p><p>即f[n] = (f[n-1] + k) mod n。</p><p>至此递推公式的两个式子我们均证明了其正确性，则对于任意给定的n，我们可以使用该递推式求得f[n]，写成伪代码为：</p><p>同时由于计算f[i]时，只会用到f[i-1]，因此我们还可以将f[]的空间节约，改进后的代码为：</p><p>该算法的时间复杂度为O(N)，空间复杂度为O(1)。对于N不是很大的数据来说，可以解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n,m=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    s=(s+m)%i  <span class="comment">#循环递推式</span></span><br><span class="line">print(s+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：这次的题目不算很难，都是你们学过的东西，比如第一题是排序，第二题的循环，第三题的斐波那契等等。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;【新生阶段月赛NO-1】白细胞&quot;&gt;&lt;a href=&quot;#【新生阶段月赛NO-1】白细胞&quot; class=&quot;headerlink&quot; title=&quot;【新生阶段月赛NO.1】白细胞&quot;&gt;&lt;/a&gt;【新生阶段月赛NO.1】白细胞&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;amp;pid=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门:&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这题非常的水，按非降序的方式排序，然后用循环模拟整个过程即可。&lt;br&gt;
    
    </summary>
    
      <category term="18级新生赛题解" scheme="http://maojunjie666.top/categories/18%E7%BA%A7%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="新生赛题解" scheme="http://maojunjie666.top/tags/%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
