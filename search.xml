<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>西南民族大学程序设计竞赛---A题：星图</title>
      <link href="/2018/09/05/Other/xingtu/"/>
      <url>/2018/09/05/Other/xingtu/</url>
      <content type="html"><![CDATA[<p>这题第一次做的时候没有做到一个合格acmer的基本素质，应首先判断输入的规模，再来确定算法复杂度，误以为题目简单，直接循环暴力搜索头铁就去做了，结果TLE。</p><p>在确认了输入规模后，确定了这道题必须先对原矩阵的行和列进行区间处理或者前缀和处理（计算前n项有多少个黑洞），然后在进行复杂度为O(1)的查询即可。</p><p>下列是使用区间处理的方法，维护矩阵的每行和每列的最大最小值，然后进行O(1)的查询即可。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;    <span class="comment">//在输入的时候先对 行进行处理</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;minv)minv=j; </span><br><span class="line">                <span class="keyword">if</span>(j&gt;maxv)maxv=j;</span><br><span class="line">            &#125;</span><br><span class="line">            row[i][<span class="number">0</span>]=minv,row[i][<span class="number">1</span>]=maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对列进行处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> minv=INF,maxv=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;minv)minv=i;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;maxv)maxv=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        col[j][<span class="number">0</span>]=minv;</span><br><span class="line">        col[j][<span class="number">1</span>]=maxv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,op);</span><br><span class="line">        x--,y--;  <span class="comment">//因为坐标是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'U'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;col[y][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;col[y][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;row[x][<span class="number">0</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;row[x][<span class="number">1</span>])flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 区间处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是EOF</title>
      <link href="/2018/09/02/C/EOF/"/>
      <url>/2018/09/02/C/EOF/</url>
      <content type="html"><![CDATA[<h4 id="什么是EOF？"><a href="#什么是EOF？" class="headerlink" title="什么是EOF？"></a>什么是EOF？</h4><p>很多萌新都问到，什么是eof，所以我特地写了一篇博文来介绍EOF。</p><p>首先来看，百度百科给其的定义：</p><p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。<br><a id="more"></a></p><hr><h4 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h4><p>简单来说，eof就是在文件末尾添加的一个字符。在C语言中，EOF是一个关键字，它的值是-1，这样不会与ASCII码冲突（这个以后再详说）</p><p>在window中，eof使用快捷键：<code>ctrl+z</code> 来输入。</p><p>又比如，在下面这个例子中，在8的末尾是有一个eof的，当读取完8后，继续往下读，读到了eof，结束读入。</p><blockquote><p>1 2</p><p>3 4</p><p>5 6</p><p>7 8</p></blockquote><p>EOF在OJ是用来针对多组输入问题的，当你不知道系统有几组输入时，你都可以使用EOF关键字判断，因为不论是有3组、4组还是n组，只要读到了EOF关键字，肯定能表示测试用例已经读完。</p><hr><h4 id="代码举例（C语言）"><a href="#代码举例（C语言）" class="headerlink" title="代码举例（C语言）"></a>代码举例（C语言）</h4><p>现在我们有一个不确定有多少组输入的A+B问题。</p><p>C语言比较方便，因为c语言中定义了EOF关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF)&#123;    <span class="comment">//这里当scanf读取正确时，返回参数个数，如果读到EOF，返回EOF</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当scanf返回EOF，不满足while循环的条件时就结束了输入，非常方便。</p><hr><h4 id="代码举例-python"><a href="#代码举例-python" class="headerlink" title="代码举例(python)"></a>代码举例(python)</h4><p>在python中，是没有定义eof关键字的，但是我们可以使用异常捕获来针对eof关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       print(sum(int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()))</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当捕获到eof时，就会执行pass语句，pass语句表示什么都不执行，然后循环就会结束了。</p>]]></content>
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>18级编程俱乐部新生赛div1轮题解</title>
      <link href="/2018/09/02/program%20club/mrdiv1/"/>
      <url>/2018/09/02/program%20club/mrdiv1/</url>
      <content type="html"><![CDATA[<p>前言：这次的题目不算很难，都是你们学过的东西，比如第一题是排序，第二题的循环，第三题的斐波那契等等。</p><hr><h4 id="【新生阶段月赛NO-1】白细胞"><a href="#【新生阶段月赛NO-1】白细胞" class="headerlink" title="【新生阶段月赛NO.1】白细胞"></a>【新生阶段月赛NO.1】白细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=0" target="_blank" rel="noopener">传送门:</a> </p><p>这题非常的水，按非降序的方式排序，然后用循环模拟整个过程即可。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a,b=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">L.sort()</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=i):</span><br><span class="line">        a-=i</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><hr><h4 id="【新生阶段月赛NO-2】红细胞"><a href="#【新生阶段月赛NO-2】红细胞" class="headerlink" title="【新生阶段月赛NO.2】红细胞"></a>【新生阶段月赛NO.2】红细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=1" target="_blank" rel="noopener">传送门:</a></p><p>这题无比的水，循环连乘即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">L=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">ans=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    ans*=i</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-3】杀手T细胞"><a href="#【新生阶段月赛NO-3】杀手T细胞" class="headerlink" title="【新生阶段月赛NO.3】杀手T细胞"></a>【新生阶段月赛NO.3】杀手T细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=2" target="_blank" rel="noopener">传送门:</a></p><p>这题观察可知，杀手t细胞可以走1步或跑2步，观察前几项可知为：1 2 3 5 8  ，显然是个斐波那契数列，循环走一波，ac。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   <span class="comment">#打表，打出前几项，然后在进行循环递推</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,<span class="number">32</span>):</span><br><span class="line">    L.append(L[i<span class="number">-1</span>]+L[i<span class="number">-2</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=int(input())</span><br><span class="line">        print(L[n])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-4】辅助T细胞"><a href="#【新生阶段月赛NO-4】辅助T细胞" class="headerlink" title="【新生阶段月赛NO.4】辅助T细胞"></a>【新生阶段月赛NO.4】辅助T细胞</h4><p><a href="hhttp://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=3" target="_blank" rel="noopener">传送门:</a></p><p>用python的孩子这题可以直接用字符串的方式来做，不过用c就的话，就需要用下面这种方式了。</p><p>这题我们显然可以用取余的方式来获得每一位，比如631，</p><p>631%10=1  取余一次再整除10，631//10=63  </p><p>63%10=3  再整除10，63//10=6</p><p>6%10=6  再整除10,  6//10=0</p><p>结束循环即可，使用一个变量记录6的个数，如果是2，就给计数器变量加1，最后输出计数器变量即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取余解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">sum=<span class="number">0</span> <span class="comment">#计数器变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">66</span>,n+<span class="number">1</span>):  <span class="comment">#i至少从66开始才会有2个6，如果小于66，这个循环不会执行</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">6</span>):cnt+=<span class="number">1</span>;</span><br><span class="line">        i=i//<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">2</span>):sum+=<span class="number">1</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串解法</span></span><br><span class="line">n=int(input())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    cnt=str(i).count(<span class="string">'6'</span>)</span><br><span class="line">    <span class="keyword">if</span> cnt==<span class="number">2</span>:</span><br><span class="line">        ans+=<span class="number">1</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-5】巨噬细胞"><a href="#【新生阶段月赛NO-5】巨噬细胞" class="headerlink" title="【新生阶段月赛NO.5】巨噬细胞"></a>【新生阶段月赛NO.5】巨噬细胞</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=4" target="_blank" rel="noopener">传送门:</a></p><p>这题显然对10取余即可，只有（9+1）%10=0，这样正好模拟了向前推一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l=[(int(x)+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> input()]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">    print(l[i],end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="【新生阶段月赛NO-6】压轴：血小板是我的"><a href="#【新生阶段月赛NO-6】压轴：血小板是我的" class="headerlink" title="【新生阶段月赛NO.6】压轴：血小板是我的"></a>【新生阶段月赛NO.6】压轴：血小板是我的</h4><p><a href="http://ojjump.acm-icpc.top:8899/problem.php?cid=1026&amp;pid=5" target="_blank" rel="noopener">传送门:</a></p><p>这题是著名的约瑟夫环问题，有兴趣的孩子可以百度，我这题出的数据特别的小，所以可以用模拟的方法ac，如果数据量大，模拟的方式肯定会超时。</p><p>下面是用递推的方式来解这个问题，<strong>证明过程如下：</strong></p><blockquote><p>令f[n]表示当有n个候选人时，最后当选者的编号。<br>f[1] = 0<br>f[n] = (f[n - 1] + K) mod n</p></blockquote><p>接下来我们用数学归纳法来证明这个递推公式的正确性：</p><p>(1) <strong>f[1] = 0</strong></p><p>显然当只有1个候选人时，该候选人就是当选者，并且他的编号为0。</p><p>(2) <strong>f[n] = (f[n - 1] + K) mod n</strong></p><p>假设我们已经求解出了f[n - 1]，并且保证f[n - 1]的值是正确的。</p><p>现在先将n个人按照编号进行排序：</p><p>那么第一次被淘汰的人编号一定是K-1(假设K &lt; n，若K &gt; n则为(K-1) mod n)。将被选中的人标记为”#”：</p><p>第二轮报数时，起点为K这个候选人。并且只剩下n-1个选手。假如此时把k+1看作0’，k+2看作1’…</p><p>则对应有：</p><p>此时在0’,1’,…,n-2’上再进行一次K报数的选择。而f[n-1]的值已经求得，因此我们可以直接求得当选者的编号s’。</p><p>但是，该编号s’是在n-1个候选人报数时的编号，并不等于n个人时的编号，所以我们还需要将s’转换为对应的s。</p><p>通过观察，s和s’编号相对偏移了K，又因为是在环中，因此得到s = (s’+K) mod n。</p><p>即f[n] = (f[n-1] + k) mod n。</p><p>至此递推公式的两个式子我们均证明了其正确性，则对于任意给定的n，我们可以使用该递推式求得f[n]，写成伪代码为：</p><p>同时由于计算f[i]时，只会用到f[i-1]，因此我们还可以将f[]的空间节约，改进后的代码为：</p><p>该算法的时间复杂度为O(N)，空间复杂度为O(1)。对于N不是很大的数据来说，可以解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n,m=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    s=(s+m)%i  <span class="comment">#循环递推式</span></span><br><span class="line">print(s+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 18级新生赛题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新生赛题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件的基本操作（文件重定向篇）</title>
      <link href="/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="1-文件重定向"><a href="#1-文件重定向" class="headerlink" title="1.文件重定向"></a>1.文件重定向</h4><p>​    平时我们用到的scanf、gets和printf、puts等等，都是从标准输入输出文件中读写。</p><p>​    默认把键盘作为标准输入文件（scanf和gets在其中读取），把屏幕作为标准输出文件（printf和puts）等在其中写入。</p><p>​    当我们需要读取某一个文本文件的内容时，我们就需要用到文件重定向了，将默认的标准输入文件从键盘改成文本文件；或者输入一些字符到文本文件中，将默认的输出文件从屏幕改成文本文件。<br><a id="more"></a></p><hr><h4 id="2-文件重定向读取"><a href="#2-文件重定向读取" class="headerlink" title="2.文件重定向读取"></a>2.文件重定向读取</h4><p>​    step1：用vs2012新建一个工程，在工程目录里面新建一个文本文件，命名为test.txt（名字可以随便命名），在里面输入12 13 14</p><p>​    如下图：</p><p><img src="https://i.loli.net/2018/06/20/5b29cc2e864c8.png" alt="123.png"></p><p>step2：</p><p>使用文件重定向函数freopen来改变标准输入文件。</p><p>freopen函数一共有3个参数，第一个参数是文本文件的路径，第二个参数是读取文件的方式，第三个参数是标准输入流stdin（这个不需要变动）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  <span class="comment">//"r"：表示以只读方式打开test.txt，stdin是标准输入文件</span></span><br><span class="line"> <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//我们可以使用scanf像平时一样读取3个数，只是你可以不用再输入这三个数，因为它会从文件中读取</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"读取的3个数是：%d %d %d\n"</span>,a,b,c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是重定向了标准输入流，该程序会从文本文件中读取3个数字，然后printf打印到屏幕(标准输出流)</p><hr><h4 id="3-文件重定向写入"><a href="#3-文件重定向写入" class="headerlink" title="3.文件重定向写入"></a>3.文件重定向写入</h4><p>​    step1：用vs2012新建一个工程，在工程目录里面新建一个文本文件，命名为test.txt（名字可以随便命名），在里面输入12 13 14</p><p>​    step2：在工程目录里面新建另一个文本文件，命名为test2.txt（名字随便起）里面不输入任何东西。</p><p>​    step3:</p><p>​        使用freopen的只写模式（”w”)写入数据。程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  <span class="comment">//"r"：表示以只读方式打开test.txt，stdin是标准输入文件</span></span><br><span class="line">    freopen(<span class="string">"test2.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//"w": 表示以只写方式打开test2.txt，stdout是标准输出文件</span></span><br><span class="line"> <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//我们可以使用scanf像平时一样读取3个数，只是你可以不用再输入这三个数，因为它会从文件中读取</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="comment">//下面的printf不会再打印在屏幕上，而是会将文字打印到test2.txt文本文件中。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"读取的3个数是：%d %d %d\n"</span>,a,b,c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>本章介绍了基本文件重定向的概念以及如何使用freopen进行读取和写入重定向，下章将会介绍文件指针的概念和基本操作。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>文件的基本操作（文件指针上篇）</title>
      <link href="/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="1-文件指针的定义"><a href="#1-文件指针的定义" class="headerlink" title="1.文件指针的定义"></a>1.文件指针的定义</h4><p>​    在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。</p><p>​    文件指针实际上是系统封装好的一个结构体，里面包含了各种信息，如文件名、文件状态和文件当前位置等信息 （类似光标位置），不用关心内部实现，想具体了解请点击 <a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88/1953678" target="_blank" rel="noopener">文件指针</a>。<br><a id="more"></a></p><hr><h4 id="2-定义文件指针"><a href="#2-定义文件指针" class="headerlink" title="2.定义文件指针"></a>2.定义文件指针</h4><p>fopen函数：打开文件</p><p>用法：fp=fopen（文件路径，“打开方式”） </p><p>fclose函数：关闭文件</p><p>用法：fclose(文件指针名)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>)；<span class="comment">//以只读方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-fscanf函数的用法"><a href="#3-fscanf函数的用法" class="headerlink" title="3.fscanf函数的用法"></a>3.fscanf函数的用法</h4><p>在test.txt文件中提前写入 12 13 14</p><p>fscanf函数：从文件中读取相应内容，类似scanf。</p><p>用法：fscanf（文件指针名，“%d……”，&amp;a，……） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;  <span class="comment">//用来接收文件中的数据</span></span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>)；<span class="comment">//以只读方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-fprintf函数的用法"><a href="#4-fprintf函数的用法" class="headerlink" title="4.fprintf函数的用法"></a>4.fprintf函数的用法</h4><p>fprintf函数：相应内容输出相应内容到文件，类似printf。</p><p>用法：pirntf（文件指针名，“%d……”，a，……） </p><p>在当前目录下准备一个叫test2.txt的空文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>,b=<span class="number">13</span>,c=<span class="number">14</span>;  <span class="comment">//用来接收文件中的数据</span></span><br><span class="line">    FILE *fp;   <span class="comment">//定义一个指针变量，名字叫fp，类型为FILE*</span></span><br><span class="line">    fp=fopen(<span class="string">"test2.txt"</span>,<span class="string">"a"</span>)；<span class="comment">//以只写方式打开当前目录下的文本文件，其他目录下需要加上文件路径</span></span><br><span class="line">   <span class="comment">//上述操作就打开了一个文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"读取到的三个数是：a=%d b=%d c=%d"</span>,a,b,c);</span><br><span class="line">   fclose(fp);   <span class="comment">//关闭一个文件，只有关闭文件或者缓冲区满，文件的内容才会改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5-fgets函数和fputs函数的用法"><a href="#5-fgets函数和fputs函数的用法" class="headerlink" title="5.fgets函数和fputs函数的用法"></a>5.fgets函数和fputs函数的用法</h4><p><strong>fgets函数</strong>：从文件中读取n个字符写入到字符数组中</p><p>用法：fgets（字符数组名，字符串大小，文件指针）</p><p><strong>fputs函数</strong>:字符数组的内容写入到文件中</p><p>用法：fputs（字符数组名，文件指针）</p><p>具体代码不做过多赘述，自己去尝试一下吧。</p><p> <strong>PS：fgets保留了换行符，fputs输出就不会再添加换行符了。</strong></p><hr><p>下章将详细介绍剩余的fwrite和fread函数，以及如何使用文件的基础操作模拟实现一个登陆界面。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>文件的基本操作（概念介绍篇）</title>
      <link href="/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/02/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="1-文件的基本概念（需要理解）"><a href="#1-文件的基本概念（需要理解）" class="headerlink" title="1.文件的基本概念（需要理解）"></a>1.文件的基本概念（需要理解）</h4><p>​    所谓“文件”一般是指存储在外部介质上数据的集合。一批文件是以数据的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存在外部介质上的数据，必须先按文件名找到指定的文件，然后再从该文件中读取数据。 </p><p>​    普通文件是指驻留在磁盘或其它外部介质上的一个有序数据集，可以是源文件、目标文件、可执行程序； 也可以是一组待输入处理的原始数据，或者是一组输出的结果。对于源文件、目标文件、 可执行程序可以称作程序文件，对输入输出数据可称作数据文件。</p><p>　　设备文件是指与主机相联的各种外部设备，如显示器、打印机、键盘等。在操作系统中，把外部设备也看作是一个文件来进行管理，把它们的输入、输出等同于对磁盘文件的读和写。</p><p> 通常把显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的printf,putchar 函数就是这类输出。键盘通常被指定标准的输入文件， 从键盘上输入就意味着从标准输入文件上输入数据。scanf,getchar函数就属于这类输入。<br><a id="more"></a></p><hr><h4 id="2-文件的分类"><a href="#2-文件的分类" class="headerlink" title="2.文件的分类"></a>2.文件的分类</h4><p>　从文件编码的方式来看，文件可分为ASCII码文件和二进制码文件两种。</p><p>　　ASCII文件也称为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如，数5678的存储形式为：<br>ASCII码： 00110101 00110110 00110111 00111000<br>　　　　　↓ 　　　　     ↓　　　   ↓ 　　       ↓<br>十进制码： 5　　　　　6　　　　7　　　　8 共占用4个字节。ASCII码文件可在屏幕上按字符显示， 例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。 由于是按字符显示，因此能读懂文件内容。</p><p>　　二进制文件是按二进制的编码方式来存放文件的。 例如， 数5678的存储形式为： 00010110 00101110只占二个字节。二进制文件虽然也可在屏幕上显示，但其内容无法读懂。C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。</p><p>　</p><p>　　在Ｃ语言中，文件操作都是由库函数来完成的。 在下章将介绍主要的文件操作函数。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>位运算技巧</title>
      <link href="/2018/09/02/bit%20operation/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/09/02/bit%20operation/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h4 id="按位与运算"><a href="#按位与运算" class="headerlink" title="按位与运算"></a>按位与运算</h4><p>​    通常用来将某变量中的某些位清零而保留其他位不变，例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：</p><p>​        n= n &amp; 0xffffff00;</p><p>​    也可以写成：</p><p>​        n &amp; = 0xffffff00;</p><p>​    如果n是short类型的，则只需执行：</p><p>​        n &amp; = 0xff00;    如果要判断一个int型的变量n的第7位（从左往右，从0开始数）是否为1，则只需看表达式 n &amp;0x80的值是否等于0x80即可。<br><a id="more"></a></p><hr><h4 id="按位或运算"><a href="#按位或运算" class="headerlink" title="按位或运算"></a>按位或运算</h4><p>​    通常用来将变量中的某些位置成1，而保留其他位不变，例如，如果需要int型变量n的低8位全置成1，而其余位不变，则可以执行：</p><p>​        n | = 0xff；</p><hr><h4 id="按位异或运算"><a href="#按位异或运算" class="headerlink" title="按位异或运算"></a>按位异或运算</h4><p>​    异或运算的特点是：</p><p>​        a^b==c  那么  c^b ==a   以及  c^a ==b ，此规律可以用来做最简单的快速加密和解密。</p><p>​    且一个数异或另一个数两次，得到的仍为这个数本身：</p><p>​        a ^ b ^ b = a  </p><hr><h4 id="按位非运算"><a href="#按位非运算" class="headerlink" title="按位非运算"></a>按位非运算</h4><p>​    是单目运算，其功能是将操作数中的二进制位中的0变成1,1变成0。</p><p>例如：表达式”~21”是无符号整型数0xffffea，运行下面的语句：</p><pre><code>printf(&quot;%d,%u,%x&quot;,\~21,\~21,~21)；</code></pre><p>​    输入结果是：</p><pre><code>&gt;-22,4294967274,ffffffea</code></pre><hr><h4 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h4><p>​    其计算结果是将左操作数的各二进制位全部左移若干位后得到的值，右操作数指明了要左移的位数，左移时，高位丢弃，右边低位补0，左移运算符不会改变左操作数的值。</p><p>​    例如，常数9有32位，其二进制表示是：</p><p>​        0000 0000 0000 0000 0000 0000 0000 1001</p><p>​    表达式”9&lt;&lt;4”就是将上面的二进制数左移4位，得到：</p><p>​        0000 0000 0000 0000 0000 0000 1001 0000</p><p>​    即为10进制是144。</p><p>实际上，左移1位，就等于是乘以2，左移n位，就是乘以2的n次方，而左移操作比乘法操作快的多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">short</span> n2 =<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> n3 =<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">15</span>;</span><br><span class="line">    n1&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    n2&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    n3&lt;&lt;=<span class="number">15</span>;</span><br><span class="line">    c&lt;&lt;=<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n1="</span>%x,n2=%d,n3=%d,c=%x,c&lt;&lt;<span class="number">4</span>=%d<span class="string">",n1,n2,n3,c,c&lt;&lt;4);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述程序的输出结果是：</p><blockquote><p>n1=78000,n2=-32768,n3=32768,c=c0,c&lt;&lt;4=3072</p></blockquote><hr><p><strong>敲黑板，记重点</strong></p><p>①语句n1&lt;&lt;=15，对n1左移15位，将32位的n1用二进制表示出来后，即可得知新的n1值是0x78000。</p><p>②语句n2&lt;&lt;=15,对n2左移15位，注意n2是short类型的，只有16位，表示为二进制就是0000000000001111，因此左移15位后，一共从左边移出去了（丢弃了）3个1，左移后n2中存放的二进制数就是1000000000000000,由于n2是short类型，此时n2的最高位是1，因此n2实际上表示的是负数，所以在语句中输出为-32768。</p><p>③语句n3&lt;&lt;=15，对n3左移15位，左移后n3存放的二进制数也是1000000000000000，但是由于n3是无符号的，表示的值总是非负数，所以n3输出为32768。</p><p>④c&lt;&lt;=6,对c左移6位，由于c是 unsigned char类型的，一共只有8位，其二进制表示就是00001111，因此左移6位后，就变为11000000，输出十六进制为c0。</p><p>⑤c&lt;&lt;4,表达式计算的过程是首先将c转换成一个int类型的临时变量（32位，用十六进制表示就是00000000000000c0），然后将该临时变量左移4位，得到的结果是十六进制的0000000000000c00,换算成十进制就是3072。（因为占位符为%d，所以会转换成int临时变量）</p><p>⑥表达式c&lt;&lt;4并不会改变c的值，就像c+4不会改变c的值一样。</p><hr><h4 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h4><p>​    右移运算符是双目运算符，其计算结果是把”&gt;&gt;”的左操作数的各二进制位全部右移若干位后得到的值，要移动的位数就是”&gt;&gt;”的右操作数，移出最右边的位全部被丢弃。</p><p>​    对于有符号数，如long、int、short、char类型变量，在右移时，符号位(即最高位)将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时右边高位就补充1，原符号位为0，则右移时高位就补充0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">short</span> n2 =<span class="number">-15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> n3 =<span class="number">0xffe0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">15</span>;</span><br><span class="line">    n1&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">    n2&gt;&gt;=<span class="number">3</span>;</span><br><span class="line">    n3&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">    c&gt;&gt;=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n1=%x,n2=%d,n3=%x,c=%x"</span>,n1,n2,n3,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出结果是：</p><pre><code>&gt;n1=3,n2=-2,n3=ffe,c=1</code></pre><p><strong>敲黑板，记重点</strong></p><p>①执行语句n1&gt;&gt;=2时，n1的值是0xf，右移两位后变成0x3。</p><p>②执行语句n2&gt;&gt;=3时，n2是有符号16位整数，而原来的值为负数，表示成二进制是1111 1111 1111 0001，由于最高位（符号位）是1，右移时仍然在最高位补充1，所以右移完成后其二进制形式是1111 1111 1111 1110，对于一个有符号16位整数来说，这个二进制形式代表-2。</p><p>③执行语句n3&gt;&gt;=4时，n3是无符号的16位整数，原来的值为0xffe0，尽管最高位是1，但由于它是无符号整数，所以右移时高位补充0，因此右移4位后，n3的值变为0xffe。</p><p>④执行语句c&gt;&gt;=3时，c是无符号的，原来的值为0xf，右移三位后自然就变成了1。</p><p>实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。</p><hr><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>​    有两个int类型的变量a和n(0&lt;=n&lt;=31),要求写一个表达式，使该表达式的值和a的第n位相同。</p>]]></content>
      
      <categories>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网原杂项笔记(第4章)</title>
      <link href="/2018/09/02/Other/%E7%BD%91%E5%8E%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/02/Other/%E7%BD%91%E5%8E%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="1-IP地址及其表示方法"><a href="#1-IP地址及其表示方法" class="headerlink" title="1.IP地址及其表示方法"></a>1.IP地址及其表示方法</h4><p>IP地址表示方法{&lt;网络号&gt;,&lt;主机号&gt;}，一共32位。</p><p>注：表示IP地址的时候不允许十进制和二进制混用。<br><a id="more"></a><br>| 地址类型 | 地址范围                    | 网络号 | 主机号 | 网络号二进制表示 |<br>| ——– | ————————— | —— | —— | —————- |<br>| A类      | 1.0.0.0 ~ 126.255.255.255   | 8位    | 24位   | 0                |<br>| B类      | 128.0.0.0 ~ 191.255.255.255 | 16位   | 16位   | 10               |<br>| C类      | 192.0.0.0 ~ 223.255.255.255 | 24位   | 8位    | 110              |<br>| D类      | \                           | \      | \      | 1110             |<br>| E类      | \                           | \      | \      | 1111             |</p><p>从IP地址的结构来看，IP地址不仅仅指明一台主机，而是还指明了主机所连接的网络。</p><hr><h4 id="2-默认路由"><a href="#2-默认路由" class="headerlink" title="2.默认路由"></a>2.默认路由</h4><p>默认路由的地址是0.0.0.0 ，如果配置路由表，把ip地址改成0.0.0.0即可</p><hr><h4 id="3-ARP协议的工作方式"><a href="#3-ARP协议的工作方式" class="headerlink" title="3.ARP协议的工作方式"></a>3.ARP协议的工作方式</h4><p>详见课本P124-P127页</p><hr><h4 id="4-IP数据报的格式"><a href="#4-IP数据报的格式" class="headerlink" title="4.IP数据报的格式"></a>4.IP数据报的格式</h4><p>重点了解内容：</p><p>首部长度、片偏移</p><p>片偏移中：</p><p>MF=1表示还有分片，MF=0表示这已经是若干个数据报分片中的最后一个。</p><p>DF表示不能分片，只有当DF=0才允许分片。</p><hr><h4 id="5-IP分组的转发流程"><a href="#5-IP分组的转发流程" class="headerlink" title="5.IP分组的转发流程"></a>5.IP分组的转发流程</h4><p>详见课本P132-P134页</p><hr><h4 id="6-划分子网"><a href="#6-划分子网" class="headerlink" title="6.划分子网"></a>6.划分子网</h4><p><strong>划分子网的原因：</strong></p><p>①IP空间利用率低</p><p>②给每一个主机分配网络号会造成路由表过大，影响网络性能。</p><p>③两级IP地址不够灵活。</p><p>划分子网后，两级IP地址就变成了三级IP地址，{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><hr><h4 id="7-子网掩码"><a href="#7-子网掩码" class="headerlink" title="7.子网掩码"></a>7.子网掩码</h4><p>使用子网掩码的意义：可以判断网络是否进行了子网划分。</p><p>无论是否划分子网，将子网掩码与IP地址进行与运算，就能立即计算出IP地址的网络地址。</p><p>若IP地址同属于一个子网，则这些IP虽然不同，但与子网掩码做与运算后，都能得出同一个网络地址。</p><hr><h4 id="8-使用子网时的分组转发"><a href="#8-使用子网时的分组转发" class="headerlink" title="8.使用子网时的分组转发"></a>8.使用子网时的分组转发</h4><p>详见课本P140-141页</p><hr><h4 id="9-无分类编址CIDR（构造超网）"><a href="#9-无分类编址CIDR（构造超网）" class="headerlink" title="9.无分类编址CIDR（构造超网）"></a>9.无分类编址CIDR（构造超网）</h4><p><strong>斜线记法</strong></p><p>如128.14.35.7/20 =10000000 00001110 00100011 00000111</p><p>这样，这个地址的最大最小地址可以很快得出：将20位后的位全置为0，即可得到最小地址，全置为1，得到最大地址。</p><p>10000000 00001110 0010 0000 0000 0000  =128.14.32.0</p><p>10000000 00001110 0010 1111 1111 1111  =128.14.47.255</p><hr><p><strong>路由聚合</strong></p><p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合称为路由聚合。</p><p>网络前缀越短，其地址块所包含的地址数就越多。</p><p>具体路由聚合举例：见课本P144页。</p><hr><p><strong>最长前缀匹配</strong></p><p>具体例子见课本P145页。</p><hr><h4 id="10-ICMP报文"><a href="#10-ICMP报文" class="headerlink" title="10.ICMP报文"></a>10.ICMP报文</h4><p><strong>应用：</strong>  </p><p>ping命令：测试连通性<br>tracert命令：跟踪沿途路径</p><hr><h4 id="11-RIP协议（动态路由）"><a href="#11-RIP协议（动态路由）" class="headerlink" title="11.RIP协议（动态路由）"></a>11.RIP协议（动态路由）</h4><p>基于距离的学习过程。</p><p><strong>特点：</strong></p><p>①仅和相邻的路由器交换信息。</p><p>②路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</p><p>③按固定的时间间隔交换路由信息。</p><p>路由表中最重要的信息是：到某个网络的距离（即最短距离），以及应经过的下一跳地址，路由表更新的原则是找出到每个目的网络的最短距离，这种更新算法称为距离向量算法。</p><hr><h4 id="12-距离向量算法"><a href="#12-距离向量算法" class="headerlink" title="12.距离向量算法"></a>12.距离向量算法</h4><p>详见课本P155-P156页。</p><hr><h4 id="13-内部网关协议OSPF"><a href="#13-内部网关协议OSPF" class="headerlink" title="13.内部网关协议OSPF"></a>13.内部网关协议OSPF</h4><p> 基于路由表的查表转发过程。</p><hr><h4 id="14-虚拟专用网VPN（了解）"><a href="#14-虚拟专用网VPN（了解）" class="headerlink" title="14.虚拟专用网VPN（了解）"></a>14.虚拟专用网VPN（了解）</h4><p>  保留地址（私网地址）<br>  10.0.0.0——10.255.255.255<br>  172.16.0.0——172.31.255.255<br>  192.168.0.0——192.168.255.255</p><p>详见课本P185-187页</p><hr><h4 id="15-网络地址转换NAT（了解）"><a href="#15-网络地址转换NAT（了解）" class="headerlink" title="15.网络地址转换NAT（了解）"></a>15.网络地址转换NAT（了解）</h4><p>详见课本P187-P189页</p><hr><h4 id="16-IP地址和物理地址的区别"><a href="#16-IP地址和物理地址的区别" class="headerlink" title="16.IP地址和物理地址的区别"></a>16.IP地址和物理地址的区别</h4><p>为什么要使用这两种不同的地址？ IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。从而把整个因特网看成为一个单一的、抽象的网络在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><hr><h4 id="17-看累了？刷会儿题吧"><a href="#17-看累了？刷会儿题吧" class="headerlink" title="17.看累了？刷会儿题吧"></a>17.看累了？刷会儿题吧</h4><p>推荐习题：</p><p>4-07、4-09、4-10 、4-17 、4-18 、4-19 、4-20 、 4-21 、4-22 、4-26、4-27 、4-29 、4-30 、</p><p>4-31、4-34、4-35 、4-37 、4-41 、4-42 、4-47 、4-48  、4-49 、4-51、4-52 、4-54 、4-55、</p><p>4-56、4-58。</p><hr>]]></content>
      
      
    </entry>
    
    <entry>
      <title>网络原理笔记(1-3章)</title>
      <link href="/2018/09/02/Other/%E7%BD%91%E5%8E%9F%E7%AC%94%E8%AE%B0(1-3%E7%AB%A0)/"/>
      <url>/2018/09/02/Other/%E7%BD%91%E5%8E%9F%E7%AC%94%E8%AE%B0(1-3%E7%AB%A0)/</url>
      <content type="html"><![CDATA[<h4 id="0-考试题型"><a href="#0-考试题型" class="headerlink" title="0.考试题型"></a>0.考试题型</h4><p>1.选择10题，2分<br>2.填空10空，1分<br>3.简答4题，每题5分<br>4.综合设计，5道题，50分。</p><p>综合设计题：<br>①给一个场景，根据所学去设计解决方案。<br>②抓取真实的网络数据，对其进行分析。<br><a id="more"></a></p><hr><h4 id="1-三种交换方式的对比"><a href="#1-三种交换方式的对比" class="headerlink" title="1.三种交换方式的对比"></a>1.三种交换方式的对比</h4><p>（1）电路交换</p><p>优点：建立连接使得所需通信资源得到可靠保障，连续传送大量数据时效率高。</p><p>缺点：电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。</p><p>适用场合：适合于数据量很大的实时性传输，核心路由之间可以使用电路交换。</p><p>（2）报文交换</p><p>优点：无须预约传输带宽，动态逐段利用传输资源，整个报文采用存储—转发的思想，对突发式数据通信效率高，通信迅速。</p><p>缺点：存在存储转发时延。</p><p>适用场合：突发性的数据，且端到端的通路有很少段的链路组成时，采用报文交换传送数据较为合适。</p><p> （3）分组交换</p><p>优点：具有报文交换之高效、迅速的优点，且各分组小，路由灵活，网络生存性能好。</p><p>缺点：存储转发时延以及额外的开销</p><p>适用场合：突发性的数据，且端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。</p><hr><h4 id="2-网络排错"><a href="#2-网络排错" class="headerlink" title="2.网络排错"></a>2.网络排错</h4><p>根据五层协议体系结构，由低层到高层依次排查错误：</p><p>物理层：检测网线是否破损，水晶头是否接触不良，网卡是否被禁用</p><p>链路层：检测MAC地址是否有效（MAC地址认证、MAC地址修改）</p><p>网络层：检测IP地址、网关、子网掩码是否正确配置</p><p>传输层：端口是否被禁用</p><p>应用层：检测DNS是否正确配置，浏览器是否设置代理</p><hr><h4 id="3-四种时延"><a href="#3-四种时延" class="headerlink" title="3.四种时延"></a>3.四种时延</h4><p><img src="https://i.loli.net/2018/07/05/5b3dca4a2de70.png" alt="1.png"></p><p>时延的计算：</p><p>​    发送时延=数据帧长度(bit)/发送速率（bit/s)</p><p>​    传播时延=信道长度(bit)/电磁波在信道上的传播速率（m/s)</p><p>​    时延带宽积= 传播时延*带宽</p><p><strong>注：发送时延和信道的长度无关，而传播时延与发送速率无关</strong></p><hr><h4 id="4-往返时间RTT和有效数据率"><a href="#4-往返时间RTT和有效数据率" class="headerlink" title="4.往返时间RTT和有效数据率"></a>4.往返时间RTT和有效数据率</h4><p>发送时间=数据长度/发送速率</p><p>有效数据率=数据长度/(发送时间+RTT)</p><p><strong>注：RTT题目会给出</strong></p><hr><h4 id="5-计算机网络五层模型"><a href="#5-计算机网络五层模型" class="headerlink" title="5.计算机网络五层模型"></a>5.计算机网络五层模型</h4><p><strong>①应用层</strong>：通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。</p><p>应用层交互的数据单元称为：<strong>报文</strong>。</p><p><strong>重要协议：</strong> DNS协议、HTTP协议、STMP协议</p><hr><p><strong>②运输层：</strong>负责向两台主机中进程之间的通信提供通用的数据传输服务。具有复用和分用的功能。</p><p><strong>重要协议</strong>：TCP协议和UDP协议</p><hr><p><strong>③网络层</strong>：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。</p><p>网络成的交互数据单元称为：<strong>IP数据报或数据报（分组和数据报同义）</strong></p><p><strong>重要协议</strong>：TCP/IP协议</p><p><strong>网络层设备：</strong>路由器</p><hr><p><strong>④数据链路层：</strong>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。在两个相邻结点直接传输数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点的链路上传送帧。</p><p>数据链路层的交互数据单元称为：<strong>帧</strong></p><p><strong>重要协议：</strong>PPP协议和 CSMA/CD协议</p><p><strong>数据链路层设备：</strong>交换机（网桥）</p><hr><p><strong>⑤物理层：</strong>物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。在物理层上所传数据的的单位是比特。</p><p><strong>物理层的设备：</strong>集线器（内部是总线型结构）</p><hr><h4 id="6-物理层的四个特性"><a href="#6-物理层的四个特性" class="headerlink" title="6.物理层的四个特性"></a>6.物理层的四个特性</h4><p> 机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<br> 电气特性：指明在接口电缆的各条线上出现的电压的范围。<br> 功能特性：指明某条线上出现的某一电平的电压表示何意。<br> 过程特性：指明对于不同功能的各种可能事件的出现顺序。 </p><hr><h4 id="7-数字信号和模拟信号"><a href="#7-数字信号和模拟信号" class="headerlink" title="7.数字信号和模拟信号"></a>7.数字信号和模拟信号</h4><p>数字信号：代表消息参数的取值是离散的</p><p>模拟信号：代表消息的参数取值是连续的</p><hr><h4 id="8-三种通信方式"><a href="#8-三种通信方式" class="headerlink" title="8.三种通信方式"></a>8.三种通信方式</h4><p>单向通信：又叫单工通信，只能发送而不能收到回馈，入电视，广播等。</p><p>双向交替通信：又叫半双工通信，双方都能发送信息，只是一方发送时另一方不能发送。</p><p>双向同时通信：又叫全双工通信，双方可以同时发送和接受信息。</p><hr><h4 id="9-码元的概念"><a href="#9-码元的概念" class="headerlink" title="9.码元的概念"></a>9.码元的概念</h4><p>码元：一码元可以携带n比特的信息，n的取值和码元的状态数相关。</p><p> 码元的传输速率（波特）与比特速率（bps或者b/s）的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Baud = log2M (bit/s)</span><br><span class="line">其中M是信号的编码数。也可以写成:Rbit = Rbaud log2M，上式中：Rbit-比特率，Rbaud-波特率。</span><br></pre></td></tr></table></figure><hr><h4 id="10-曼彻斯特和差分曼彻斯特编码"><a href="#10-曼彻斯特和差分曼彻斯特编码" class="headerlink" title="10.曼彻斯特和差分曼彻斯特编码"></a>10.曼彻斯特和差分曼彻斯特编码</h4><p>曼彻斯特：从低跳变到高代表0，从高跳变到低代表1。（bit和bit之间无跳转）</p><p>差分曼特斯特:跳变要看前一位bit，跳转代表0，不跳转代表1。(bit和bit之间有跳转)，且第一位是不确定的。</p><hr><h4 id="11-奈氏准则和香农公式"><a href="#11-奈氏准则和香农公式" class="headerlink" title="11.奈氏准则和香农公式"></a>11.奈氏准则和香农公式</h4><p><strong>奈奎斯特</strong>(Nyquist)推导出在理想低通信道下的最高码元传输速率的公式:</p><p>理想低通信道的最高码元传输速率 = 2W Baud</p><p>这里W是理想低通信道①的带宽,单位为赫(Hz);</p><p>Baud是波特,是码元传输速率的单位,1波特为每秒传送1个码元.</p><p>再根据香农公式推导出：C=2W*log₂(M)</p><p>其中，C为数据传输速率，W为带宽，单位HZ，M为信号状态数</p><p>上式就是著名的奈氏准则.奈氏准则的另一种表达方法是:每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元.</p><hr><p><strong>香农公式：</strong></p><p>C=W*log₂（1+S/N) （bit/s)<br>该式通常称为香农公式。C是码元速率的极限值(W为信道带宽，单位Bit/s)；S是信号功率（瓦），N是噪声功率（瓦）。<br>香农公式中的S/N是为信号与噪声的功率之比，为无量纲单位。如：S/N=1000（即，信号功率是噪声功率的1000倍）<br>但是，当讨论信噪比时，常以分贝（dB）为单位。公式如下：<br>SNR（信噪比，单位为dB)=10 lg（S/N)<br>换算一下：<br>S/N=10^(SNR/10）</p><hr><h4 id="12-信道复用技术"><a href="#12-信道复用技术" class="headerlink" title="12.信道复用技术"></a>12.信道复用技术</h4><p>频分复用：像大厅中不同的人同时用不同的语言交流</p><p>时分复用：像大厅中不同的人按一定的时间周期讲话。</p><p>统计时分复用：加了一个集中器，同时连接多个低速用户， 在时分复用的基础上，用户发送来的数据就收集起来，当缓存满了就发送出去，这样可以提高利用率。</p><p>波分复用：光的频分复用</p><p>码分复用：利用向量的叠加性原理来计算规格化内积。</p><hr><h4 id="13-数据链路层的基本问题"><a href="#13-数据链路层的基本问题" class="headerlink" title="13.数据链路层的基本问题"></a>13.数据链路层的基本问题</h4><p>三个基本问题<br>封装成帧：在一段数据的前后分别添加首部和尾部。</p><p>透明传输：让所有的信息都能传输，使用字节填充（转义字符）</p><p>帧的定界符：SOH和EOT，表示帧开始和帧结束。</p><p>他们的16进制编码分别为01（00000001）和04（000001000）。</p><p>转义符ESC：十六进制编码为(1B)</p><p>差错检测：CRC检测的计算。</p><hr><h4 id="14-ppp协议（点对点协议）"><a href="#14-ppp协议（点对点协议）" class="headerlink" title="14.ppp协议（点对点协议）"></a>14.ppp协议（点对点协议）</h4><p>PPP协议的首部：7E FF 03 协议 </p><p>PPP协议的尾部：FCS 7E </p><p>7E: 标志着一个帧的开始或结束，为定界符，若出现两个标志字段，这表示这是一个空帧，应当丢弃。</p><p>FF:为地址字段。</p><p>0x03：为控制字段。</p><p>协议字段：2个字节。</p><p>数据部分：不能超过1500字节。</p><p>FCS：帧检验序列，2个字节。</p><hr><p><strong>字节填充</strong>（实现透明传输）</p><p>信息字段中如果有7E，则加上转义字符0x7D，并使用字节填充。</p><p>①若出现0x7E，则填充为（0x7D，0x5E）</p><p>②若出现0x7D，则填充为(0x7D, 0x5D)</p><p>③若出现ASCII码的控制字符（数值小于0x20），则在前面加一个0x7D的字节，并把编码加以改变，例如，出现0x03，则把他们转变为(0x7D,0x23)  加20。</p><hr><p><strong>零比特填充</strong></p><p>如果发现5个连续的1，立即插入一个0，这样就保证不会出现6个连续的1，接收端在进行扫描时，如果发现5个连续的1，就把5个1后的1个0删除，以还原成原来的信息。</p><hr><h4 id="15-CSMA-CD协议"><a href="#15-CSMA-CD协议" class="headerlink" title="15.CSMA/CD协议"></a>15.CSMA/CD协议</h4><p><strong>碰撞检测</strong></p><p>争用期（Contention Period）就是以太网端到端往返时间2τ，又称为碰撞窗口（Collision Window）。 在局域网的分析中，常把总线上的单程端到端传播时延记为τ。通常取51.2微秒为争用期时间，对于10Mb/s以太网，期间可以发送512bit数据，即64字节。</p><p>CSMA/CD协议的最短数据帧长(bit):2倍信号传播时延(s)*数据传输速率(bps)=</p><p>2<em>(   两点的距离(m)    /（信号传播速率\</em>数据传输速率)     )</p><hr><p><strong>极限信道利用率</strong></p><p>Smax = 1 / (1+a)  其中a为( τ / T0)  τ为单程端时延，T0为帧的发送时间</p><hr><h4 id="16-MAC地址"><a href="#16-MAC地址" class="headerlink" title="16.MAC地址"></a>16.MAC地址</h4><p>硬件地址又称为物理地址或mac地址，全球统一，48位。</p><p>目标mac地址全为1即为广播地址。</p><p>查看mac地址的方法：ipconfig -all。</p><hr><h4 id="17-以太网交换机学习功能"><a href="#17-以太网交换机学习功能" class="headerlink" title="17.以太网交换机学习功能"></a>17.以太网交换机学习功能</h4><p>基于源mac地址的学习，记录在交换机的交换表中。具体见课本p100页</p><hr><h4 id="18-看累了刷会儿题吧"><a href="#18-看累了刷会儿题吧" class="headerlink" title="18.看累了刷会儿题吧"></a>18.看累了刷会儿题吧</h4><p>第一章推荐习题：1-03 、 1-05  、 1-10  、1-13   、1-15  、 1-17  、1-19  、1-22 、1 -29</p><p>第二章推荐习题：2-07 、 2-08  、 2-09  、2-13   、2-16</p><p>第三章推荐习题：3-07 、 3-08  、 3-09  、3-10   、3-20  、 3-22  、3-33</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>算法学习：深度优先搜索DFS(一)</title>
      <link href="/2018/09/02/Search/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/09/02/Search/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>南阳理工学院校园里有一些小河和一些湖泊，现在，我们把它们通一看成水池，假设有一张我们学校的某处的地图，这个地图上仅标识了此处是否是水池，现在，你的任务来了，请用计算机算出该地图中共有几个水池。</p></blockquote><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>第一行输入一个整数N，表示共有N组测试数据<br>每一组数据都是先输入该地图的行数m(0&lt;m&lt;100)与列数n(0&lt;n&lt;100)，<br>然后，输入接下来的m行每行输入n个数，表示此处有水还是没水（1表示此处是水池，0表示此处是地面）</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>输出该地图中水池的个数。<br>要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2<br>3 4<br>1 0 0 0<br>0 0 1 1<br>1 1 1 0<br>5 5<br>1 1 1 1 0<br>0 0 1 0 1<br>0 0 0 0 0<br>1 1 1 0 0<br>0 0 1 1 1</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>3</p></blockquote><hr><p>这题是一道简单的dfs题目，dfs题，说白了就是暴力搜索的优化版本，属于不撞南墙不回头的算法，除非有东西阻挡，不然就会一直往下走，直到走完为止。</p><p>这题是求水池数目，我们可以用dfs对每个点的上下左右进行搜索，如果某个点的上下左右(某一个或多个)为1，则把这个点设置成0,一趟搜索来，我们可以把跟这个点连接的水池全部标记为0，然后给计数器变量加1，代表这整个为1个水池。只要对所有点都进行一遍dfs，则可以求出所有水池数目。</p><p><strong>技巧：</strong><br>①我们不用二维数组的第一行和第一列，并且将二维数组设置为num[105][105]，这样既可以防止数组越界，又可以用第1和101行已经第1列和101列来作为外围边界。<br>②初始时将二维数组全部设置为0，这样外围就存在边界了。<br>③将数组定义在外部，这样可以使dfs无序传数组的参数进入。<br><strong>Coding：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">using namespace std;</span><br><span class="line">int arr[N][N];</span><br><span class="line"></span><br><span class="line">void dfs(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    if(arr[a-1][b]==1)&#123;arr[a-1][b]=0,dfs(a-1,b);&#125;  //向上搜索</span><br><span class="line">    if(arr[a+1][b]==1)&#123;arr[a+1][b]=0,dfs(a+1,b);&#125;  //向下搜索</span><br><span class="line">    if(arr[a][b-1]==1)&#123;arr[a][b-1]=0,dfs(a,b-1);&#125;  //向左搜索</span><br><span class="line">    if(arr[a][b+1]==1)&#123;arr[a][b+1]=0,dfs(a,b+1);&#125;  //向右搜索</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)</span><br><span class="line">                cin&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(arr[i][j]==1)   //代表此点为水池</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    dfs(i,j);     //将与该水池相邻的水池都标记为0</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> dfs 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习：深度优先搜索DFS(二)</title>
      <link href="/2018/09/02/Search/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(2)/"/>
      <url>/2018/09/02/Search/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(2)/</url>
      <content type="html"><![CDATA[<p>##Oil Deposits</p><blockquote><p>Problem Description<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.</p></blockquote><a id="more"></a><blockquote><p>Input<br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either \’*’, representing the absence of oil, or ‘@’, representing an oil pocket.</p></blockquote><blockquote><p>Output<br>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p></blockquote><blockquote><p>Sample Input<br>1 1<br><em><br>3 5</em>@<em>@</em><br><strong>@</strong><br><em>@</em>@<em><br>1 8<br>@@<em>**</em>@</em><br>5 5<br><strong>*<em>@</em>@@<em>@</em>@</strong>@<br>@@@*@<br>@@**@<br>0 0 </p></blockquote><blockquote><p>Sample Output<br>0<br>1<br>2<br>2</p></blockquote><hr><p><strong>Thinking：</strong><br>这题是刚才那道水池问题的升级版，只不过这次是向八个方向搜索，根据水池那题的思路，我们可以得到一种代码，还有另一种使用二维向量和循环的方法，使代码更加简洁，这里两种方法都附上。</p><p><strong>Code1:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归出口判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[a][b]!=<span class="string">'@'</span>||a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&gt;n<span class="number">-1</span>||b&gt;m<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(judge(a,b))<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    arr[a][b]=<span class="string">'*'</span>;</span><br><span class="line">    <span class="comment">//向八个方向搜索</span></span><br><span class="line">    dfs(a<span class="number">-1</span>,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a<span class="number">-1</span>,b);</span><br><span class="line">    dfs(a<span class="number">-1</span>,b+<span class="number">1</span>);</span><br><span class="line">    dfs(a,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a,b+<span class="number">1</span>);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b<span class="number">-1</span>);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b);</span><br><span class="line">    dfs(a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m &amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'@'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Code2:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[a][b]!=<span class="string">'@'</span>||a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&gt;n<span class="number">-1</span>||b&gt;m<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(judge(a,b))<span class="keyword">return</span> ;</span><br><span class="line">    arr[a][b]=<span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(a+moves[i][<span class="number">0</span>],b+moves[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m &amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]==<span class="string">'@'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> dfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组和指针(一)</title>
      <link href="/2018/09/02/C/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/"/>
      <url>/2018/09/02/C/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h4 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h4><p>​    数组的下标可以是任意整数，可以是负数，也可以大于等于数组的元素个数，还能是小数（截取整数部分），如果出现这以下的情况，编译的时候也不会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> an[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) an[<span class="number">-2</span>]=<span class="number">5</span>;</span><br><span class="line">(<span class="number">2</span>) an[<span class="number">200</span>]=<span class="number">10</span>;</span><br><span class="line">(<span class="number">3</span>) an[<span class="number">10</span>]=<span class="number">20</span>;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">int</span> m =an[<span class="number">30</span>];</span><br></pre></td></tr></table></figure><p>这些语句的语法都没有任何问题，编译的时候也不会报错，那么an[-2]是什么含义呢？</p><p>它表示，数组an的起始地址为n，那么a[-2]就代表位于地址 n+(-2)*sizeof(int)处的一个int类型变量，即位于n-8处的一个int型变量。地址n-8处，可能存放的是其他变量，也可能存放的是其他指令，往该处写入数据，就可能意外更改其他变量的值，甚至更改程序的指令，程序继续运行就有可能出错。</p><p>向上述这些情况，就成为数组越界，语句4使m被赋了一个不可预料的值，在有的操作系统中，程序的某些内存区域是不能读取的，如果an[30]正好位于这样的区域，执行到语句(4)就会立即引发错误。</p><p>如果数组越界导致指令被修改的话，甚至会导致在调试器里调试的时候，程序不按照应当的次序运行的怪现象。比如单步调试程序的时候，明明碰到一个条件为真的if语句，却没有执行那个为真的分支。</p><hr><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>​    在32位系统中，指针是4个字节的，在64位系统中，指针是8个字节的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p =（<span class="keyword">int</span>*)<span class="number">10000</span>；<span class="comment">//这个指针的内容就代表内存地址10000，也可以说p指向内存地址10000</span></span><br><span class="line"><span class="comment">//上述语句执行后，如果想对内存地址10000起始的若干字节进行读写，就通过表达式"*p"来进行，因为表达式"*p"就代表地址p开始的若干字节。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*p = <span class="number">5000</span>；  <span class="comment">//往内存地址10000处的若干字节的内存空间里写入数值5000</span></span><br><span class="line"><span class="keyword">int</span> n =*p;  <span class="comment">//将内存地址10000处起始的若干字节的内容赋值给n，实际效果是使得n=5000</span></span><br></pre></td></tr></table></figure><p>显然，从等号两边的表达式类型应该兼容可以推想出，表达式”*p”的类型应该是int。</p><p>这里的若干字节就是一个int的所占的字节，sizeof(int)=4</p><blockquote><p>T * p;   // T可以是任意类型的名字，例如double，int，char等，下文碰到的T都是这个意思</p></blockquote><p>那么变量p就是一个指针变量（简称指针），p的类型 是T<em>，表达式”T\</em>“的类型是T。而通过表达式”*p”,我们就可以读写从地址p开始的size(T)个字节。</p><p><strong>敲黑板，记笔记</strong></p><p>​    通俗的说，可以认为，表达式”<em>p”可以等价于存放在地址p处的一个T类型的变量，表达式”\</em>P”中的”*“被称作间接引用运算符。</p><p>​    需要记住的是，不论T是什么类型，sizeof(T*)的值都是4或者8，一般来说编译器都是4个字节。</p><p>​    记住，对于类型为T的变量x，表达式”&amp;x”就表示变量x的地址，表达式”&amp;x”的类型是T *。</p><h5 id="不同类型的指针是不能直接进行赋值的"><a href="#不同类型的指针是不能直接进行赋值的" class="headerlink" title="不同类型的指针是不能直接进行赋值的"></a>不同类型的指针是不能直接进行赋值的</h5><p>​    不同类型的指针，如果不经过强制类型转换，是不能直接互相赋值的，如下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">int</span> * pn, <span class="keyword">char</span> *pc, <span class="keyword">char</span> c =<span class="number">0x65</span>;</span><br><span class="line">(<span class="number">2</span>)pn = pc;</span><br><span class="line">(<span class="number">3</span>)pn =&amp; c;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">int</span> n =*pn;</span><br><span class="line">(<span class="number">5</span>) *pn = <span class="number">0x12345678</span>;</span><br></pre></td></tr></table></figure><p>​    语句2和语句3都会在编译的时候保存，错误信息是类型不兼容，因为在这两条语句中，等号左边的类型是int <em>，而等号右边的类型是 char </em>。语句4则没有问题，虽然表达式”&amp;c”的类型是char *,但是其值经过强制类型转换后，赋给pn是可以的，语句4执行的效果是使得pn指向c的地址。</p><p>​    思考题：语句5的执行效果是使得n的值变为0x65吗，语句6编译会不会出错？如果不出错，执行后会有什么结果呢？会不会有问题？</p>]]></content>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表的基本操作（整表删除篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>注：<strong>这里跟上篇一样，均未写释放链表的操作，以后内容将补上</strong></p><p>当我们不打算在使用这个单链表时，我们需要把它销毁，思路如下：<br><a id="more"></a><br>①声明一个结点p和q；</p><p>②将第一个结点赋值给p；</p><p>③循环：</p><p>​    (1)将下一个结点赋值给q；</p><p>​    (2)释放p；</p><p>​    (3)将q赋值给p。</p><p>具体实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearList</span><span class="params">(Node **L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=(*L)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//头结点的指针域设为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head,*p;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"遍历链表：\n"</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    ClearList(&amp;head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（删除结点篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%A0%E9%99%A4%E7%AF%87)%20/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%A0%E9%99%A4%E7%AF%87)%20/</url>
      <content type="html"><![CDATA[<p>下面代码演示了一下如何:</p><p><strong>删除链表中的某一个元素</strong></p><p>注：<strong>这里跟上篇一样，均未写释放链表的操作，以后内容将补上</strong></p><p>用一级指针和二级指针的区别：</p><p>一级指针：传入一个地址，我们可以对地址上的值进行修改。但如果是一个空指针，你在函数内为之开辟空间是无法带回函数外部的。</p><p>二级指针：传入一个指针的地址，此时指针是作为地址上的值让我们修改的。</p><blockquote><p>传入一级指针如果只是删除添加除头结点以外的结点是可以的，但是删除和插入有可能需要修改头结点，这时需要传入二级指针来修改指向头结点的指针指向的位置。<br><a id="more"></a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单链表中的某一个结点</span></span><br><span class="line"><span class="comment">/*Node **为指向头结点的指针，i为删除结点的位置，然后把元素值放入e中*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(Node **L,<span class="keyword">int</span> i,<span class="keyword">int</span> *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=*L;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;   <span class="comment">//当j小于i时，让p的指针向后移动，若到链表末尾p为空，则说明第i个结点不存在</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)&#123;  <span class="comment">//如果p指向的节点为NULL则说明下一个节点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);   <span class="comment">//在内存中删除此结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    ListDelete(&amp;head,<span class="number">3</span>,&amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"被删除的元素的值为：%d\n"</span>,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"遍历链表:\n"</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">include &lt;stdlib.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    Node *next;  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"遍历链表:\n"</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序输出结果：</p><p>被删除的元素的值为：2<br>遍历链表:<br>0<br>1<br>3<br>4</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（链表逆序篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%AF%87)%20%20/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%AF%87)%20%20/</url>
      <content type="html"><![CDATA[<p>思路：</p><p>​    假设当前创建好的链表如下：<br><a id="more"></a><br><img src="https://i.loli.net/2018/07/01/5b38c536514ee.png" alt="1.png"></p><p>首先让头节点与第一个元素节点断开，但是要注意在断开之前需要用p指针指向第一个元素节点来保存第一个元素节点的位置，然后再断开。在这里有一个指针q指向一个指针域为空的节点，这个节点用来做为链表反转后的最后一个节点。</p><p><img src="https://i.loli.net/2018/07/01/5b38c536514f9.png" alt="2.png"></p><p>让第二个元素节点的指针从指向第三个元素节点变为指向第一个元素节点，以此类推，直至指针p指向原链表最后一个元素。<br><!-- more --><br><img src="https://i.loli.net/2018/07/01/5b38c5365dbc4.png" alt="3.png"><br><img src="https://i.loli.net/2018/07/01/5b38c5365db37.png" alt="4.png"><br><img src="https://i.loli.net/2018/07/01/5b38c5365dc04.png" alt="5.png"></p><p>p指针指向NULL时，让原头节点的指针域指向原来最后一个元素节点。此时链表倒置已完成。</p><p><img src="https://i.loli.net/2018/07/01/5b38c5365d9fd.png" alt="6.png"></p><p>实现代码：</p><p>两种方法：迭代版和递归版（了解即可）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*link;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代版本：翻转链表</span></span><br><span class="line"><span class="comment">//传入头结点的写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(link head)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link  p,q,r;</span><br><span class="line">    p=head-&gt;next;</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        r=p-&gt;next;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        q=p;    </span><br><span class="line">        p=r;        </span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本：翻转链表</span></span><br><span class="line"><span class="comment">//如果使用头结点，则传入第一个结点，因为头结点不能去翻转</span></span><br><span class="line"><span class="comment">//如果使用头指针，则直接传入头指针即可</span></span><br><span class="line"><span class="function">link <span class="title">reverseList</span><span class="params">(link h)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!h||!(h-&gt;next))<span class="keyword">return</span> h;</span><br><span class="line">    link first =reverseList(h-&gt;next);</span><br><span class="line">    h-&gt;next-&gt;next=h;</span><br><span class="line">    h-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(link head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    link p,q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link head=(link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    head-&gt;next=reverseList(head-&gt;next);</span><br><span class="line">    PrintList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（获取元素篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%89/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>获取链表中的某一个结点的值的函数，还是固定使用尾插法，且没有free链表的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表中第i个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem</span><span class="params">(Node* L ,<span class="keyword">int</span> i,<span class="keyword">int</span>* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    Node* p;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123; <span class="comment">//p不为空，且计数器小于j时，执行循环</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *e =p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    GetElem(head,<span class="number">2</span>,&amp;e);   <span class="comment">//获取链表中的第二个结点的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,e);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（读取篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E8%AF%BB%E5%8F%96%E7%AF%87)/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E8%AF%BB%E5%8F%96%E7%AF%87)/</url>
      <content type="html"><![CDATA[<p>下面代码演示了一下如何:</p><p><strong>遍历整个链表</strong></p><p>注：<strong>这里跟上篇一样，均未写释放链表的操作，以后内容将补上</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p=L;</span><br><span class="line">    p=p-&gt;next;     <span class="comment">//使p指向第一个节点，p本来是头结点，头结点里面不含数据</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"遍历链表:\n"</span>);</span><br><span class="line">    PrintList(head);</span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（初始化篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>底下是使用头插法和尾插法进行链表初始化的函数，并比较了两种插入的不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的头插法（即每次插入结点都在开头,在head与第一个节点之间插入）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Node*head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=i;       <span class="comment">//数据域赋值为i的值</span></span><br><span class="line">        p-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//初始化两个头结点</span></span><br><span class="line">   Node *head,*head1,*p;</span><br><span class="line">   head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   head1=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   head1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//头插法创建5个结点的链表</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"头插法创建5个结点的链表\n"</span>);</span><br><span class="line">   create(head,<span class="number">5</span>);</span><br><span class="line">   <span class="comment">//打印链表1</span></span><br><span class="line">   p =head-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"----------------------------\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"尾插法创建5个结点的链表\n"</span>);</span><br><span class="line">   create2(head1,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印链表2</span></span><br><span class="line">   p =head1-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>链表的基本操作（插入结点篇）</title>
      <link href="/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8F%92%E5%85%A5%E7%AF%87)/"/>
      <url>/2018/09/02/list/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8F%92%E5%85%A5%E7%AF%87)/</url>
      <content type="html"><![CDATA[<p><strong>在链表的某一个位置插入一个结点</strong>，同样，未写出free链表的函数</p><p>用一级指针和二级指针的区别：</p><p>一级指针：传入一个地址，我们可以对地址上的值进行修改。但如果是一个空指针，你在函数内为之开辟空间是无法带回函数外部的。</p><p>二级指针：传入一个指针的地址，此时指针是作为地址上的值让我们修改的。</p><blockquote><p>传入一级指针如果只是删除添加除头结点以外的结点是可以的，但是删除和插入有可能需要修改头结点，这时需要传入二级指针来修改指向头结点的指针指向的位置。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">//数据域为int类型的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，每次在链表末尾插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create2</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        q=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data=i;</span><br><span class="line">        q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表中的某一个位置插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Node **L,<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span>   <span class="comment">//head为头结点，i为要插入的位置，e为要插入的int类型数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    Node *p,*s;</span><br><span class="line">    p=*L;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)<span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果p为空或者j大于了i，则说明插入失败</span></span><br><span class="line">    s=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head,*p;</span><br><span class="line">    head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    create2(head,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//向链表的第3个位置插入一个元素6</span></span><br><span class="line">    ListInsert(&amp;head,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">    p=head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入后,新链表为:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>插入后,新链表为:<br>0<br>1<br>6<br>2<br>3<br>4</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>html知识点总结(1-3章)</title>
      <link href="/2018/09/02/WEB/html%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(1-3%E7%AB%A0)/"/>
      <url>/2018/09/02/WEB/html%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(1-3%E7%AB%A0)/</url>
      <content type="html"><![CDATA[<h4 id="1-万维网的概念"><a href="#1-万维网的概念" class="headerlink" title="1.万维网的概念"></a>1.万维网的概念</h4><p>​    万维网（亦作“Web”、“WWW”、全称为“World  Wide Web”），是一个由许多互相链接的超文本组成的系统，通过互联网访问。 </p><hr><h4 id="2-网站访问的过程"><a href="#2-网站访问的过程" class="headerlink" title="2.网站访问的过程"></a>2.网站访问的过程</h4><p>网站是一种典型的B/S架构，即客户端（浏览器）和服务端（服务器）</p><p>B/S架构：通过浏览器访问的网络应用程序。 </p><p>Web浏览器（<strong>客户端</strong>）：</p><p>​    ①显示网页内容，并让用户与这些文件交互的一种软件。    </p><p>​    ②常用浏览器：谷歌浏览器（Chrome）、火狐（Firefox）、 IE 浏览器等等。</p><p>Web服务器（<strong>服务端</strong>）：</p><p>​    ①物理设备：提供Web服务的计算机。</p><p>​    ②软件：根据用户请求将信息资源传递给用户的应用程序。</p><p>​    ③常用Web服务器：Apache和ngix服务器。</p><hr><h4 id="3-URL（Uniform-Resource-Locator-统一资源定位符）"><a href="#3-URL（Uniform-Resource-Locator-统一资源定位符）" class="headerlink" title="3.URL（Uniform Resource Locator 统一资源定位符）"></a>3.URL（Uniform Resource Locator 统一资源定位符）</h4><p>定义：互联网上标准的资源的地址。</p><p>示例如下：</p><p>•<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></p><p>•<a href="http://tech.sina.com.cn/it/2015-01-14/doc-iavxeafr9972646.shtml" target="_blank" rel="noopener">http://tech.sina.com.cn/it/2015-01-14/doc-iavxeafr9972646.html</a></p><p>组成部分：协议、服务器地址（域名）、资源路径 </p><p><img src="https://i.loli.net/2018/06/12/5b1fbf86e849d.png" alt="1.png"></p><hr><h4 id="4-B-S架构和C-S架构的区别"><a href="#4-B-S架构和C-S架构的区别" class="headerlink" title="4.B/S架构和C/S架构的区别"></a>4.B/S架构和C/S架构的区别</h4><p>B/S架构：通过浏览器访问的网络应用程序。 它通过浏览器访问的网络应用程序。 </p><p>如：百度、淘宝、京东等网站</p><p>特点：</p><p>①无需安装特定客户端程序，通过URL访问。</p><p>②跨平台能力（Windows、Linux、Android、IOS…）。</p><p>③无缝升级，客户端免维护。</p><p>④不能直接使用客户端硬件资源，用户体验单一。</p><p>C/S架构（Client/Server）它通过客户端应用软件访问的网络应用程序。</p><p>如：QQ、微信等应用。 </p><p>特点：</p><p>①需要安装特定客户端程序。</p><p>②针对不同平台开发不同版本。</p><p>③升级应用须重新安装。</p><p>④能够直接使用客户端硬件资源。</p><hr><h4 id="5-网站浏览过程"><a href="#5-网站浏览过程" class="headerlink" title="5.网站浏览过程"></a>5.网站浏览过程</h4><ol><li>通过输入网址（URL）指定要访问的网页 。</li><li>请求：把XXX网页文件传送给我。（浏览器把请求发送给服务器）</li><li>响应：把XXX网页文件传送给你。 （服务器响应请求回复浏览器）</li><li>浏览器“解释”网页文件，呈现出网页。</li></ol><hr><h4 id="6-html网页的标准框架"><a href="#6-html网页的标准框架" class="headerlink" title="6.html网页的标准框架"></a>6.html网页的标准框架</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是第一个网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>框架又分为头部和体部，头部用来存放配置信息（如字符集或者css等），体部用来存放具体内容。</p><hr><h4 id="7-HTML：Hyper-Text-Markup-Language"><a href="#7-HTML：Hyper-Text-Markup-Language" class="headerlink" title="7.HTML：Hyper Text Markup Language"></a>7.HTML：Hyper Text Markup Language</h4><p>定义和特点：</p><p>①超文本标记语言</p><p>②HTML 不是一种编程语言，而是一种标记语言</p><p>③标记语言是一套标记标签，HTML 使用标记标签来描述网页</p><p>④HTML 标记标签通常被称为 HTML 标签，它是由尖括号包围的关键词，如\<html> :</html></p><hr><h4 id="8-常见标签的意义"><a href="#8-常见标签的意义" class="headerlink" title="8.常见标签的意义"></a>8.常见标签的意义</h4><p><img src="https://i.loli.net/2018/06/12/5b1fbfc26402c.png" alt="TIM截图20180612204221.png"></p><hr><h4 id="9-标签的分类"><a href="#9-标签的分类" class="headerlink" title="9.标签的分类"></a>9.标签的分类</h4><p>①双标签：由“开始标签”和“结束标签”两部分构成。结束标签比开始标签多了一个“/” </p><p>（比如&lt;body&gt; &lt; /body&gt; ），必须成对使用。</p><p>②单标签：在开始标签中进行关闭，即以开始标签的结束而结束</p><blockquote><p>（比如&lt; meta/&gt; ）。</p></blockquote><p>为什么 HTML 语言设计出单双两种标签?</p><p>双标签：代表标签作用范围</p><p>单标签：无需表达范围，仅在标签出现处有效。</p><p>单标签后面的\可以省略，具体看个人习惯和公司要求。</p><hr><h4 id="10-元素的概念"><a href="#10-元素的概念" class="headerlink" title="10.元素的概念"></a>10.元素的概念</h4><blockquote><p>①HTML 元素指的是从开始标签到结束标签的所有代码。</p></blockquote><blockquote><p>②标签与标签之间是可以嵌套的，但先后书序必须保持一致。</p></blockquote><blockquote><p>③HTML 标签对大小写不敏感。&lt;H1&gt;等同于&lt;h1&gt;，但建议统一规范小写。</p></blockquote><hr><h4 id="11-标签的属性"><a href="#11-标签的属性" class="headerlink" title="11.标签的属性"></a>11.标签的属性</h4><p>HTML 标签可以拥有属性 —— 辅助标签提供更多信息</p><p>属性书写形式：name = “value”</p><p>属性书写位置：开始标签</p><p>不同标签具有不同属性，也可能有相同的属性。</p><hr><h4 id="12-body中常见标签"><a href="#12-body中常见标签" class="headerlink" title="12.body中常见标签"></a>12.body中常见标签</h4><blockquote><p>①标题  &lt; hn&gt;&lt; /hn&gt;(n取值是1-6)：在 HTML 文档中，一篇文章往往需要标题，数值越小标题越大。</p></blockquote><blockquote><p>②段落&lt; p&gt;&lt; /p&gt;: 在网页中显示一段文字 </p></blockquote><blockquote><p>③图片&lt; img&gt;： 在网页中显示一张图片：</p></blockquote><p>属性：</p><p>src : 指明存储图像的位置 (图片的路径)</p><p>alt : 为图片添加替换文本（当图片不显示时显示这个文本）。</p><blockquote><p>④超链接&lt; a href=“”&gt; &lt; /a&gt;： 从一个网页指向一个目标的链接关系。</p></blockquote><p>属性：</p><p>href：必选属性，规定链接目标。（链接的地址）</p><p>target：在何处打开目标:   _blank：在新窗口打开   _self：在当前窗口打开（默认）。</p><hr><h4 id="13-绝对路径和相对路径"><a href="#13-绝对路径和相对路径" class="headerlink" title="13.绝对路径和相对路径"></a>13.绝对路径和相对路径</h4><p>①绝对路径</p><p>本机绝对路径：从盘符开始的完整路径。</p><blockquote><p>e:\my_site\web\image\a.png</p></blockquote><p>网络绝对路径：网络可访问地址。</p><blockquote><p><a href="http://www.a.com/image/a.png" target="_blank" rel="noopener">http://www.a.com/image/a.png</a></p></blockquote><p>优点：</p><p>真实路径，定位清晰。</p><p>缺点：</p><p>本机绝对路径长，容易出错；</p><p>如果站点文件夹被移动，就需要重新修改路径。</p><p>②相对路径</p><p>相对路径是指相对当前文件或目录的路径。</p><p>相对路径规则：</p><blockquote><p>图片和网页在同级目录     src=”./图片名”</p></blockquote><blockquote><p>图片在网页的下一级目录  src=”目录名称/图片名”</p></blockquote><blockquote><p>图片在网页的上一级目录  src=”../图片名”</p></blockquote><p>优点：文件夹被移动，其内部文件的相对路径不变。</p><hr><h4 id="14-无序列表和有序列表"><a href="#14-无序列表和有序列表" class="headerlink" title="14.无序列表和有序列表"></a>14.无序列表和有序列表</h4><p>列表 —— HTML 支持无序列表、有序列表</p><p>①无序列表：是一个没有前后顺序的信息列表。</p><p>②有序列表：是一个有前后顺序的信息列表。</p><p>无序列表使用&lt;ul&gt; 标签，每个列表项使用&lt;li&gt;标签。</p><p>每个列表项默认使用粗体圆点进行标记。</p><p>列表项内部可以使用段落、换行符、图片、链接以及其他列表等。</p><p>有序列表使用&lt;ol&gt; 标签，每个列表项使用&lt;li&gt;标签。</p><p>每个列表项默认使用数字进行标记。</p><p>列表项内部可以使用段落、换行符、图片、链接以及其他列表等。</p><hr><h4 id="15-编码规范"><a href="#15-编码规范" class="headerlink" title="15.编码规范"></a>15.编码规范</h4><p>文件的扩展名要以 .html 或者 .htm 结束。</p><p>文件名由英文字母、数字或下划线组成。</p><p>文件名中不要包含特殊符号，比如空格、$ 等，不使用中文。</p><p>所有的标签必须关闭。</p><p>所有标签和其属性的名字都必须使用小写。</p><p>所有的标签都必须合理嵌套。</p><p>所有的属性必须赋值，所有的属性值必须用引号括起来。</p><hr><h4 id="16-表格的基本语法"><a href="#16-表格的基本语法" class="headerlink" title="16.表格的基本语法"></a>16.表格的基本语法</h4><p>使用表格可以排列页面中的文本、图像以及各种对象。</p><blockquote><p>&lt; table&gt; /table&gt;</p></blockquote><blockquote><p>&lt;table&gt;&lt; /table&gt;</p></blockquote><p>语法：1. 成对出现</p><p>​              2. 表格的开始和结束位置</p><p>语义：定义一个“表格”</p><blockquote><p>&lt; tr&gt; /tr&gt;</p></blockquote><blockquote><p>&lt;tr&gt;&lt; /tr&gt;</p></blockquote><p>语法：</p><ol><li><p>成对出现</p></li><li><blockquote><p>嵌套于&lt; table&gt;&lt; /table&gt;标签内</p></blockquote></li></ol><p>语义：定义表格中的“一行”</p><blockquote><p>&lt; th&gt;&lt; /th&gt;</p></blockquote><p>语法：</p><ol><li><p>成对出现</p></li><li><blockquote><p>嵌套于&lt; tr&gt;&lt; /tr&gt;标签内</p></blockquote></li></ol><p>语义：定义“表头”（特殊的单元格）</p><blockquote><p>&lt; td&gt;&lt; /td&gt;</p></blockquote><p>语法：</p><ol><li><p>成对出现</p></li><li><blockquote><p>嵌套于&lt; tr&gt;&lt; /tr&gt;标签内</p></blockquote></li></ol><p>语义：定义表格中的“一个单元格”</p><blockquote><p>&lt; caption&gt;&lt; /caption&gt;</p></blockquote><p>语法：</p><ol><li><p>成对出现</p></li><li><blockquote><p>嵌套于&lt; table&gt;&lt; /table&gt;标签内</p></blockquote></li></ol><p>语义：定义表格的标题</p><p><strong>实例：</strong></p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_tables2" target="_blank" rel="noopener">没有边框的表格</a></p><p>本例演示一个没有边框的表格。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_headers" target="_blank" rel="noopener">表格中的表头(Heading)</a></p><p>本例演示如何显示表格表头。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_nbsp" target="_blank" rel="noopener">空单元格</a></p><p>本例展示如何使用 “&nbsp;” 处理没有内容的单元格。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_tables3" target="_blank" rel="noopener">带有标题的表格</a></p><p>本例演示一个带标题 (caption) 的表格</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_span" target="_blank" rel="noopener">跨行或跨列的表格单元格</a></p><p>本例演示如何定义跨行或跨列的表格单元格。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_elements" target="_blank" rel="noopener">表格内的标签</a></p><p>本例演示如何显示在不同的元素内显示元素。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_cellpadding" target="_blank" rel="noopener">单元格边距(Cell padding)</a></p><p>本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_cellspacing" target="_blank" rel="noopener">单元格间距(Cell spacing)</a></p><p>本例演示如何使用 Cell spacing 增加单元格之间的距离。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_background" target="_blank" rel="noopener">向表格添加背景颜色或背景图像</a></p><p>本例演示如何向表格添加背景。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_cellbackground" target="_blank" rel="noopener">向表格单元添加背景颜色或者背景图像</a></p><p>本例演示如何向一个或者更多表格单元添加背景。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_align" target="_blank" rel="noopener">在表格单元中排列内容</a></p><p>本例演示如何使用 “align” 属性排列单元格内容,以便创建一个美观的表格。</p><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=html_table_frame" target="_blank" rel="noopener">框架(frame)属性</a></p><p>本例演示如何使用 “frame” 属性来控制围绕表格的边框。</p><hr><h4 id="17-表格的属性"><a href="#17-表格的属性" class="headerlink" title="17.表格的属性"></a>17.表格的属性</h4><p>表格相关属性：</p><p>border：        表格边框的宽度（pixels）</p><p>bordercolor：表格边框的颜色</p><p>background：表格背景图</p><p>bgcolor：       表格背景颜色</p><p>cellpadding :  单元边沿与其内容之间的距离（pixels）</p><p>cellspacing :   单元格之间的空白（pixels）</p><p>width :      规定表格元素的宽度（pixels或%）</p><p>height :     规定表格元素的高度（pixels或%）</p><p>align：      表格的对齐方式（left  center  right）</p><hr><h4 id="18-表单的概念"><a href="#18-表单的概念" class="headerlink" title="18.表单的概念"></a>18.表单的概念</h4><p>表单包含表单元素，其作用是从访问网站的用户那里获得信息，是用户向服务器传输数据的接口。</p><p>表单元素是允许用户在表单中输入信息的元素。（比如：文本框、下拉列表、单选框、复选框等等）。</p><blockquote><p>&lt; form&gt;&lt; /form&gt;</p></blockquote><p>语法：</p><ol><li>成对出现</li><li>表单的开始和结束位置</li></ol><p>语义：定义一个“表单”</p><p>相关属性：</p><p>action：   规定向何处发送提交的表单数据。值：URL</p><p>method：规定以何种方式将表单数据传送到服务器。值：get/post</p><p>所有表单控件都必须放在\<form>\</form>标签之间，否则用户输入的信息无法提交到服务器！</p><hr><h4 id="19-表单的文本框、单-复-选框"><a href="#19-表单的文本框、单-复-选框" class="headerlink" title="19.表单的文本框、单(复)选框"></a>19.表单的文本框、单(复)选框</h4><p><strong>文本框</strong></p><p>当用户要在表单中键入字母、数字等内容时，就会用到文本框。</p><p>&lt; input&gt; 用于搜集用户信息，输入类型是由类型属性（type）定义的。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"password"</span> <span class="attr">name</span> = <span class="string">"名称"</span> <span class="attr">value</span> = <span class="string">"文本"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>属性：</strong></p><ol><li>type：当type = “password”时，输入框为密码输入框。</li><li>name：为输入框命名，以备后台程序使用。</li><li>value：为输入框设置默认值。(一般起到提示作用)</li></ol><p>在使用表单设计调查表时，为了减少用户的操作，推荐使用选择框。</p><p> HTML 中有两种选择框，即单选框和复选框。</p><p>单选框(<strong>单组选框的name必须相同</strong>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"radio"</span>  <span class="attr">value</span> = <span class="string">"Male"</span>      <span class="attr">name</span> = <span class="string">"sex"</span>  <span class="attr">checked</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"radio"</span>  <span class="attr">value</span> = <span class="string">"feMale"</span>   <span class="attr">name</span> = <span class="string">"sex"</span>  /&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>type : 当 type = “radio” 时，控件为单选框。</li><li>value：提交数据到服务器的值。</li><li>name：为控件命名。</li><li>checked：当添加 checked 时，该选项默认选中。</li></ol><hr><p><strong>复选框(name选项最好相同)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span>  <span class="attr">value</span> = <span class="string">"good1"</span>  <span class="attr">name</span> = <span class="string">"goods"</span> /&gt;</span>   </span><br><span class="line">I have a bike </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span>  <span class="attr">value</span> = <span class="string">"good2"</span>  <span class="attr">name</span> = <span class="string">"goods"</span> /&gt;</span>    </span><br><span class="line">I have a car </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>type : 当 type =“checkbox” 时，控件为复选框。</p></li><li><p>value：提交数据到服务器的值。</p></li><li><p>name：为控件命名。</p></li><li><p>checked：当添加 checked时，该选项默认选中。</p></li></ol><hr><h4 id="20-文件上传和按钮"><a href="#20-文件上传和按钮" class="headerlink" title="20.文件上传和按钮"></a>20.文件上传和按钮</h4><p>当 type 属性值为 file 时，用于文件上传。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"file"</span> <span class="attr">name</span> = <span class="string">"files"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>按钮 </strong></p><p>提交按钮：type=”submit”  </p><p> 提交表单信息到服务器</p><p>重置按钮：type=”reset”</p><p>重置表单信息至初始状态</p><p>普通按钮：type=”button”</p><hr><h4 id="21-多行文本域"><a href="#21-多行文本域" class="headerlink" title="21.多行文本域"></a>21.多行文本域</h4><p>多行文本域</p><blockquote><p>标签：&lt; textarea&gt;&lt; /textarea&gt;</p></blockquote><p>相关属性：</p><p>rows：规定文本区内可见行数。</p><p>cols：规定文本区内可见列数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">name</span> = <span class="string">"cat "</span> <span class="attr">rows</span> = <span class="string">"3"</span> <span class="attr">cols</span> = <span class="string">"30"</span>&gt;</span> </span><br><span class="line">     The cat was playing in the garden.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="22-下拉列表"><a href="#22-下拉列表" class="headerlink" title="22.下拉列表"></a>22.下拉列表</h4><p>下拉列表</p><blockquote><p>标签：&lt; select&gt;&lt; /select&gt;</p></blockquote><blockquote><p>列表项：&lt; option&gt;&lt; /option&gt;</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span> = <span class="string">"class"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> = <span class="string">"one"</span>  <span class="attr">selected</span>&gt;</span> 软件一班 <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> = <span class="string">"two"</span>&gt;</span> 软件二班 <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> = <span class="string">"three"</span>&gt;</span> 软件三班 <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="23-表单标签总结"><a href="#23-表单标签总结" class="headerlink" title="23.表单标签总结"></a>23.表单标签总结</h4><p><img src="https://i.loli.net/2018/06/12/5b1fc90659fff.png" alt="TIM截图20180612212138.png"></p><hr><h4 id="24-label标签"><a href="#24-label标签" class="headerlink" title="24.label标签"></a>24.label标签</h4><blockquote><p>&lt; label for = “控件id名称”&gt; 用户名：&lt; /label&gt;</p></blockquote><blockquote><p>&lt; input type = “text” id = “id名称” /&gt;</p></blockquote><p>当鼠标点击“用户名：”时，所关联的控件会获得焦点。</p><p>label 元素不会向用户呈现任何特殊效果，它只是增加了用户体验。</p><p>点击 label 元素内文本，就会触发此控件。即当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>]]></content>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言期末编程题总结</title>
      <link href="/2018/09/02/C/c%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/02/C/c%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len)</span>  <span class="comment">//冒泡排序：升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;     <span class="comment">//排序规则，可以任意修改</span></span><br><span class="line">                temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    BubbleSort(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,min,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        min =i;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;len;++j)&#123;    <span class="comment">//从第i个位置遍历到末尾</span></span><br><span class="line">            <span class="keyword">if</span>(arr[min]&gt;arr[j])&#123;    <span class="comment">//如果min记录的下标元素大于后面的元素，则将更小的下标赋给min</span></span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =arr[min];      <span class="comment">//将第i个位置的元素和它后面最小的元素进行交换</span></span><br><span class="line">        arr[min]=arr[i];</span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    SelectionSort(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- more --><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,key;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        key=arr[i];      <span class="comment">//将要比较的值存起来，相当于从数组里面拿出来，给数组留了一个空位</span></span><br><span class="line">        j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;key)&#123;   <span class="comment">//将i前面的数组元素当成有序的，这个循环的目的是找到插入位置</span></span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;           <span class="comment">//将key插入对应位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    InsertSort(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-数组逆序"><a href="#3-数组逆序" class="headerlink" title="3.数组逆序"></a>3.数组逆序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        a[i]=a[len-i<span class="number">-1</span>];</span><br><span class="line">        a[len-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    inverse(a,<span class="number">5</span>);</span><br><span class="line">    inverse(b,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-字符数组排序"><a href="#4-字符数组排序" class="headerlink" title="4.字符数组排序"></a>4.字符数组排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> len)</span>  <span class="comment">//冒泡排序：升序,将传入参数改成char *类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;     <span class="comment">//排序规则，两个字符比较的是ascii码</span></span><br><span class="line">                temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>]=&#123;<span class="string">'g'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'a'</span>,<span class="string">'w'</span>,<span class="string">'y'</span>,<span class="string">'a'</span>,<span class="string">'u'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>&#125;;</span><br><span class="line">    BubbleSort(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)<span class="built_in">printf</span>(<span class="string">"%c "</span>,arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5-strlen函数的实现"><a href="#5-strlen函数的实现" class="headerlink" title="5.strlen函数的实现"></a>5.strlen函数的实现</h4><p>strlen函数的作用的统计字符串长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_Strlen</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*(str++)!=<span class="string">'\0'</span>)len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> *str=<span class="string">"helloworld!"</span>;</span><br><span class="line">    len=My_Strlen(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s的长度为：%d\n"</span>,str,len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="6-strcpy函数的实现"><a href="#6-strcpy函数的实现" class="headerlink" title="6.strcpy函数的实现"></a>6.strcpy函数的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">My_Strcpy</span><span class="params">(<span class="keyword">char</span> *des,<span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret=des;</span><br><span class="line">    <span class="keyword">while</span>(*des++=*src++);  <span class="comment">//省略了（*des++ =*src++）！='\0'</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src[<span class="number">100</span>]=<span class="string">"hello,world!"</span>;</span><br><span class="line">    <span class="keyword">char</span> des[<span class="number">100</span>];</span><br><span class="line">    My_Strcpy(des,src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,des);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7-strcmp函数的实现"><a href="#7-strcmp函数的实现" class="headerlink" title="7.strcmp函数的实现"></a>7.strcmp函数的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//防止传入的字符串发生改变，使用const关键字，不加也可以实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_Strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1,<span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;    <span class="comment">//这是C语言正统写法，也可以简化用1 0 -1来分别代表大于等于小于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">char</span> *str1=<span class="string">"14345"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2=<span class="string">"13456"</span>;</span><br><span class="line">    ans=My_Strcmp(str1,str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="8-strcat函数的实现"><a href="#8-strcat函数的实现" class="headerlink" title="8.strcat函数的实现"></a>8.strcat函数的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//防止传入的字符串发生改变，使用const关键字，不加也可以实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">My_Strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret=str1;</span><br><span class="line">    <span class="comment">//等价于 *str1++！='\0'  找到str1的\0的位置</span></span><br><span class="line">    <span class="comment">//不能把str1++和while循环合并成while(*str1++)，否则会多执行一次++服务</span></span><br><span class="line">    <span class="keyword">while</span>(*str1)str1++;</span><br><span class="line">    <span class="keyword">while</span>(*str1++ = *str2++);  <span class="comment">//将str2拼接到str1上</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">100</span>]=<span class="string">",world!"</span>;</span><br><span class="line">    My_Strcat(str1,str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-二分查找"><a href="#9-二分查找" class="headerlink" title="9.二分查找"></a>9.二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;; <span class="comment">//二分查找数组必须是有序的</span></span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>,high=<span class="number">9</span>; <span class="comment">//表示区间的范围</span></span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入要查找的key值:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high) <span class="comment">//当low与high重合时是临界条件</span></span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>; <span class="comment">//二分法找区间中点</span></span><br><span class="line"><span class="keyword">if</span>(num[mid]==key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"已找到%d,在数组的第%d个位置上\n"</span>,key,mid+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; e</span><br><span class="line"><span class="function">lse <span class="title">if</span><span class="params">(num[mid]&gt;key)</span> <span class="comment">//如果中点值大于key，那么key在中点的左边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">high=mid<span class="number">-1</span>; <span class="comment">//mid为中点,mid-1为数组左边</span></span><br><span class="line">&#125; e</span><br><span class="line">lse</span><br><span class="line">low=mid+<span class="number">1</span>; <span class="comment">//反之在中点右边，mid+1为中点右边</span></span><br><span class="line">&#125; i</span><br><span class="line">f(low&gt;high) <span class="comment">//如果越界，则说明未找到key值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到%d\n"</span>,key);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="10-矩阵乘法"><a href="#10-矩阵乘法" class="headerlink" title="10.矩阵乘法"></a>10.矩阵乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n,m,k,l;</span><br><span class="line">    <span class="keyword">int</span> num1[N][N]=&#123;<span class="number">0</span>&#125;,num2[N][N]=&#123;<span class="number">0</span>&#125;,num3[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//比如 m*n 和n*k的矩阵相乘</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入矩阵的m n k的值:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入第一个矩阵:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num1[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入第二个矩阵:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num2[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//矩阵相乘</span></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">            <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n;++l)</span><br><span class="line">            &#123;</span><br><span class="line">                num3[i][j]+=num1[i][l]*num2[l][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,num3[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-进制转换-十进制内的进制转换"><a href="#11-进制转换-十进制内的进制转换" class="headerlink" title="11.进制转换(十进制内的进制转换)"></a>11.进制转换(十进制内的进制转换)</h4><p>将定义的BIN后面的数改成相应进制即可实现对应的进制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIN 3   <span class="comment">//只对10进制内的进制有效,</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要转换成%d进制的10进制数:"</span>,BIN);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans[i++]=n%BIN;    <span class="comment">//将余数存储在数组中，方便逆序输出</span></span><br><span class="line">        n/=BIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);  <span class="comment">//逆序输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="12-任意进制转换"><a href="#12-任意进制转换" class="headerlink" title="12.任意进制转换"></a>12.任意进制转换</h4><p>将定义的BIN后面的数改成相应进制即可实现对应的进制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIN 16   <span class="comment">//对16进制以内有效</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[]=<span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要转换为%d进制的10进制数:"</span>,BIN);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d转换为%d进制后为:\n"</span>,n,BIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查表转换，实现任意进制</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans[i++]=ch[n%BIN];</span><br><span class="line">        n/= BIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,ans[i]);   <span class="comment">//逆序输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="13-首字母大写"><a href="#13-首字母大写" class="headerlink" title="13.首字母大写"></a>13.首字母大写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum;</span><br><span class="line">    i=sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">    str[<span class="number">0</span>]-=<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(str);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)str[i+<span class="number">1</span>]-=<span class="number">32</span>;   <span class="comment">//大写字母ASCII码+32=小写字母ASCII码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="14-素数判定"><a href="#14-素数判定" class="headerlink" title="14.素数判定"></a>14.素数判定</h4><p>这里的输入情况不考虑0和1，只考虑2以上的正整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要判断的数："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(isprime(n)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d不是素数\n"</span>,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d是素数\n"</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="15-判断回文串"><a href="#15-判断回文串" class="headerlink" title="15.判断回文串"></a>15.判断回文串</h4><p>回文串：就是正着读反着读都是一样的字符串，如12321,101等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,len;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;   <span class="comment">//标记变量，用来记录字符串是否是回文串</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要判断的字符串:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    len =<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]!=str[len<span class="number">-1</span>-i])&#123;   <span class="comment">//如果是回文串，那么首尾对饮字符应该是相等的</span></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s是一个回文串\n"</span>,str);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s不是一个回文串\n"</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第五届图灵杯网络同步赛题解</title>
      <link href="/2018/09/02/problem%20solved/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%9B%BE%E7%81%B5%E6%9D%AF%E9%A2%98%E8%A7%A3/"/>
      <url>/2018/09/02/problem%20solved/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%9B%BE%E7%81%B5%E6%9D%AF%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本次比赛题解，题目名是超链接，点击即可跳转。</p><h4 id="A题-与众不同的Helloworld"><a href="#A题-与众不同的Helloworld" class="headerlink" title="A题:与众不同的Helloworld!"></a>A题:<a href="http://newoj.acmclub.cn/contests/1365/problem/0" target="_blank" rel="noopener">与众不同的Helloworld!</a></h4><p>水题：不解释<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Helloworld!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="B题-Dong先生的计算题"><a href="#B题-Dong先生的计算题" class="headerlink" title="B题:Dong先生的计算题"></a>B题:<a href="http://newoj.acmclub.cn/contests/1365/problem/1" target="_blank" rel="noopener">Dong先生的计算题</a></h4><p>水题，同样不解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">10</span>!=<span class="number">0</span>)n--;</span><br><span class="line">        <span class="keyword">else</span> n/=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="C题：养生专家"><a href="#C题：养生专家" class="headerlink" title="C题：养生专家"></a>C题：<a href="http://newoj.acmclub.cn/contests/1365/problem/2" target="_blank" rel="noopener">养生专家</a></h4><p>遍历就能过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> n,k;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((arr[i]==arr[j]))</span><br><span class="line">                    arr[j]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arr[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="D题：贴心的jun老板"><a href="#D题：贴心的jun老板" class="headerlink" title="D题：贴心的jun老板"></a>D题：<a href="http://newoj.acmclub.cn/contests/1365/problem/3" target="_blank" rel="noopener">贴心的jun老板</a></h4><p>子串查找和替换，不解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">while</span>((t=str.find(<span class="string">"666"</span>))!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        str[t]=<span class="string">' '</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="E题-凹凸大赛"><a href="#E题-凹凸大赛" class="headerlink" title="E题: 凹凸大赛"></a>E题:<a href="http://newoj.acmclub.cn/contests/1365/problem/4" target="_blank" rel="noopener"> 凹凸大赛</a></h4><p>注意边界，当k等于0时分类讨论，k不要越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">0</span>]==<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;n&amp;&amp;v[k<span class="number">-1</span>]==v[k])<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;v[k<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="F题：Doki-Doki-Literature-Club"><a href="#F题：Doki-Doki-Literature-Club" class="headerlink" title="F题：Doki Doki Literature Club"></a>F题：<a href="http://newoj.acmclub.cn/contests/1365/problem/5" target="_blank" rel="noopener">Doki Doki Literature Club</a></h4><p>int 就能过可以不用long long，求出最大序列和和最小序列和，然后求出满足的范围即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ops[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,w;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    ll temp;</span><br><span class="line">    ll maxv=<span class="number">0</span>;</span><br><span class="line">    ll minv=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        sum+=temp;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;minv)minv=sum;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;maxv)maxv=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxv&gt;w||<span class="built_in">abs</span>(minv)&gt;w||(w-maxv&lt;<span class="built_in">abs</span>(minv)))<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(w-maxv+minv+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="G题：找弟子"><a href="#G题：找弟子" class="headerlink" title="G题：找弟子"></a>G题：<a href="http://newoj.acmclub.cn/contests/1365/problem/6" target="_blank" rel="noopener">找弟子</a></h4><p>思路：把所有人按照能力值高低排序，然后对每个人用lower_bound找有多少人能力值比他能力值低，并用ans数组记录下来。最后读入不能相处的人，如果的两人能力值相等，则不会影响任何一个答案，如果能力值不相等，则能力值较高者所对应的ans值需要减一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll *a =<span class="keyword">new</span> ll[n+<span class="number">10</span>];</span><br><span class="line">    ll *b =<span class="keyword">new</span> ll[n+<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> *ans=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(ll)*n);</span><br><span class="line">    sort(b,b+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=lower_bound(b,b+n,a[i])-b;</span><br><span class="line">        ans[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(ans[a<span class="number">-1</span>]&gt;ans[b<span class="number">-1</span>])</span><br><span class="line">            ans[a<span class="number">-1</span>]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[b<span class="number">-1</span>]&gt;ans[a<span class="number">-1</span>])</span><br><span class="line">            ans[b<span class="number">-1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    del []a;</span><br><span class="line">    del []b;</span><br><span class="line">    del []ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="H题：-CC的心意"><a href="#H题：-CC的心意" class="headerlink" title="H题： CC的心意"></a>H题：<a href="http://newoj.acmclub.cn/contests/1365/problem/7" target="_blank" rel="noopener"> CC的心意</a></h4><p>能被25整除的充要条件就是末两位是00，25，50，75。如果没有过程中不出现前导0这一限制，显然对每种情况，贪心取尽量低位即可。本题的关键就在于如何满足这个条件，首先有个”显然”的方法：讨论。。。然后会发现情况太多，过于复杂。所以，我们只好从交换本身的性质入手，找找易于实现的写法。注意到我们最多移动3个数字的位置，最终两个最低位的数，可能还有一个非0数作为最高位，而根据交换的性质，可以发现先移动那个数对于最终的结果没有影响，按照题意我们要先移动那个作为最高位的数，那现在既然调换顺序没有影响，不如把那个数留到最后再交换。于是，这道题的做法就出来了：</p><p>1）贪心模拟，确定最低两位</p><p>2）贪心模拟，确定最高位</p><p>3）检查最后两位是否合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,st,ed) for (int i=st;i&lt;=ed;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(x,t) memcpy(x,t,sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">21</span>],tmp[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> bct[<span class="number">21</span>],n,ans=INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">    copy(str,tmp);</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,pos;</span><br><span class="line">    <span class="keyword">for</span> (pos=n;pos;pos--) <span class="keyword">if</span> (str[pos]==b)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pos) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">for</span> (;pos&lt;n;pos++,ret++) swap(str[pos],str[pos+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (pos=n<span class="number">-1</span>;pos;pos--) <span class="keyword">if</span> (str[pos]==a)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pos) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">for</span> (;pos&lt;n<span class="number">-1</span>;pos++,ret++)swap(str[pos],str[pos+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (pos=<span class="number">1</span>;pos&lt;=n;pos++) <span class="keyword">if</span> (str[pos]!=<span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (;pos&gt;<span class="number">1</span>;pos--,ret++)  swap(str[pos],str[pos<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (str[n<span class="number">-1</span>]!=a||str[n]!=b) ret=INF;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">     n=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    copy(tmp,str);</span><br><span class="line">    ans= min(ans,solve(<span class="string">'0'</span>,<span class="string">'0'</span>));</span><br><span class="line">    ans= min(ans,solve(<span class="string">'2'</span>,<span class="string">'5'</span>));</span><br><span class="line">    ans= min(ans,solve(<span class="string">'5'</span>,<span class="string">'0'</span>));</span><br><span class="line">    ans= min(ans,solve(<span class="string">'7'</span>,<span class="string">'5'</span>));</span><br><span class="line">    <span class="keyword">if</span> (ans==INF) ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件的基本操作（总览导图篇）</title>
      <link href="/2018/08/08/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%80%BB%E8%A7%88%E5%AF%BC%E5%9B%BE%E7%AF%87)/"/>
      <url>/2018/08/08/C/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%80%BB%E8%A7%88%E5%AF%BC%E5%9B%BE%E7%AF%87)/</url>
      <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/06/21/5b2b21dce0b1e.png" alt="c语言文件操作.png"><br><a id="more"></a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>自动类型转换详解</title>
      <link href="/2018/08/01/C/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/08/01/C/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h1 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h1><p>​    在赋值语句中，如果等号左边的变量类型为T1，等号右边的变量或常量类型为T2，T1和T2不相同，那么编译器会将等号右边的变量或常量的值自动转换成一个T1类型的值，再将此值赋给等号左边的变量。这个过程叫做<strong>自动类型转换</strong>。</p><p>​    能进行自动类型转换的前提是：T1和T2是两个兼容的类型，如果两个类型不兼容，那么就不能进行自动类型转换，这样的赋值语句编译器会报错。</p><p>​    int、long、short、unsigned int、unsigned long、unsigned short、char、unsigned char、float、double这几个类型是两两兼容的，可以进行自动类型转换。</p><p>​    但指针类型、结构类型，它们和上述的所有类型都是不兼容的，出现这样的赋值语句时，编译器会报错。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1378</span>;</span><br><span class="line">    <span class="keyword">short</span> n2;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">double</span> d1=<span class="number">7.809</span>;</span><br><span class="line">    <span class="keyword">double</span> d2;</span><br><span class="line">    n2 =c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%c,n2=%d\n"</span>,c,n2);</span><br><span class="line">    c=n1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%c,n1=%d\n"</span>,c,n1);</span><br><span class="line">    d2=n1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n1=%d\n"</span>,n1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d2=%f"</span>,d2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><blockquote><p>c=a,n2=97</p><p>c=b,n1=1378</p><p>n1=7</p><p>d2=7.000000</p></blockquote><hr><p><strong>敲黑板，集中点</strong></p><p>①执行语句n2=c时，由于变量c内存放的是字符‘a’的ASCII码，即十进制整数97，因此n2的值由此变为97。</p><p>②执行语句c=n1时，等号左边是char类型的变量，右边是int类型的变量，语句执行时，先将右边int类型的值自动转换成一个char类型的值，再赋给c。因为char类型的变量只有一个字节，所以自动转换的过程就是丢弃n1的高3位字节，只取n1中最低的那个字节赋值给c。n1的值是1378，表示成十六进制就是562，最低的字节是十六进制的62，所以执行完这个语句后，c中的值就是十六进制中的62，换算成十进制就是98，98是字母’b’的ASCII码，因此c中就存放着字母’b’。</p><p>③执行语句d2=n1时，需将浮点数值7.809自动转换成一个整型值，再复制给n1，在C/C++中，浮点数自动转换成整数的规则是去掉小数部分，因此n1的值变成了7。</p><p><strong>思考题：</strong></p><p>​    假定char类型的变量c中存着一个’w’之前的小写字母，请写一条赋值语句，使得c变为其后的第4个字母，比如将c从’a’变成’e’。</p>]]></content>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
